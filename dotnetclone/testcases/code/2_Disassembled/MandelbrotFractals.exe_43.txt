
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System.Numerics
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly MandelbrotFractals
{
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 12 4D 61 6E 64 65 6C 62 72 6F 74 46 72 61   // ...MandelbrotFra
                                                                                                63 74 61 6C 73 00 00 )                            // ctals..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 12 4D 61 6E 64 65 6C 62 72 6F 74 46 72 61   // ...MandelbrotFra
                                                                                              63 74 61 6C 73 00 00 )                            // ctals..
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 35 62 37 31 63 62 39 37 2D 32 35 65 36   // ..$5b71cb97-25e6
                                                                                                  2D 34 61 36 34 2D 39 35 36 32 2D 30 39 66 32 31   // -4a64-9562-09f21
                                                                                                  33 31 66 64 66 39 34 00 00 )                      // 31fdf94..
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .permissionset reqmin
             = {[mscorlib]System.Security.Permissions.SecurityPermissionAttribute = {property bool 'SkipVerification' = bool(true)}}
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public Microsoft.Pcp.Pfx.InteractiveFractal.MainForm.resources
{
  // Offset: 0x00000000 Length: 0x000000B4
}
.mresource public Samples.Properties.Resources.resources
{
  // Offset: 0x000000B8 Length: 0x000000B4
}
.module MandelbrotFractals.exe
// MVID: {4D3B41F3-F98A-49B6-99C0-30C7EBBEE8C7}
.custom instance void [mscorlib]System.Security.UnverifiableCodeAttribute::.ctor() = ( 01 00 00 00 ) 
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x01220000


// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi beforefieldinit Samples.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\Properties\Resources.Designer.cs' 
//000031:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000032:         internal Resources() {
    IL_0007:  nop
//000033:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000034:         
//000035:         /// <summary>
//000036:         ///   Returns the cached ResourceManager instance used by this class.
//000037:         /// </summary>
//000038:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000039:         internal static global::System.Resources.ResourceManager ResourceManager {
//000040:             get {
    IL_0000:  nop
//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager Samples.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  call       bool [mscorlib]System.Object::ReferenceEquals(object,
                                                                       object)
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.2
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Samples.Properties.Resources", typeof(Resources).Assembly);
//000043:                     resourceMan = temp;
//000044:                 }
//000045:                 return resourceMan;
//000046:             }
//000047:         }
//000048:         
//000049:         /// <summary>
//000050:         ///   Overrides the current thread's CurrentUICulture property for all
//000051:         ///   resource lookups using this strongly typed resource class.
//000052:         /// </summary>
//000053:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000054:         internal static global::System.Globalization.CultureInfo Culture {
//000055:             get {
//000056:                 return resourceCulture;
//000057:             }
//000058:             set {
//000059:                 resourceCulture = value;
//000060:             }
//000061:         }
//000062:     }
//000063: }
    IL_0010:  ldloc.2
    IL_0011:  brtrue.s   IL_0035

//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0013:  nop
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Samples.Properties.Resources", typeof(Resources).Assembly);
    IL_0014:  ldstr      "Samples.Properties.Resources"
    IL_0019:  ldtoken    Samples.Properties.Resources
    IL_001e:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0023:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0028:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002d:  stloc.0
//000043:                     resourceMan = temp;
    IL_002e:  ldloc.0
    IL_002f:  stsfld     class [mscorlib]System.Resources.ResourceManager Samples.Properties.Resources::resourceMan
//000044:                 }
    IL_0034:  nop
//000045:                 return resourceMan;
    IL_0035:  ldsfld     class [mscorlib]System.Resources.ResourceManager Samples.Properties.Resources::resourceMan
    IL_003a:  stloc.1
    IL_003b:  br.s       IL_003d

//000046:             }
    IL_003d:  ldloc.1
    IL_003e:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000047:         }
//000048:         
//000049:         /// <summary>
//000050:         ///   Overrides the current thread's CurrentUICulture property for all
//000051:         ///   resource lookups using this strongly typed resource class.
//000052:         /// </summary>
//000053:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000054:         internal static global::System.Globalization.CultureInfo Culture {
//000055:             get {
    IL_0000:  nop
//000056:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Samples.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000057:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000058:             set {
    IL_0000:  nop
//000059:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo Samples.Properties.Resources::resourceCulture
//000060:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager Samples.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .set void Samples.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
    .get class [mscorlib]System.Globalization.CultureInfo Samples.Properties.Resources::get_Culture()
  } // end of property Resources::Culture
} // end of class Samples.Properties.Resources

.class private abstract auto ansi sealed beforefieldinit Microsoft.Pcp.Pfx.InteractiveFractal.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main() cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       26 (0x1a)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\Program.cs' 
//000012:         {
    IL_0000:  nop
//000013:             Application.EnableVisualStyles();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
    IL_0006:  nop
//000014:             Application.SetCompatibleTextRenderingDefault(false);
    IL_0007:  ldc.i4.0
    IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
    IL_000d:  nop
//000015:             Application.Run(new MainForm());
    IL_000e:  newobj     instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::.ctor()
    IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_0018:  nop
//000016:         }
    IL_0019:  ret
  } // end of method Program::Main

} // end of class Microsoft.Pcp.Pfx.InteractiveFractal.Program

.class public auto ansi beforefieldinit Microsoft.Pcp.Pfx.InteractiveFractal.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass2'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass4'
           extends [mscorlib]System.Object
    {
      .field public class [System]System.Diagnostics.Stopwatch sw
      .field public class [System.Drawing]System.Drawing.Bitmap bmp
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClass4'::.ctor

    } // end of class '<>c__DisplayClass4'

    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass6'
           extends [mscorlib]System.Object
    {
      .field public class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4' 'CS$<>8__locals5'
      .field public class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' 'CS$<>8__locals3'
      .field public float64 ppms
      .field public class [System.Drawing]System.Drawing.Image old
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClass6'::.ctor

      .method public hidebysig instance void 
              '<UpdateImageAsync>b__1'() cil managed
      {
        // Code size       250 (0xfa)
        .maxstack  5
        .locals init ([0] bool CS$4$0000,
                 [1] int64 CS$0$0001)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\MainForm.cs' 
//000165:                     {
        IL_0000:  nop
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_0007:  ldfld      valuetype [mscorlib]System.DateTime Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::timeOfRequest
        IL_000c:  ldarg.0
        IL_000d:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_0012:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
        IL_0017:  ldfld      valuetype [mscorlib]System.DateTime Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastUpdateTime
        IL_001c:  call       bool [mscorlib]System.DateTime::op_GreaterThan(valuetype [mscorlib]System.DateTime,
                                                                            valuetype [mscorlib]System.DateTime)
        IL_0021:  ldc.i4.0
        IL_0022:  ceq
        IL_0024:  stloc.0
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
        IL_0025:  ldloc.0
        IL_0026:  brtrue     IL_00e8

//000170:                         {
        IL_002b:  nop
//000171:                             old = mandelbrotPb.Image;
        IL_002c:  ldarg.0
        IL_002d:  ldarg.0
        IL_002e:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_0033:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
        IL_0038:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
        IL_003d:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
        IL_0042:  stfld      class [System.Drawing]System.Drawing.Image Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::old
//000172:                             mandelbrotPb.Image = bmp;
        IL_0047:  ldarg.0
        IL_0048:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_004d:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
        IL_0052:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
        IL_0057:  ldarg.0
        IL_0058:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals5'
        IL_005d:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::bmp
        IL_0062:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
        IL_0067:  nop
//000173:                             _lastUpdateTime = timeOfRequest;
        IL_0068:  ldarg.0
        IL_0069:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_006e:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
        IL_0073:  ldarg.0
        IL_0074:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_0079:  ldfld      valuetype [mscorlib]System.DateTime Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::timeOfRequest
        IL_007e:  stfld      valuetype [mscorlib]System.DateTime Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastUpdateTime
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
        IL_0083:  ldarg.0
        IL_0084:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_0089:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
        IL_008e:  ldstr      "Interactive Fractal ({0}x) - PPMS: {1} - Time: {2}"
        IL_0093:  ldarg.0
        IL_0094:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
        IL_0099:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
        IL_009e:  ldfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_parallelRendering
        IL_00a3:  brtrue.s   IL_00a8

        IL_00a5:  ldc.i4.1
        IL_00a6:  br.s       IL_00ad

        IL_00a8:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
        IL_00ad:  box        [mscorlib]System.Int32
        IL_00b2:  ldarg.0
        IL_00b3:  ldflda     float64 Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::ppms
        IL_00b8:  ldstr      "F2"
        IL_00bd:  call       instance string [mscorlib]System.Double::ToString(string)
        IL_00c2:  ldarg.0
        IL_00c3:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals5'
        IL_00c8:  ldfld      class [System]System.Diagnostics.Stopwatch Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::sw
        IL_00cd:  callvirt   instance int64 [System]System.Diagnostics.Stopwatch::get_ElapsedMilliseconds()
        IL_00d2:  stloc.1
        IL_00d3:  ldloca.s   CS$0$0001
        IL_00d5:  call       instance string [mscorlib]System.Int64::ToString()
        IL_00da:  call       string [mscorlib]System.String::Format(string,
                                                                    object,
                                                                    object,
                                                                    object)
        IL_00df:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
        IL_00e4:  nop
//000175:                         }
        IL_00e5:  nop
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
        IL_00e6:  br.s       IL_00f9

//000177:                         else bmp.Dispose();
        IL_00e8:  ldarg.0
        IL_00e9:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals5'
        IL_00ee:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::bmp
        IL_00f3:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
        IL_00f8:  nop
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
        IL_00f9:  ret
      } // end of method '<>c__DisplayClass6'::'<UpdateImageAsync>b__1'

    } // end of class '<>c__DisplayClass6'

    .field public valuetype [System.Drawing]System.Drawing.Size renderSize
    .field public valuetype [mscorlib]System.DateTime timeOfRequest
    .field public valuetype [mscorlib]System.Threading.CancellationToken token
    .field public class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass2'::.ctor

    .method public hidebysig instance void 
            '<UpdateImageAsync>b__0'() cil managed
    {
      // Code size       230 (0xe6)
      .maxstack  6
      .locals init ([0] class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6' 'CS$<>8__locals7',
               [1] class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4' 'CS$<>8__locals5',
               [2] bool CS$4$0000)
      IL_0000:  newobj     instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::.ctor()
      IL_0005:  stloc.1
//000151:             {
      IL_0006:  nop
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
      IL_0007:  ldloc.1
      IL_0008:  call       class [System]System.Diagnostics.Stopwatch [System]System.Diagnostics.Stopwatch::StartNew()
      IL_000d:  stfld      class [System]System.Diagnostics.Stopwatch Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::sw
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
      IL_0012:  ldloc.1
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
      IL_0019:  ldfld      valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
      IL_001e:  ldarg.0
      IL_001f:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::renderSize
      IL_0024:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
      IL_0029:  ldarg.0
      IL_002a:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::renderSize
      IL_002f:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
      IL_0034:  ldarg.0
      IL_0035:  ldfld      valuetype [mscorlib]System.Threading.CancellationToken Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::token
      IL_003a:  ldarg.0
      IL_003b:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
      IL_0040:  ldfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_parallelRendering
      IL_0045:  call       class [System.Drawing]System.Drawing.Bitmap Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator::Create(valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition,
                                                                                                                                        int32,
                                                                                                                                        int32,
                                                                                                                                        valuetype [mscorlib]System.Threading.CancellationToken,
                                                                                                                                        bool)
      IL_004a:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::bmp
//000157:                 if (bmp != null)
      IL_004f:  ldloc.1
      IL_0050:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::bmp
      IL_0055:  ldnull
      IL_0056:  ceq
      IL_0058:  stloc.2
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
      IL_0059:  ldloc.2
      IL_005a:  brtrue     IL_00e4

      IL_005f:  newobj     instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::.ctor()
      IL_0064:  stloc.0
      IL_0065:  ldloc.0
      IL_0066:  ldloc.1
      IL_0067:  stfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals5'
      IL_006c:  ldloc.0
      IL_006d:  ldarg.0
      IL_006e:  stfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'CS$<>8__locals3'
//000158:                 {
      IL_0073:  nop
//000159:                     sw.Stop();
      IL_0074:  ldloc.1
      IL_0075:  ldfld      class [System]System.Diagnostics.Stopwatch Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::sw
      IL_007a:  callvirt   instance void [System]System.Diagnostics.Stopwatch::Stop()
      IL_007f:  nop
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
      IL_0080:  ldloc.0
      IL_0081:  ldarg.0
      IL_0082:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::renderSize
      IL_0087:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
      IL_008c:  ldarg.0
      IL_008d:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::renderSize
      IL_0092:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
      IL_0097:  mul
      IL_0098:  conv.r8
      IL_0099:  ldloc.1
      IL_009a:  ldfld      class [System]System.Diagnostics.Stopwatch Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass4'::sw
      IL_009f:  callvirt   instance int64 [System]System.Diagnostics.Stopwatch::get_ElapsedMilliseconds()
      IL_00a4:  conv.r8
      IL_00a5:  div
      IL_00a6:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::ppms
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
      IL_00ab:  ldloc.0
      IL_00ac:  ldnull
      IL_00ad:  stfld      class [System.Drawing]System.Drawing.Image Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::old
//000164:                     BeginInvoke((MethodInvoker)delegate
      IL_00b2:  ldarg.0
      IL_00b3:  ldfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
      IL_00b8:  ldloc.0
      IL_00b9:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::'<UpdateImageAsync>b__1'()
      IL_00bf:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MethodInvoker::.ctor(object,
                                                                                                         native int)
      IL_00c4:  call       instance class [mscorlib]System.IAsyncResult [System.Windows.Forms]System.Windows.Forms.Control::BeginInvoke(class [mscorlib]System.Delegate)
      IL_00c9:  pop
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
      IL_00ca:  ldloc.0
      IL_00cb:  ldfld      class [System.Drawing]System.Drawing.Image Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::old
      IL_00d0:  ldnull
      IL_00d1:  ceq
      IL_00d3:  stloc.2
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
      IL_00d4:  ldloc.2
      IL_00d5:  brtrue.s   IL_00e3

//000179:                     if (old != null) old.Dispose();
      IL_00d7:  ldloc.0
      IL_00d8:  ldfld      class [System.Drawing]System.Drawing.Image Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'/'<>c__DisplayClass6'::old
      IL_00dd:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
      IL_00e2:  nop
//000180:                 }
      IL_00e3:  nop
//000181:             }, token);
      IL_00e4:  nop
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
      IL_00e5:  ret
    } // end of method '<>c__DisplayClass2'::'<UpdateImageAsync>b__0'

  } // end of class '<>c__DisplayClass2'

  .field private static literal string _formTitle = "Interactive Fractal ({0}x) - PPMS: {1} - Time: {2}"
  .field private valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition _mandelbrotWindow
  .field private valuetype [System.Drawing]System.Drawing.Size _lastWindowSize
  .field private valuetype [System.Drawing]System.Drawing.Point _lastMousePosition
  .field private class [mscorlib]System.Threading.CancellationTokenSource _lastCancellation
  .field private valuetype [mscorlib]System.DateTime _lastUpdateTime
  .field private bool _leftMouseDown
  .field private bool _parallelRendering
  .field private class [System]System.ComponentModel.IContainer components
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox mandelbrotPb
  .field private class [System.Windows.Forms]System.Windows.Forms.StatusStrip statusStrip1
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel1
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       71 (0x47)
    .maxstack  2
//000017:         MandelbrotPosition _mandelbrotWindow = MandelbrotPosition.Default;
    IL_0000:  ldarg.0
    IL_0001:  call       valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::get_Default()
    IL_0006:  stfld      valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
//000018:         /// <summary>The last known size of the main window.</summary>
//000019:         private Size _lastWindowSize = Size.Empty;
    IL_000b:  ldarg.0
    IL_000c:  ldsfld     valuetype [System.Drawing]System.Drawing.Size [System.Drawing]System.Drawing.Size::Empty
    IL_0011:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
//000020:         /// <summary>The last known position of the mouse.</summary>
//000021:         private Point _lastMousePosition;
//000022:         /// <summary>The most recent cancellation source to cancel the last task.</summary>
//000023:         private CancellationTokenSource _lastCancellation;
//000024:         /// <summary>The last time the image was updated.</summary>
//000025:         private DateTime _lastUpdateTime = DateTime.MinValue;
    IL_0016:  ldarg.0
    IL_0017:  ldsfld     valuetype [mscorlib]System.DateTime [mscorlib]System.DateTime::MinValue
    IL_001c:  stfld      valuetype [mscorlib]System.DateTime Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastUpdateTime
//000026:         /// <summary>Whether the left mouse button is currently pressed on the picture box.</summary>
//000027:         private bool _leftMouseDown = false;
    IL_0021:  ldarg.0
    IL_0022:  ldc.i4.0
    IL_0023:  stfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_leftMouseDown
//000028:         /// <summary>
//000029:         /// The format string to use for the main form's title; {0} should be set to the number of
//000030:         /// pixels per second rendered.
//000031:         /// </summary>
//000032:         private const string _formTitle = "Interactive Fractal ({0}x) - PPMS: {1} - Time: {2}";
//000033:         /// <summary>Whether to use parallel rendering.</summary>
//000034:         private bool _parallelRendering = false;
    IL_0028:  ldarg.0
    IL_0029:  ldc.i4.0
    IL_002a:  stfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_parallelRendering
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\MainForm.designer.cs' 
//000008:         private System.ComponentModel.IContainer components = null;
    IL_002f:  ldarg.0
    IL_0030:  ldnull
    IL_0031:  stfld      class [System]System.ComponentModel.IContainer Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\MainForm.cs' 
//000014:         public MainForm() { InitializeComponent(); }
    IL_0036:  ldarg.0
    IL_0037:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_003c:  nop
    IL_003d:  nop
    IL_003e:  ldarg.0
    IL_003f:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::InitializeComponent()
    IL_0044:  nop
    IL_0045:  nop
    IL_0046:  ret
  } // end of method MainForm::.ctor

  .method private hidebysig instance void 
          mandelbrotPb_MouseDoubleClick(object sender,
                                        class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       227 (0xe3)
    .maxstack  5
    .locals init ([0] float64 factor)
//000015: 
//000016:         /// <summary>Describes the bounds of the fractal to render.</summary>
//000017:         MandelbrotPosition _mandelbrotWindow = MandelbrotPosition.Default;
//000018:         /// <summary>The last known size of the main window.</summary>
//000019:         private Size _lastWindowSize = Size.Empty;
//000020:         /// <summary>The last known position of the mouse.</summary>
//000021:         private Point _lastMousePosition;
//000022:         /// <summary>The most recent cancellation source to cancel the last task.</summary>
//000023:         private CancellationTokenSource _lastCancellation;
//000024:         /// <summary>The last time the image was updated.</summary>
//000025:         private DateTime _lastUpdateTime = DateTime.MinValue;
//000026:         /// <summary>Whether the left mouse button is currently pressed on the picture box.</summary>
//000027:         private bool _leftMouseDown = false;
//000028:         /// <summary>
//000029:         /// The format string to use for the main form's title; {0} should be set to the number of
//000030:         /// pixels per second rendered.
//000031:         /// </summary>
//000032:         private const string _formTitle = "Interactive Fractal ({0}x) - PPMS: {1} - Time: {2}";
//000033:         /// <summary>Whether to use parallel rendering.</summary>
//000034:         private bool _parallelRendering = false;
//000035: 
//000036:         void mandelbrotPb_MouseDoubleClick(object sender, MouseEventArgs e)
//000037:         {
    IL_0000:  nop
//000038:             // Center the image on the selected location
//000039:             _mandelbrotWindow.CenterX += ((e.X - (mandelbrotPb.Width / 2.0)) / mandelbrotPb.Width) * _mandelbrotWindow.Width;
    IL_0001:  ldarg.0
    IL_0002:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_0007:  dup
    IL_0008:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterX
    IL_000d:  ldarg.2
    IL_000e:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_X()
    IL_0013:  conv.r8
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_001a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_001f:  conv.r8
    IL_0020:  ldc.r8     2.
    IL_0029:  div
    IL_002a:  sub
    IL_002b:  ldarg.0
    IL_002c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0031:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_0036:  conv.r8
    IL_0037:  div
    IL_0038:  ldarg.0
    IL_0039:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_003e:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
    IL_0043:  mul
    IL_0044:  add
    IL_0045:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterX
//000040:             _mandelbrotWindow.CenterY += ((e.Y - (mandelbrotPb.Height / 2.0)) / mandelbrotPb.Height) * _mandelbrotWindow.Height;
    IL_004a:  ldarg.0
    IL_004b:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_0050:  dup
    IL_0051:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterY
    IL_0056:  ldarg.2
    IL_0057:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Y()
    IL_005c:  conv.r8
    IL_005d:  ldarg.0
    IL_005e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0063:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0068:  conv.r8
    IL_0069:  ldc.r8     2.
    IL_0072:  div
    IL_0073:  sub
    IL_0074:  ldarg.0
    IL_0075:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_007a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_007f:  conv.r8
    IL_0080:  div
    IL_0081:  ldarg.0
    IL_0082:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_0087:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
    IL_008c:  mul
    IL_008d:  add
    IL_008e:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterY
//000041: 
//000042:             // If the left mouse button was used, zoom in by a factor of 2; if the right mouse button, zoom
//000043:             // out by a factor of 2
//000044:             double factor = e.Button == MouseButtons.Left ? .5 : 2;
    IL_0093:  ldarg.2
    IL_0094:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.MouseButtons [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Button()
    IL_0099:  ldc.i4     0x100000
    IL_009e:  beq.s      IL_00ab

    IL_00a0:  ldc.r8     2.
    IL_00a9:  br.s       IL_00b4

    IL_00ab:  ldc.r8     0.5
    IL_00b4:  stloc.0
//000045:             _mandelbrotWindow.Width *= factor;
    IL_00b5:  ldarg.0
    IL_00b6:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_00bb:  dup
    IL_00bc:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
    IL_00c1:  ldloc.0
    IL_00c2:  mul
    IL_00c3:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
//000046:             _mandelbrotWindow.Height *= factor;
    IL_00c8:  ldarg.0
    IL_00c9:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_00ce:  dup
    IL_00cf:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
    IL_00d4:  ldloc.0
    IL_00d5:  mul
    IL_00d6:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
//000047:             
//000048:             // Update the image
//000049:             UpdateImageAsync();
    IL_00db:  ldarg.0
    IL_00dc:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::UpdateImageAsync()
    IL_00e1:  nop
//000050:         }
    IL_00e2:  ret
  } // end of method MainForm::mandelbrotPb_MouseDoubleClick

  .method private hidebysig instance void 
          mandelbrotPb_VisibleChanged(object sender,
                                      class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       41 (0x29)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000051: 
//000052:         void mandelbrotPb_VisibleChanged(object sender, EventArgs e)
//000053:         {
    IL_0000:  nop
//000054:             // When the picture box becomes visible, render it
//000055:             if (mandelbrotPb.Visible)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0007:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.Control::get_Visible()
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.0
//000056:             {
//000057:                 _lastWindowSize = Size;
//000058:                 UpdateImageAsync();
//000059:             }
//000060:         }
//000061: 
//000062:         void mandelbrotPb_Resize(object sender, EventArgs e)
//000063:         {
//000064:             // If the window has been resized
//000065:             if (Size != _lastWindowSize)
//000066:             {
//000067:                 // Scale the mandelbrot image by the same factor so that its visual size doesn't change
//000068:                 if (_lastWindowSize.Width != 0)
//000069:                 {
//000070:                     double xFactor = Size.Width / (double)_lastWindowSize.Width;
//000071:                     _mandelbrotWindow.Width *= xFactor;
//000072:                 }
//000073: 
//000074:                 if (_lastWindowSize.Height != 0)
//000075:                 {
//000076:                     double yFactor = Size.Height / (double)_lastWindowSize.Height;
//000077:                     _mandelbrotWindow.Height *= yFactor;
//000078:                 }
//000079: 
//000080:                 // Record the new window size
//000081:                 _lastWindowSize = Size;
//000082: 
//000083:                 // Update the image
//000084:                 UpdateImageAsync();
//000085:             }
//000086:         }
//000087: 
//000088:         void mandelbrotPb_MouseMove(object sender, MouseEventArgs e)
//000089:         {
//000090:             // Determine how far the mouse has moved.  If it moved at all...
//000091:             Point delta = new Point(e.X - _lastMousePosition.X, e.Y - _lastMousePosition.Y);
//000092:             if (delta != Point.Empty)
//000093:             {
//000094:                 // And if the left mouse button is down...
//000095:                 if (_leftMouseDown)
//000096:                 {
//000097:                     // Determine how much the mouse moved in fractal coordinates
//000098:                     double fractalMoveX = delta.X * _mandelbrotWindow.Width / mandelbrotPb.Width;
//000099:                     double fractalMoveY = delta.Y * _mandelbrotWindow.Height / mandelbrotPb.Height;
//000100: 
//000101:                     // Shift the fractal window accordingly
//000102:                     _mandelbrotWindow.CenterX -= fractalMoveX;
//000103:                     _mandelbrotWindow.CenterY -= fractalMoveY;
//000104:  
//000105:                     // And update the image
//000106:                     UpdateImageAsync();
//000107:                 }
//000108:                 // Record the new mouse position
//000109:                 _lastMousePosition = e.Location;
//000110:             }
//000111:         }
//000112: 
//000113:         void mandelbrotPb_MouseDown(object sender, MouseEventArgs e)
//000114:         {
//000115:             // Record that mouse button is being pressed
//000116:             if (e.Button == MouseButtons.Left)
//000117:             {
//000118:                 _lastMousePosition = e.Location;
//000119:                 _leftMouseDown = true;
//000120:             }
//000121:         }
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0010:  ldloc.0
    IL_0011:  brtrue.s   IL_0028

//000056:             {
    IL_0013:  nop
//000057:                 _lastWindowSize = Size;
    IL_0014:  ldarg.0
    IL_0015:  ldarg.0
    IL_0016:  call       instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Form::get_Size()
    IL_001b:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
//000058:                 UpdateImageAsync();
    IL_0020:  ldarg.0
    IL_0021:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::UpdateImageAsync()
    IL_0026:  nop
//000059:             }
    IL_0027:  nop
//000060:         }
    IL_0028:  ret
  } // end of method MainForm::mandelbrotPb_VisibleChanged

  .method private hidebysig instance void 
          mandelbrotPb_Resize(object sender,
                              class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       186 (0xba)
    .maxstack  3
    .locals init ([0] float64 xFactor,
             [1] float64 yFactor,
             [2] bool CS$4$0000,
             [3] valuetype [System.Drawing]System.Drawing.Size CS$0$0001)
//000061: 
//000062:         void mandelbrotPb_Resize(object sender, EventArgs e)
//000063:         {
    IL_0000:  nop
//000064:             // If the window has been resized
//000065:             if (Size != _lastWindowSize)
    IL_0001:  ldarg.0
    IL_0002:  call       instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Form::get_Size()
    IL_0007:  ldarg.0
    IL_0008:  ldfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
    IL_000d:  call       bool [System.Drawing]System.Drawing.Size::op_Inequality(valuetype [System.Drawing]System.Drawing.Size,
                                                                                 valuetype [System.Drawing]System.Drawing.Size)
    IL_0012:  ldc.i4.0
    IL_0013:  ceq
    IL_0015:  stloc.2
//000066:             {
//000067:                 // Scale the mandelbrot image by the same factor so that its visual size doesn't change
//000068:                 if (_lastWindowSize.Width != 0)
//000069:                 {
//000070:                     double xFactor = Size.Width / (double)_lastWindowSize.Width;
//000071:                     _mandelbrotWindow.Width *= xFactor;
//000072:                 }
//000073: 
//000074:                 if (_lastWindowSize.Height != 0)
//000075:                 {
//000076:                     double yFactor = Size.Height / (double)_lastWindowSize.Height;
//000077:                     _mandelbrotWindow.Height *= yFactor;
//000078:                 }
//000079: 
//000080:                 // Record the new window size
//000081:                 _lastWindowSize = Size;
//000082: 
//000083:                 // Update the image
//000084:                 UpdateImageAsync();
//000085:             }
//000086:         }
//000087: 
//000088:         void mandelbrotPb_MouseMove(object sender, MouseEventArgs e)
//000089:         {
//000090:             // Determine how far the mouse has moved.  If it moved at all...
//000091:             Point delta = new Point(e.X - _lastMousePosition.X, e.Y - _lastMousePosition.Y);
//000092:             if (delta != Point.Empty)
//000093:             {
//000094:                 // And if the left mouse button is down...
//000095:                 if (_leftMouseDown)
//000096:                 {
//000097:                     // Determine how much the mouse moved in fractal coordinates
//000098:                     double fractalMoveX = delta.X * _mandelbrotWindow.Width / mandelbrotPb.Width;
//000099:                     double fractalMoveY = delta.Y * _mandelbrotWindow.Height / mandelbrotPb.Height;
//000100: 
//000101:                     // Shift the fractal window accordingly
//000102:                     _mandelbrotWindow.CenterX -= fractalMoveX;
//000103:                     _mandelbrotWindow.CenterY -= fractalMoveY;
//000104:  
//000105:                     // And update the image
//000106:                     UpdateImageAsync();
//000107:                 }
//000108:                 // Record the new mouse position
//000109:                 _lastMousePosition = e.Location;
//000110:             }
//000111:         }
//000112: 
//000113:         void mandelbrotPb_MouseDown(object sender, MouseEventArgs e)
//000114:         {
//000115:             // Record that mouse button is being pressed
//000116:             if (e.Button == MouseButtons.Left)
//000117:             {
//000118:                 _lastMousePosition = e.Location;
//000119:                 _leftMouseDown = true;
//000120:             }
//000121:         }
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0016:  ldloc.2
    IL_0017:  brtrue     IL_00b9

//000066:             {
    IL_001c:  nop
//000067:                 // Scale the mandelbrot image by the same factor so that its visual size doesn't change
//000068:                 if (_lastWindowSize.Width != 0)
    IL_001d:  ldarg.0
    IL_001e:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
    IL_0023:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.2
//000069:                 {
//000070:                     double xFactor = Size.Width / (double)_lastWindowSize.Width;
//000071:                     _mandelbrotWindow.Width *= xFactor;
//000072:                 }
//000073: 
//000074:                 if (_lastWindowSize.Height != 0)
//000075:                 {
//000076:                     double yFactor = Size.Height / (double)_lastWindowSize.Height;
//000077:                     _mandelbrotWindow.Height *= yFactor;
//000078:                 }
//000079: 
//000080:                 // Record the new window size
//000081:                 _lastWindowSize = Size;
//000082: 
//000083:                 // Update the image
//000084:                 UpdateImageAsync();
//000085:             }
//000086:         }
//000087: 
//000088:         void mandelbrotPb_MouseMove(object sender, MouseEventArgs e)
//000089:         {
//000090:             // Determine how far the mouse has moved.  If it moved at all...
//000091:             Point delta = new Point(e.X - _lastMousePosition.X, e.Y - _lastMousePosition.Y);
//000092:             if (delta != Point.Empty)
//000093:             {
//000094:                 // And if the left mouse button is down...
//000095:                 if (_leftMouseDown)
//000096:                 {
//000097:                     // Determine how much the mouse moved in fractal coordinates
//000098:                     double fractalMoveX = delta.X * _mandelbrotWindow.Width / mandelbrotPb.Width;
//000099:                     double fractalMoveY = delta.Y * _mandelbrotWindow.Height / mandelbrotPb.Height;
//000100: 
//000101:                     // Shift the fractal window accordingly
//000102:                     _mandelbrotWindow.CenterX -= fractalMoveX;
//000103:                     _mandelbrotWindow.CenterY -= fractalMoveY;
//000104:  
//000105:                     // And update the image
//000106:                     UpdateImageAsync();
//000107:                 }
//000108:                 // Record the new mouse position
//000109:                 _lastMousePosition = e.Location;
//000110:             }
//000111:         }
//000112: 
//000113:         void mandelbrotPb_MouseDown(object sender, MouseEventArgs e)
//000114:         {
//000115:             // Record that mouse button is being pressed
//000116:             if (e.Button == MouseButtons.Left)
//000117:             {
//000118:                 _lastMousePosition = e.Location;
//000119:                 _leftMouseDown = true;
//000120:             }
//000121:         }
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_002c:  ldloc.2
    IL_002d:  brtrue.s   IL_0061

//000069:                 {
    IL_002f:  nop
//000070:                     double xFactor = Size.Width / (double)_lastWindowSize.Width;
    IL_0030:  ldarg.0
    IL_0031:  call       instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Form::get_Size()
    IL_0036:  stloc.3
    IL_0037:  ldloca.s   CS$0$0001
    IL_0039:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_003e:  conv.r8
    IL_003f:  ldarg.0
    IL_0040:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
    IL_0045:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_004a:  conv.r8
    IL_004b:  div
    IL_004c:  stloc.0
//000071:                     _mandelbrotWindow.Width *= xFactor;
    IL_004d:  ldarg.0
    IL_004e:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_0053:  dup
    IL_0054:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
    IL_0059:  ldloc.0
    IL_005a:  mul
    IL_005b:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
//000072:                 }
    IL_0060:  nop
//000073: 
//000074:                 if (_lastWindowSize.Height != 0)
    IL_0061:  ldarg.0
    IL_0062:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
    IL_0067:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_006c:  ldc.i4.0
    IL_006d:  ceq
    IL_006f:  stloc.2
//000075:                 {
//000076:                     double yFactor = Size.Height / (double)_lastWindowSize.Height;
//000077:                     _mandelbrotWindow.Height *= yFactor;
//000078:                 }
//000079: 
//000080:                 // Record the new window size
//000081:                 _lastWindowSize = Size;
//000082: 
//000083:                 // Update the image
//000084:                 UpdateImageAsync();
//000085:             }
//000086:         }
//000087: 
//000088:         void mandelbrotPb_MouseMove(object sender, MouseEventArgs e)
//000089:         {
//000090:             // Determine how far the mouse has moved.  If it moved at all...
//000091:             Point delta = new Point(e.X - _lastMousePosition.X, e.Y - _lastMousePosition.Y);
//000092:             if (delta != Point.Empty)
//000093:             {
//000094:                 // And if the left mouse button is down...
//000095:                 if (_leftMouseDown)
//000096:                 {
//000097:                     // Determine how much the mouse moved in fractal coordinates
//000098:                     double fractalMoveX = delta.X * _mandelbrotWindow.Width / mandelbrotPb.Width;
//000099:                     double fractalMoveY = delta.Y * _mandelbrotWindow.Height / mandelbrotPb.Height;
//000100: 
//000101:                     // Shift the fractal window accordingly
//000102:                     _mandelbrotWindow.CenterX -= fractalMoveX;
//000103:                     _mandelbrotWindow.CenterY -= fractalMoveY;
//000104:  
//000105:                     // And update the image
//000106:                     UpdateImageAsync();
//000107:                 }
//000108:                 // Record the new mouse position
//000109:                 _lastMousePosition = e.Location;
//000110:             }
//000111:         }
//000112: 
//000113:         void mandelbrotPb_MouseDown(object sender, MouseEventArgs e)
//000114:         {
//000115:             // Record that mouse button is being pressed
//000116:             if (e.Button == MouseButtons.Left)
//000117:             {
//000118:                 _lastMousePosition = e.Location;
//000119:                 _leftMouseDown = true;
//000120:             }
//000121:         }
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0070:  ldloc.2
    IL_0071:  brtrue.s   IL_00a5

//000075:                 {
    IL_0073:  nop
//000076:                     double yFactor = Size.Height / (double)_lastWindowSize.Height;
    IL_0074:  ldarg.0
    IL_0075:  call       instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Form::get_Size()
    IL_007a:  stloc.3
    IL_007b:  ldloca.s   CS$0$0001
    IL_007d:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_0082:  conv.r8
    IL_0083:  ldarg.0
    IL_0084:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
    IL_0089:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_008e:  conv.r8
    IL_008f:  div
    IL_0090:  stloc.1
//000077:                     _mandelbrotWindow.Height *= yFactor;
    IL_0091:  ldarg.0
    IL_0092:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_0097:  dup
    IL_0098:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
    IL_009d:  ldloc.1
    IL_009e:  mul
    IL_009f:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
//000078:                 }
    IL_00a4:  nop
//000079: 
//000080:                 // Record the new window size
//000081:                 _lastWindowSize = Size;
    IL_00a5:  ldarg.0
    IL_00a6:  ldarg.0
    IL_00a7:  call       instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Form::get_Size()
    IL_00ac:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastWindowSize
//000082: 
//000083:                 // Update the image
//000084:                 UpdateImageAsync();
    IL_00b1:  ldarg.0
    IL_00b2:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::UpdateImageAsync()
    IL_00b7:  nop
//000085:             }
    IL_00b8:  nop
//000086:         }
    IL_00b9:  ret
  } // end of method MainForm::mandelbrotPb_Resize

  .method private hidebysig instance void 
          mandelbrotPb_MouseMove(object sender,
                                 class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       209 (0xd1)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Point delta,
             [1] float64 fractalMoveX,
             [2] float64 fractalMoveY,
             [3] bool CS$4$0000)
//000087: 
//000088:         void mandelbrotPb_MouseMove(object sender, MouseEventArgs e)
//000089:         {
    IL_0000:  nop
//000090:             // Determine how far the mouse has moved.  If it moved at all...
//000091:             Point delta = new Point(e.X - _lastMousePosition.X, e.Y - _lastMousePosition.Y);
    IL_0001:  ldloca.s   delta
    IL_0003:  ldarg.2
    IL_0004:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_X()
    IL_0009:  ldarg.0
    IL_000a:  ldflda     valuetype [System.Drawing]System.Drawing.Point Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastMousePosition
    IL_000f:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
    IL_0014:  sub
    IL_0015:  ldarg.2
    IL_0016:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Y()
    IL_001b:  ldarg.0
    IL_001c:  ldflda     valuetype [System.Drawing]System.Drawing.Point Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastMousePosition
    IL_0021:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
    IL_0026:  sub
    IL_0027:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_002c:  nop
//000092:             if (delta != Point.Empty)
    IL_002d:  ldloc.0
    IL_002e:  ldsfld     valuetype [System.Drawing]System.Drawing.Point [System.Drawing]System.Drawing.Point::Empty
    IL_0033:  call       bool [System.Drawing]System.Drawing.Point::op_Inequality(valuetype [System.Drawing]System.Drawing.Point,
                                                                                  valuetype [System.Drawing]System.Drawing.Point)
    IL_0038:  ldc.i4.0
    IL_0039:  ceq
    IL_003b:  stloc.3
//000093:             {
//000094:                 // And if the left mouse button is down...
//000095:                 if (_leftMouseDown)
//000096:                 {
//000097:                     // Determine how much the mouse moved in fractal coordinates
//000098:                     double fractalMoveX = delta.X * _mandelbrotWindow.Width / mandelbrotPb.Width;
//000099:                     double fractalMoveY = delta.Y * _mandelbrotWindow.Height / mandelbrotPb.Height;
//000100: 
//000101:                     // Shift the fractal window accordingly
//000102:                     _mandelbrotWindow.CenterX -= fractalMoveX;
//000103:                     _mandelbrotWindow.CenterY -= fractalMoveY;
//000104:  
//000105:                     // And update the image
//000106:                     UpdateImageAsync();
//000107:                 }
//000108:                 // Record the new mouse position
//000109:                 _lastMousePosition = e.Location;
//000110:             }
//000111:         }
//000112: 
//000113:         void mandelbrotPb_MouseDown(object sender, MouseEventArgs e)
//000114:         {
//000115:             // Record that mouse button is being pressed
//000116:             if (e.Button == MouseButtons.Left)
//000117:             {
//000118:                 _lastMousePosition = e.Location;
//000119:                 _leftMouseDown = true;
//000120:             }
//000121:         }
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_003c:  ldloc.3
    IL_003d:  brtrue     IL_00d0

//000093:             {
    IL_0042:  nop
//000094:                 // And if the left mouse button is down...
//000095:                 if (_leftMouseDown)
    IL_0043:  ldarg.0
    IL_0044:  ldfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_leftMouseDown
    IL_0049:  ldc.i4.0
    IL_004a:  ceq
    IL_004c:  stloc.3
//000096:                 {
//000097:                     // Determine how much the mouse moved in fractal coordinates
//000098:                     double fractalMoveX = delta.X * _mandelbrotWindow.Width / mandelbrotPb.Width;
//000099:                     double fractalMoveY = delta.Y * _mandelbrotWindow.Height / mandelbrotPb.Height;
//000100: 
//000101:                     // Shift the fractal window accordingly
//000102:                     _mandelbrotWindow.CenterX -= fractalMoveX;
//000103:                     _mandelbrotWindow.CenterY -= fractalMoveY;
//000104:  
//000105:                     // And update the image
//000106:                     UpdateImageAsync();
//000107:                 }
//000108:                 // Record the new mouse position
//000109:                 _lastMousePosition = e.Location;
//000110:             }
//000111:         }
//000112: 
//000113:         void mandelbrotPb_MouseDown(object sender, MouseEventArgs e)
//000114:         {
//000115:             // Record that mouse button is being pressed
//000116:             if (e.Button == MouseButtons.Left)
//000117:             {
//000118:                 _lastMousePosition = e.Location;
//000119:                 _leftMouseDown = true;
//000120:             }
//000121:         }
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_004d:  ldloc.3
    IL_004e:  brtrue.s   IL_00c3

//000096:                 {
    IL_0050:  nop
//000097:                     // Determine how much the mouse moved in fractal coordinates
//000098:                     double fractalMoveX = delta.X * _mandelbrotWindow.Width / mandelbrotPb.Width;
    IL_0051:  ldloca.s   delta
    IL_0053:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
    IL_0058:  conv.r8
    IL_0059:  ldarg.0
    IL_005a:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_005f:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
    IL_0064:  mul
    IL_0065:  ldarg.0
    IL_0066:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_006b:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_0070:  conv.r8
    IL_0071:  div
    IL_0072:  stloc.1
//000099:                     double fractalMoveY = delta.Y * _mandelbrotWindow.Height / mandelbrotPb.Height;
    IL_0073:  ldloca.s   delta
    IL_0075:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
    IL_007a:  conv.r8
    IL_007b:  ldarg.0
    IL_007c:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_0081:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
    IL_0086:  mul
    IL_0087:  ldarg.0
    IL_0088:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_008d:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0092:  conv.r8
    IL_0093:  div
    IL_0094:  stloc.2
//000100: 
//000101:                     // Shift the fractal window accordingly
//000102:                     _mandelbrotWindow.CenterX -= fractalMoveX;
    IL_0095:  ldarg.0
    IL_0096:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_009b:  dup
    IL_009c:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterX
    IL_00a1:  ldloc.1
    IL_00a2:  sub
    IL_00a3:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterX
//000103:                     _mandelbrotWindow.CenterY -= fractalMoveY;
    IL_00a8:  ldarg.0
    IL_00a9:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
    IL_00ae:  dup
    IL_00af:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterY
    IL_00b4:  ldloc.2
    IL_00b5:  sub
    IL_00b6:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterY
//000104:  
//000105:                     // And update the image
//000106:                     UpdateImageAsync();
    IL_00bb:  ldarg.0
    IL_00bc:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::UpdateImageAsync()
    IL_00c1:  nop
//000107:                 }
    IL_00c2:  nop
//000108:                 // Record the new mouse position
//000109:                 _lastMousePosition = e.Location;
    IL_00c3:  ldarg.0
    IL_00c4:  ldarg.2
    IL_00c5:  callvirt   instance valuetype [System.Drawing]System.Drawing.Point [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Location()
    IL_00ca:  stfld      valuetype [System.Drawing]System.Drawing.Point Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastMousePosition
//000110:             }
    IL_00cf:  nop
//000111:         }
    IL_00d0:  ret
  } // end of method MainForm::mandelbrotPb_MouseMove

  .method private hidebysig instance void 
          mandelbrotPb_MouseDown(object sender,
                                 class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000112: 
//000113:         void mandelbrotPb_MouseDown(object sender, MouseEventArgs e)
//000114:         {
    IL_0000:  nop
//000115:             // Record that mouse button is being pressed
//000116:             if (e.Button == MouseButtons.Left)
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.MouseButtons [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Button()
    IL_0007:  ldc.i4     0x100000
    IL_000c:  ceq
    IL_000e:  ldc.i4.0
    IL_000f:  ceq
    IL_0011:  stloc.0
//000117:             {
//000118:                 _lastMousePosition = e.Location;
//000119:                 _leftMouseDown = true;
//000120:             }
//000121:         }
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0012:  ldloc.0
    IL_0013:  brtrue.s   IL_002a

//000117:             {
    IL_0015:  nop
//000118:                 _lastMousePosition = e.Location;
    IL_0016:  ldarg.0
    IL_0017:  ldarg.2
    IL_0018:  callvirt   instance valuetype [System.Drawing]System.Drawing.Point [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Location()
    IL_001d:  stfld      valuetype [System.Drawing]System.Drawing.Point Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastMousePosition
//000119:                 _leftMouseDown = true;
    IL_0022:  ldarg.0
    IL_0023:  ldc.i4.1
    IL_0024:  stfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_leftMouseDown
//000120:             }
    IL_0029:  nop
//000121:         }
    IL_002a:  ret
  } // end of method MainForm::mandelbrotPb_MouseDown

  .method private hidebysig instance void 
          mandelbrotPb_MouseUp(object sender,
                               class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000122: 
//000123:         void mandelbrotPb_MouseUp(object sender, MouseEventArgs e)
//000124:         {
    IL_0000:  nop
//000125:             // Record that the mouse button is being released
//000126:             if (e.Button == MouseButtons.Left)
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.MouseButtons [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Button()
    IL_0007:  ldc.i4     0x100000
    IL_000c:  ceq
    IL_000e:  ldc.i4.0
    IL_000f:  ceq
    IL_0011:  stloc.0
//000127:             {
//000128:                 _lastMousePosition = e.Location;
//000129:                 _leftMouseDown = false;
//000130:             }
//000131:         }
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0012:  ldloc.0
    IL_0013:  brtrue.s   IL_002a

//000127:             {
    IL_0015:  nop
//000128:                 _lastMousePosition = e.Location;
    IL_0016:  ldarg.0
    IL_0017:  ldarg.2
    IL_0018:  callvirt   instance valuetype [System.Drawing]System.Drawing.Point [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Location()
    IL_001d:  stfld      valuetype [System.Drawing]System.Drawing.Point Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastMousePosition
//000129:                 _leftMouseDown = false;
    IL_0022:  ldarg.0
    IL_0023:  ldc.i4.0
    IL_0024:  stfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_leftMouseDown
//000130:             }
    IL_0029:  nop
//000131:         }
    IL_002a:  ret
  } // end of method MainForm::mandelbrotPb_MouseUp

  .method private hidebysig instance void 
          UpdateImageAsync() cil managed
  {
    // Code size       126 (0x7e)
    .maxstack  4
    .locals init ([0] class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2' 'CS$<>8__locals3',
             [1] bool CS$4$0000)
//000132: 
//000133:         private void UpdateImageAsync()
//000134:         {
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0000:  newobj     instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.0
    IL_0008:  stfld      class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<>4__this'
//000134:         {
    IL_000d:  nop
//000135:             // If there's currently an active task, cancel it!  We don't care about it anymore.
//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastCancellation
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  stloc.1
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
//000149:             var token = _lastCancellation.Token;
//000150:             Task.Factory.StartNew(() =>
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
//000186:             base.OnKeyDown(e);
//000187:             if (e.KeyCode == Keys.R)
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0018:  ldloc.1
    IL_0019:  brtrue.s   IL_0027

//000136:             if (_lastCancellation != null) _lastCancellation.Cancel();
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastCancellation
    IL_0021:  callvirt   instance void [mscorlib]System.Threading.CancellationTokenSource::Cancel()
    IL_0026:  nop
//000137: 
//000138:             // Get the current size of the picture box
//000139:             Size renderSize = mandelbrotPb.Size;
    IL_0027:  ldloc.0
    IL_0028:  ldarg.0
    IL_0029:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_002e:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0033:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::renderSize
//000140: 
//000141:             // Keep track of the time this request was made.  If multiple requests are executing,
//000142:             // we want to only render the most recent one available rather than overwriting a more
//000143:             // recent image with an older one.
//000144:             DateTime timeOfRequest = DateTime.UtcNow;
    IL_0038:  ldloc.0
    IL_0039:  call       valuetype [mscorlib]System.DateTime [mscorlib]System.DateTime::get_UtcNow()
    IL_003e:  stfld      valuetype [mscorlib]System.DateTime Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::timeOfRequest
//000145: 
//000146:             // Start a task to asynchronously render the fractal, and store the task
//000147:             // so we can cancel it later as necessary
//000148:             _lastCancellation = new CancellationTokenSource();
    IL_0043:  ldarg.0
    IL_0044:  newobj     instance void [mscorlib]System.Threading.CancellationTokenSource::.ctor()
    IL_0049:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastCancellation
//000149:             var token = _lastCancellation.Token;
    IL_004e:  ldloc.0
    IL_004f:  ldarg.0
    IL_0050:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_lastCancellation
    IL_0055:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_005a:  stfld      valuetype [mscorlib]System.Threading.CancellationToken Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::token
//000150:             Task.Factory.StartNew(() =>
    IL_005f:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_0064:  ldloc.0
    IL_0065:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::'<UpdateImageAsync>b__0'()
    IL_006b:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_0070:  ldloc.0
    IL_0071:  ldfld      valuetype [mscorlib]System.Threading.CancellationToken Microsoft.Pcp.Pfx.InteractiveFractal.MainForm/'<>c__DisplayClass2'::token
    IL_0076:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action,
                                                                                                                                     valuetype [mscorlib]System.Threading.CancellationToken)
    IL_007b:  pop
//000151:             {
//000152:                 // For diagnostic reasons, time how long the rendering takes
//000153:                 Stopwatch sw = Stopwatch.StartNew();
//000154: 
//000155:                 // Render the fractal
//000156:                 Bitmap bmp = MandelbrotGenerator.Create(_mandelbrotWindow, renderSize.Width, renderSize.Height, token, _parallelRendering);
//000157:                 if (bmp != null)
//000158:                 {
//000159:                     sw.Stop();
//000160:                     double ppms = (renderSize.Width * renderSize.Height) / (double)sw.ElapsedMilliseconds;
//000161: 
//000162:                     // Update the fractal image asynchronously on the UI thread
//000163:                     Image old = null;
//000164:                     BeginInvoke((MethodInvoker)delegate
//000165:                     {
//000166:                         // If this image is the most recent, store it into the picture box
//000167:                         // making sure to free the resources for the one currently in use.
//000168:                         // And update the form's title to reflect the rendering time.
//000169:                         if (timeOfRequest > _lastUpdateTime)
//000170:                         {
//000171:                             old = mandelbrotPb.Image;
//000172:                             mandelbrotPb.Image = bmp;
//000173:                             _lastUpdateTime = timeOfRequest;
//000174:                             this.Text = string.Format(_formTitle, _parallelRendering ? Environment.ProcessorCount : 1, ppms.ToString("F2"), sw.ElapsedMilliseconds.ToString());
//000175:                         }
//000176:                         // If the image isn't the most recent, just get rid of it
//000177:                         else bmp.Dispose();
//000178:                     });
//000179:                     if (old != null) old.Dispose();
//000180:                 }
//000181:             }, token);
//000182:         }
    IL_007c:  nop
    IL_007d:  ret
  } // end of method MainForm::UpdateImageAsync

  .method family hidebysig virtual instance void 
          OnKeyDown(class [System.Windows.Forms]System.Windows.Forms.KeyEventArgs e) cil managed
  {
    // Code size       235 (0xeb)
    .maxstack  3
    .locals init ([0] class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm tempForm,
             [1] float64 xFactor,
             [2] float64 yFactor,
             [3] bool CS$4$0000,
             [4] valuetype [System.Drawing]System.Drawing.Size CS$0$0001)
//000183: 
//000184:         protected override void OnKeyDown(KeyEventArgs e)
//000185:         {
    IL_0000:  nop
//000186:             base.OnKeyDown(e);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::OnKeyDown(class [System.Windows.Forms]System.Windows.Forms.KeyEventArgs)
    IL_0008:  nop
//000187:             if (e.KeyCode == Keys.R)
    IL_0009:  ldarg.1
    IL_000a:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.Keys [System.Windows.Forms]System.Windows.Forms.KeyEventArgs::get_KeyCode()
    IL_000f:  ldc.i4.s   82
    IL_0011:  ceq
    IL_0013:  ldc.i4.0
    IL_0014:  ceq
    IL_0016:  stloc.3
//000188:             {
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
//000192:                 {
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
//000194:                     _mandelbrotWindow.Width *= xFactor;
//000195:                     _mandelbrotWindow.Height *= yFactor;
//000196:                 }
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_0017:  ldloc.3
    IL_0018:  brtrue     IL_00a6

//000188:             {
    IL_001d:  nop
//000189:                 _mandelbrotWindow = MandelbrotPosition.Default;
    IL_001e:  ldarg.0
    IL_001f:  call       valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::get_Default()
    IL_0024:  stfld      valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
//000190: 
//000191:                 using (MainForm tempForm = new MainForm())
    IL_0029:  newobj     instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::.ctor()
    IL_002e:  stloc.0
//000192:                 {
    .try
    {
      IL_002f:  nop
//000193:                     double xFactor = Size.Width / (double)tempForm.Width, yFactor = Size.Height / (double)tempForm.Height;
      IL_0030:  ldarg.0
      IL_0031:  call       instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Form::get_Size()
      IL_0036:  stloc.s    CS$0$0001
      IL_0038:  ldloca.s   CS$0$0001
      IL_003a:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
      IL_003f:  conv.r8
      IL_0040:  ldloc.0
      IL_0041:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
      IL_0046:  conv.r8
      IL_0047:  div
      IL_0048:  stloc.1
      IL_0049:  ldarg.0
      IL_004a:  call       instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Form::get_Size()
      IL_004f:  stloc.s    CS$0$0001
      IL_0051:  ldloca.s   CS$0$0001
      IL_0053:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
      IL_0058:  conv.r8
      IL_0059:  ldloc.0
      IL_005a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
      IL_005f:  conv.r8
      IL_0060:  div
      IL_0061:  stloc.2
//000194:                     _mandelbrotWindow.Width *= xFactor;
      IL_0062:  ldarg.0
      IL_0063:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
      IL_0068:  dup
      IL_0069:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
      IL_006e:  ldloc.1
      IL_006f:  mul
      IL_0070:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
//000195:                     _mandelbrotWindow.Height *= yFactor;
      IL_0075:  ldarg.0
      IL_0076:  ldflda     valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_mandelbrotWindow
      IL_007b:  dup
      IL_007c:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
      IL_0081:  ldloc.2
      IL_0082:  mul
      IL_0083:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
//000196:                 }
      IL_0088:  nop
//000197: 
//000198:                 UpdateImageAsync();
//000199:             }
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
      IL_0089:  leave.s    IL_009b

    }  // end .try
    finally
    {
      IL_008b:  ldloc.0
      IL_008c:  ldnull
      IL_008d:  ceq
      IL_008f:  stloc.3
      IL_0090:  ldloc.3
      IL_0091:  brtrue.s   IL_009a

      IL_0093:  ldloc.0
      IL_0094:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0099:  nop
      IL_009a:  endfinally
    }  // end handler
    IL_009b:  nop
//000198:                 UpdateImageAsync();
    IL_009c:  ldarg.0
    IL_009d:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::UpdateImageAsync()
    IL_00a2:  nop
//000199:             }
    IL_00a3:  nop
//000200:             else if (e.KeyCode == Keys.S)
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_00a4:  br.s       IL_00ea

//000200:             else if (e.KeyCode == Keys.S)
    IL_00a6:  ldarg.1
    IL_00a7:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.Keys [System.Windows.Forms]System.Windows.Forms.KeyEventArgs::get_KeyCode()
    IL_00ac:  ldc.i4.s   83
    IL_00ae:  ceq
    IL_00b0:  ldc.i4.0
    IL_00b1:  ceq
    IL_00b3:  stloc.3
//000201:             {
//000202:                 _parallelRendering = false;
//000203:                 UpdateImageAsync();
//000204:             }
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_00b4:  ldloc.3
    IL_00b5:  brtrue.s   IL_00c9

//000201:             {
    IL_00b7:  nop
//000202:                 _parallelRendering = false;
    IL_00b8:  ldarg.0
    IL_00b9:  ldc.i4.0
    IL_00ba:  stfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_parallelRendering
//000203:                 UpdateImageAsync();
    IL_00bf:  ldarg.0
    IL_00c0:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::UpdateImageAsync()
    IL_00c5:  nop
//000204:             }
    IL_00c6:  nop
//000205:             else if (e.KeyCode == Keys.P)
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_00c7:  br.s       IL_00ea

//000205:             else if (e.KeyCode == Keys.P)
    IL_00c9:  ldarg.1
    IL_00ca:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.Keys [System.Windows.Forms]System.Windows.Forms.KeyEventArgs::get_KeyCode()
    IL_00cf:  ldc.i4.s   80
    IL_00d1:  ceq
    IL_00d3:  ldc.i4.0
    IL_00d4:  ceq
    IL_00d6:  stloc.3
//000206:             {
//000207:                 _parallelRendering = true;
//000208:                 UpdateImageAsync();
//000209:             }
//000210:         }
//000211:     }
//000212: }
//000213: 
//000214: 
    IL_00d7:  ldloc.3
    IL_00d8:  brtrue.s   IL_00ea

//000206:             {
    IL_00da:  nop
//000207:                 _parallelRendering = true;
    IL_00db:  ldarg.0
    IL_00dc:  ldc.i4.1
    IL_00dd:  stfld      bool Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::_parallelRendering
//000208:                 UpdateImageAsync();
    IL_00e2:  ldarg.0
    IL_00e3:  call       instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::UpdateImageAsync()
    IL_00e8:  nop
//000209:             }
    IL_00e9:  nop
//000210:         }
    IL_00ea:  ret
  } // end of method MainForm::OnKeyDown

  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\MainForm.designer.cs' 
//000015:         {
    IL_0000:  nop
//000016:             if (disposing && (components != null))
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000f

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::components
    IL_000a:  ldnull
    IL_000b:  ceq
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000017:             {
//000018:                 components.Dispose();
//000019:             }
//000020:             base.Dispose(disposing);
//000021:         }
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
//000031:             this.mandelbrotPb = new System.Windows.Forms.PictureBox();
//000032:             this.statusStrip1 = new System.Windows.Forms.StatusStrip();
//000033:             this.toolStripStatusLabel1 = new System.Windows.Forms.ToolStripStatusLabel();
//000034:             ((System.ComponentModel.ISupportInitialize)(this.mandelbrotPb)).BeginInit();
//000035:             this.statusStrip1.SuspendLayout();
//000036:             this.SuspendLayout();
//000037:             // 
//000038:             // mandelbrotPb
//000039:             // 
//000040:             this.mandelbrotPb.BackColor = System.Drawing.Color.Black;
//000041:             this.mandelbrotPb.Dock = System.Windows.Forms.DockStyle.Fill;
//000042:             this.mandelbrotPb.Location = new System.Drawing.Point(0, 0);
//000043:             this.mandelbrotPb.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
//000044:             this.mandelbrotPb.Name = "mandelbrotPb";
//000045:             this.mandelbrotPb.Size = new System.Drawing.Size(521, 452);
//000046:             this.mandelbrotPb.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
//000047:             this.mandelbrotPb.TabIndex = 0;
//000048:             this.mandelbrotPb.TabStop = false;
//000049:             this.mandelbrotPb.VisibleChanged += new System.EventHandler(this.mandelbrotPb_VisibleChanged);
//000050:             this.mandelbrotPb.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseDoubleClick);
//000051:             this.mandelbrotPb.MouseDown += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseDown);
//000052:             this.mandelbrotPb.MouseMove += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseMove);
//000053:             this.mandelbrotPb.MouseUp += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseUp);
//000054:             this.mandelbrotPb.Resize += new System.EventHandler(this.mandelbrotPb_Resize);
//000055:             // 
//000056:             // statusStrip1
//000057:             // 
//000058:             this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000059:             this.toolStripStatusLabel1});
//000060:             this.statusStrip1.Location = new System.Drawing.Point(0, 427);
//000061:             this.statusStrip1.Name = "statusStrip1";
//000062:             this.statusStrip1.Padding = new System.Windows.Forms.Padding(1, 0, 19, 0);
//000063:             this.statusStrip1.Size = new System.Drawing.Size(521, 25);
//000064:             this.statusStrip1.TabIndex = 2;
//000065:             this.statusStrip1.Text = "statusStrip1";
//000066:             // 
//000067:             // toolStripStatusLabel1
//000068:             // 
//000069:             this.toolStripStatusLabel1.Name = "toolStripStatusLabel1";
//000070:             this.toolStripStatusLabel1.Size = new System.Drawing.Size(386, 20);
//000071:             this.toolStripStatusLabel1.Text = "P: parallel mode, S: sequential mode, Double-click: zoom";
//000072:             // 
//000073:             // MainForm
//000074:             // 
//000075:             this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
//000076:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
//000077:             this.ClientSize = new System.Drawing.Size(521, 452);
//000078:             this.Controls.Add(this.statusStrip1);
//000079:             this.Controls.Add(this.mandelbrotPb);
//000080:             this.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
//000081:             this.Name = "MainForm";
//000082:             this.Text = "Mandelbrot Fractals";
//000083:             ((System.ComponentModel.ISupportInitialize)(this.mandelbrotPb)).EndInit();
//000084:             this.statusStrip1.ResumeLayout(false);
//000085:             this.statusStrip1.PerformLayout();
//000086:             this.ResumeLayout(false);
//000087:             this.PerformLayout();
//000088: 
//000089:         }
//000090: 
//000091:         #endregion
//000092: 
//000093:         private System.Windows.Forms.PictureBox mandelbrotPb;
//000094:         private System.Windows.Forms.StatusStrip statusStrip1;
//000095:         private System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel1;
//000096:     }
//000097: }
//000098: 
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_0022

//000017:             {
    IL_0014:  nop
//000018:                 components.Dispose();
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::components
    IL_001b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_0020:  nop
//000019:             }
    IL_0021:  nop
//000020:             base.Dispose(disposing);
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0029:  nop
//000021:         }
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       751 (0x2ef)
    .maxstack  6
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[] CS$0$0000)
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
    IL_0000:  nop
//000031:             this.mandelbrotPb = new System.Windows.Forms.PictureBox();
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_0007:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
//000032:             this.statusStrip1 = new System.Windows.Forms.StatusStrip();
    IL_000c:  ldarg.0
    IL_000d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.StatusStrip::.ctor()
    IL_0012:  stfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
//000033:             this.toolStripStatusLabel1 = new System.Windows.Forms.ToolStripStatusLabel();
    IL_0017:  ldarg.0
    IL_0018:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripStatusLabel::.ctor()
    IL_001d:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripStatusLabel Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::toolStripStatusLabel1
//000034:             ((System.ComponentModel.ISupportInitialize)(this.mandelbrotPb)).BeginInit();
    IL_0022:  ldarg.0
    IL_0023:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0028:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_002d:  nop
//000035:             this.statusStrip1.SuspendLayout();
    IL_002e:  ldarg.0
    IL_002f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_0034:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0039:  nop
//000036:             this.SuspendLayout();
    IL_003a:  ldarg.0
    IL_003b:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0040:  nop
//000037:             // 
//000038:             // mandelbrotPb
//000039:             // 
//000040:             this.mandelbrotPb.BackColor = System.Drawing.Color.Black;
    IL_0041:  ldarg.0
    IL_0042:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0047:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Black()
    IL_004c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0051:  nop
//000041:             this.mandelbrotPb.Dock = System.Windows.Forms.DockStyle.Fill;
    IL_0052:  ldarg.0
    IL_0053:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0058:  ldc.i4.5
    IL_0059:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_005e:  nop
//000042:             this.mandelbrotPb.Location = new System.Drawing.Point(0, 0);
    IL_005f:  ldarg.0
    IL_0060:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0065:  ldc.i4.0
    IL_0066:  ldc.i4.0
    IL_0067:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_006c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0071:  nop
//000043:             this.mandelbrotPb.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
    IL_0072:  ldarg.0
    IL_0073:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0078:  ldc.i4.4
    IL_0079:  ldc.i4.4
    IL_007a:  ldc.i4.4
    IL_007b:  ldc.i4.4
    IL_007c:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Padding::.ctor(int32,
                                                                                                 int32,
                                                                                                 int32,
                                                                                                 int32)
    IL_0081:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Margin(valuetype [System.Windows.Forms]System.Windows.Forms.Padding)
    IL_0086:  nop
//000044:             this.mandelbrotPb.Name = "mandelbrotPb";
    IL_0087:  ldarg.0
    IL_0088:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_008d:  ldstr      "mandelbrotPb"
    IL_0092:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0097:  nop
//000045:             this.mandelbrotPb.Size = new System.Drawing.Size(521, 452);
    IL_0098:  ldarg.0
    IL_0099:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_009e:  ldc.i4     0x209
    IL_00a3:  ldc.i4     0x1c4
    IL_00a8:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_00ad:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_00b2:  nop
//000046:             this.mandelbrotPb.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
    IL_00b3:  ldarg.0
    IL_00b4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_00b9:  ldc.i4.3
    IL_00ba:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_00bf:  nop
//000047:             this.mandelbrotPb.TabIndex = 0;
    IL_00c0:  ldarg.0
    IL_00c1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_00c6:  ldc.i4.0
    IL_00c7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_00cc:  nop
//000048:             this.mandelbrotPb.TabStop = false;
    IL_00cd:  ldarg.0
    IL_00ce:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_00d3:  ldc.i4.0
    IL_00d4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_00d9:  nop
//000049:             this.mandelbrotPb.VisibleChanged += new System.EventHandler(this.mandelbrotPb_VisibleChanged);
    IL_00da:  ldarg.0
    IL_00db:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_00e0:  ldarg.0
    IL_00e1:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb_VisibleChanged(object,
                                                                                                                  class [mscorlib]System.EventArgs)
    IL_00e7:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_00ec:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_VisibleChanged(class [mscorlib]System.EventHandler)
    IL_00f1:  nop
//000050:             this.mandelbrotPb.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseDoubleClick);
    IL_00f2:  ldarg.0
    IL_00f3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_00f8:  ldarg.0
    IL_00f9:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb_MouseDoubleClick(object,
                                                                                                                    class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_00ff:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0104:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseDoubleClick(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0109:  nop
//000051:             this.mandelbrotPb.MouseDown += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseDown);
    IL_010a:  ldarg.0
    IL_010b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0110:  ldarg.0
    IL_0111:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb_MouseDown(object,
                                                                                                             class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0117:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_011c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseDown(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0121:  nop
//000052:             this.mandelbrotPb.MouseMove += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseMove);
    IL_0122:  ldarg.0
    IL_0123:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0128:  ldarg.0
    IL_0129:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb_MouseMove(object,
                                                                                                             class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_012f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0134:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseMove(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0139:  nop
//000053:             this.mandelbrotPb.MouseUp += new System.Windows.Forms.MouseEventHandler(this.mandelbrotPb_MouseUp);
    IL_013a:  ldarg.0
    IL_013b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0140:  ldarg.0
    IL_0141:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb_MouseUp(object,
                                                                                                           class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0147:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_014c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseUp(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0151:  nop
//000054:             this.mandelbrotPb.Resize += new System.EventHandler(this.mandelbrotPb_Resize);
    IL_0152:  ldarg.0
    IL_0153:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_0158:  ldarg.0
    IL_0159:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb_Resize(object,
                                                                                                          class [mscorlib]System.EventArgs)
    IL_015f:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0164:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Resize(class [mscorlib]System.EventHandler)
    IL_0169:  nop
//000055:             // 
//000056:             // statusStrip1
//000057:             // 
//000058:             this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_016a:  ldarg.0
    IL_016b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_0170:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStrip::get_Items()
    IL_0175:  ldc.i4.1
    IL_0176:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_017b:  stloc.0
    IL_017c:  ldloc.0
    IL_017d:  ldc.i4.0
    IL_017e:  ldarg.0
    IL_017f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripStatusLabel Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::toolStripStatusLabel1
    IL_0184:  stelem.ref
    IL_0185:  ldloc.0
    IL_0186:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_018b:  nop
//000059:             this.toolStripStatusLabel1});
//000060:             this.statusStrip1.Location = new System.Drawing.Point(0, 427);
    IL_018c:  ldarg.0
    IL_018d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_0192:  ldc.i4.0
    IL_0193:  ldc.i4     0x1ab
    IL_0198:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_019d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_01a2:  nop
//000061:             this.statusStrip1.Name = "statusStrip1";
    IL_01a3:  ldarg.0
    IL_01a4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_01a9:  ldstr      "statusStrip1"
    IL_01ae:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_01b3:  nop
//000062:             this.statusStrip1.Padding = new System.Windows.Forms.Padding(1, 0, 19, 0);
    IL_01b4:  ldarg.0
    IL_01b5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_01ba:  ldc.i4.1
    IL_01bb:  ldc.i4.0
    IL_01bc:  ldc.i4.s   19
    IL_01be:  ldc.i4.0
    IL_01bf:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Padding::.ctor(int32,
                                                                                                 int32,
                                                                                                 int32,
                                                                                                 int32)
    IL_01c4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.StatusStrip::set_Padding(valuetype [System.Windows.Forms]System.Windows.Forms.Padding)
    IL_01c9:  nop
//000063:             this.statusStrip1.Size = new System.Drawing.Size(521, 25);
    IL_01ca:  ldarg.0
    IL_01cb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_01d0:  ldc.i4     0x209
    IL_01d5:  ldc.i4.s   25
    IL_01d7:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_01dc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_01e1:  nop
//000064:             this.statusStrip1.TabIndex = 2;
    IL_01e2:  ldarg.0
    IL_01e3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_01e8:  ldc.i4.2
    IL_01e9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_01ee:  nop
//000065:             this.statusStrip1.Text = "statusStrip1";
    IL_01ef:  ldarg.0
    IL_01f0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_01f5:  ldstr      "statusStrip1"
    IL_01fa:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_01ff:  nop
//000066:             // 
//000067:             // toolStripStatusLabel1
//000068:             // 
//000069:             this.toolStripStatusLabel1.Name = "toolStripStatusLabel1";
    IL_0200:  ldarg.0
    IL_0201:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripStatusLabel Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::toolStripStatusLabel1
    IL_0206:  ldstr      "toolStripStatusLabel1"
    IL_020b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0210:  nop
//000070:             this.toolStripStatusLabel1.Size = new System.Drawing.Size(386, 20);
    IL_0211:  ldarg.0
    IL_0212:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripStatusLabel Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::toolStripStatusLabel1
    IL_0217:  ldc.i4     0x182
    IL_021c:  ldc.i4.s   20
    IL_021e:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0223:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0228:  nop
//000071:             this.toolStripStatusLabel1.Text = "P: parallel mode, S: sequential mode, Double-click: zoom";
    IL_0229:  ldarg.0
    IL_022a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripStatusLabel Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::toolStripStatusLabel1
    IL_022f:  ldstr      "P: parallel mode, S: sequential mode, Double-click"
    + ": zoom"
    IL_0234:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0239:  nop
//000072:             // 
//000073:             // MainForm
//000074:             // 
//000075:             this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
    IL_023a:  ldarg.0
    IL_023b:  ldc.r4     8.
    IL_0240:  ldc.r4     16.
    IL_0245:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_024a:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_024f:  nop
//000076:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    IL_0250:  ldarg.0
    IL_0251:  ldc.i4.1
    IL_0252:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_0257:  nop
//000077:             this.ClientSize = new System.Drawing.Size(521, 452);
    IL_0258:  ldarg.0
    IL_0259:  ldc.i4     0x209
    IL_025e:  ldc.i4     0x1c4
    IL_0263:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0268:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_026d:  nop
//000078:             this.Controls.Add(this.statusStrip1);
    IL_026e:  ldarg.0
    IL_026f:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0274:  ldarg.0
    IL_0275:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_027a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_027f:  nop
//000079:             this.Controls.Add(this.mandelbrotPb);
    IL_0280:  ldarg.0
    IL_0281:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0286:  ldarg.0
    IL_0287:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_028c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0291:  nop
//000080:             this.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
    IL_0292:  ldarg.0
    IL_0293:  ldc.i4.4
    IL_0294:  ldc.i4.4
    IL_0295:  ldc.i4.4
    IL_0296:  ldc.i4.4
    IL_0297:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Padding::.ctor(int32,
                                                                                                 int32,
                                                                                                 int32,
                                                                                                 int32)
    IL_029c:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_Margin(valuetype [System.Windows.Forms]System.Windows.Forms.Padding)
    IL_02a1:  nop
//000081:             this.Name = "MainForm";
    IL_02a2:  ldarg.0
    IL_02a3:  ldstr      "MainForm"
    IL_02a8:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_02ad:  nop
//000082:             this.Text = "Mandelbrot Fractals";
    IL_02ae:  ldarg.0
    IL_02af:  ldstr      "Mandelbrot Fractals"
    IL_02b4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_02b9:  nop
//000083:             ((System.ComponentModel.ISupportInitialize)(this.mandelbrotPb)).EndInit();
    IL_02ba:  ldarg.0
    IL_02bb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::mandelbrotPb
    IL_02c0:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_02c5:  nop
//000084:             this.statusStrip1.ResumeLayout(false);
    IL_02c6:  ldarg.0
    IL_02c7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_02cc:  ldc.i4.0
    IL_02cd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_02d2:  nop
//000085:             this.statusStrip1.PerformLayout();
    IL_02d3:  ldarg.0
    IL_02d4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.StatusStrip Microsoft.Pcp.Pfx.InteractiveFractal.MainForm::statusStrip1
    IL_02d9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_02de:  nop
//000086:             this.ResumeLayout(false);
    IL_02df:  ldarg.0
    IL_02e0:  ldc.i4.0
    IL_02e1:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_02e6:  nop
//000087:             this.PerformLayout();
    IL_02e7:  ldarg.0
    IL_02e8:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_02ed:  nop
//000088: 
//000089:         }
    IL_02ee:  ret
  } // end of method MainForm::InitializeComponent

} // end of class Microsoft.Pcp.Pfx.InteractiveFractal.MainForm

.class private auto ansi sealed beforefieldinit Samples.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class Samples.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class Samples.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class Samples.Properties.Settings CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\Properties\Settings.Designer.cs' 
//000021:             get {
    IL_0000:  nop
//000022:                 return defaultInstance;
    IL_0001:  ldsfld     class Samples.Properties.Settings Samples.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000023:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000018:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void Samples.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  Samples.Properties.Settings
    IL_000f:  stsfld     class Samples.Properties.Settings Samples.Properties.Settings::defaultInstance
//000019:         
//000020:         public static Settings Default {
//000021:             get {
//000022:                 return defaultInstance;
//000023:             }
//000024:         }
//000025:     }
//000026: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class Samples.Properties.Settings
          Default()
  {
    .get class Samples.Properties.Settings Samples.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class Samples.Properties.Settings

.class public sequential ansi sealed beforefieldinit Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition
       extends [mscorlib]System.ValueType
{
  .field public float64 Width
  .field public float64 Height
  .field public float64 CenterX
  .field public float64 CenterY
  .method public hidebysig specialname static 
          valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition 
          get_Default() cil managed
  {
    // Code size       79 (0x4f)
    .maxstack  2
    .locals init ([0] valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition pos,
             [1] valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\MandelbrotFractals\MandelbrotFractals_CSharp\MandelbrotGenerator.cs' 
//000019:             {
    IL_0000:  nop
//000020:                 MandelbrotPosition pos = new MandelbrotPosition();
    IL_0001:  ldloca.s   pos
    IL_0003:  initobj    Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition
//000021:                 pos.Width = 2.9;
    IL_0009:  ldloca.s   pos
    IL_000b:  ldc.r8     2.8999999999999999
    IL_0014:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
//000022:                 pos.Height = 2.27;
    IL_0019:  ldloca.s   pos
    IL_001b:  ldc.r8     2.27
    IL_0024:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
//000023:                 pos.CenterX = -.75;
    IL_0029:  ldloca.s   pos
    IL_002b:  ldc.r8     -0.75
    IL_0034:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterX
//000024:                 pos.CenterY = .006;
    IL_0039:  ldloca.s   pos
    IL_003b:  ldc.r8     6.0000000000000001e-003
    IL_0044:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterY
//000025:                 return pos;
    IL_0049:  ldloc.0
    IL_004a:  stloc.1
    IL_004b:  br.s       IL_004d

//000026:             }
    IL_004d:  ldloc.1
    IL_004e:  ret
  } // end of method MandelbrotPosition::get_Default

  .property valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition
          Default()
  {
    .get valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::get_Default()
  } // end of property MandelbrotPosition::Default
} // end of class Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition

.class public auto ansi beforefieldinit Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator
       extends [mscorlib]System.Object
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass3'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public float64 left
    .field public float64 top
    .field public float64 colToXTranslation
    .field public float64 rowToYTranslation
    .field public uint8[] data
    .field public int32 imageWidth
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass3'::.ctor

    .method public hidebysig instance void 
            '<Create>b__1'(int32 row) cil managed
    {
      // Code size       212 (0xd4)
      .maxstack  3
      .locals init ([0] float64 initialY,
               [1] uint8& pinned ptr,
               [2] uint8* currentPixel,
               [3] int32 col,
               [4] valuetype [System.Numerics]System.Numerics.Complex c,
               [5] valuetype [System.Numerics]System.Numerics.Complex z,
               [6] int32 iteration,
               [7] uint8[] CS$0$0000,
               [8] bool CS$4$0001)
//000027:         }
//000028:         public double Width, Height;
//000029:         public double CenterX, CenterY;
//000030:     }
//000031: 
//000032:     /// <summary>Generates mandelbrot fractals.</summary>
//000033:     public class MandelbrotGenerator
//000034:     {
//000035:         /// <summary>The 256 color palette to use for all fractals.</summary>
//000036:         private static Color[] _paletteColors = CreatePaletteColors();
//000037: 
//000038:         /// <summary>Create the color palette to be used for all fractals.</summary>
//000039:         /// <returns>A 256-color array that can be stored into an 8bpp Bitmap's ColorPalette.</returns>
//000040:         private static Color[] CreatePaletteColors()
//000041:         {
//000042:             Color[] paletteColors = new Color[256];
//000043:             paletteColors[0] = Color.Black;
//000044:             for (int i = 1; i < 256; i++) paletteColors[i] = Color.FromArgb(0, i * 5 % 256, i * 5 % 256); // change this at will for different colorings
//000045:             return paletteColors;
//000046:         }
//000047: 
//000048:         /// <summary>Copy our precreated color palette into the target Bitmap.</summary>
//000049:         /// <param name="bmp">The Bitmap to be updated.</param>
//000050:         private static void UpdatePalette(Bitmap bmp)
//000051:         {
//000052:             ColorPalette p = bmp.Palette;
//000053:             Array.Copy(_paletteColors, p.Entries, _paletteColors.Length);
//000054:             bmp.Palette = p; // The Bitmap will only update when the Palette property's setter is used
//000055:         }
//000056: 
//000057:         /// <summary>Renders a mandelbrot fractal.</summary>
//000058:         /// <param name="position">The MandelbrotPosition representing the fractal boundaries to be rendered.</param>
//000059:         /// <param name="imageWidth">The width in pixels of the image to create.</param>
//000060:         /// <param name="imageHeight">The height in pixels of the image to create.</param>
//000061:         /// <param name="parallelRendering">Whether to render the image in parallel.</param>
//000062:         /// <returns>The rendered Bitmap.</returns>
//000063:         public unsafe static Bitmap Create(MandelbrotPosition position, int imageWidth, int imageHeight, CancellationToken cancellationToken, bool parallelRendering)
//000064:         {
//000065:             // The maximum number of iterations to perform for each pixel.  Higher number means better
//000066:             // quality but also slower.
//000067:             const int maxIterations = 256;
//000068: 
//000069:             // In order to use the Bitmap ctor that accepts a stride, the stride must be divisible by four.
//000070:             // We're using imageWidth as the stride, so shift it to be divisible by 4 as necessary.
//000071:             if (imageWidth % 4 != 0) imageWidth = (imageWidth / 4) * 4;
//000072: 
//000073:             // Based on the fractal bounds, determine its upper left coordinate
//000074:             double left = position.CenterX - (position.Width / 2);
//000075:             double top = position.CenterY - (position.Height / 2);
//000076: 
//000077:             // Get the factors that can be multiplied by row and col to arrive at specific x and y values
//000078:             double colToXTranslation = position.Width / (double)imageWidth;
//000079:             double rowToYTranslation = position.Height / (double)imageHeight;
//000080: 
//000081:             // Create the byte array that will store the rendered color indices
//000082:             int pixels = imageWidth * imageHeight;
//000083:             byte[] data = new byte[pixels]; // initialized to all 0s, which equates to all black based on the default palette
//000084: 
//000085:             // Generate the fractal using the mandelbrot formula : z = z^2 + c
//000086: 
//000087:             // Parallel implementation
//000088:             if (parallelRendering)
//000089:             {
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
//000091:                 Parallel.For(0, imageHeight, options, row =>
//000092:                 {
      IL_0000:  nop
//000093:                     double initialY = row * rowToYTranslation + top;
      IL_0001:  ldarg.1
      IL_0002:  conv.r8
      IL_0003:  ldarg.0
      IL_0004:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::rowToYTranslation
      IL_0009:  mul
      IL_000a:  ldarg.0
      IL_000b:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::top
      IL_0010:  add
      IL_0011:  stloc.0
//000094:                     fixed (byte* ptr = data)
      IL_0012:  ldarg.0
      IL_0013:  ldfld      uint8[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::data
      IL_0018:  dup
      IL_0019:  stloc.s    CS$0$0000
      IL_001b:  brfalse.s  IL_0023

      IL_001d:  ldloc.s    CS$0$0000
      IL_001f:  ldlen
      IL_0020:  conv.i4
      IL_0021:  brtrue.s   IL_0028

      IL_0023:  ldc.i4.0
      IL_0024:  conv.u
      IL_0025:  stloc.1
      IL_0026:  br.s       IL_0031

      IL_0028:  ldloc.s    CS$0$0000
      IL_002a:  ldc.i4.0
      IL_002b:  ldelema    [mscorlib]System.Byte
      IL_0030:  stloc.1
//000095:                     {
      IL_0031:  nop
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
      IL_0032:  ldloc.1
      IL_0033:  conv.i
      IL_0034:  ldarg.1
      IL_0035:  conv.i
      IL_0036:  ldarg.0
      IL_0037:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
      IL_003c:  mul
      IL_003d:  add
      IL_003e:  conv.u
      IL_003f:  stloc.2
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
      IL_0040:  ldc.i4.0
      IL_0041:  stloc.3
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
      IL_0042:  br.s       IL_00bd

//000098:                         {
      IL_0044:  nop
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
      IL_0045:  ldloca.s   c
      IL_0047:  ldloc.3
      IL_0048:  conv.r8
      IL_0049:  ldarg.0
      IL_004a:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::colToXTranslation
      IL_004f:  mul
      IL_0050:  ldarg.0
      IL_0051:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::left
      IL_0056:  add
      IL_0057:  ldloc.0
      IL_0058:  call       instance void [System.Numerics]System.Numerics.Complex::.ctor(float64,
                                                                                         float64)
      IL_005d:  nop
//000100:                             Complex z = c;
      IL_005e:  ldloc.s    c
      IL_0060:  stloc.s    z
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
      IL_0062:  ldc.i4.0
      IL_0063:  stloc.s    iteration
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
      IL_0065:  br.s       IL_00a4

//000102:                             {
      IL_0067:  nop
//000103:                                 if (z.Magnitude > 4)
      IL_0068:  ldloca.s   z
      IL_006a:  call       instance float64 [System.Numerics]System.Numerics.Complex::get_Magnitude()
      IL_006f:  ldc.r8     4.
      IL_0078:  cgt
      IL_007a:  ldc.i4.0
      IL_007b:  ceq
      IL_007d:  stloc.s    CS$4$0001
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
      IL_007f:  ldloc.s    CS$4$0001
      IL_0081:  brtrue.s   IL_008b

//000104:                                 {
      IL_0083:  nop
//000105:                                     *currentPixel = (byte)iteration;
      IL_0084:  ldloc.2
      IL_0085:  ldloc.s    iteration
      IL_0087:  conv.u1
      IL_0088:  stind.i1
//000106:                                     break;
      IL_0089:  br.s       IL_00b3

//000107:                                 }
//000108:                                 z = (z * z) + c;
      IL_008b:  ldloc.s    z
      IL_008d:  ldloc.s    z
      IL_008f:  call       valuetype [System.Numerics]System.Numerics.Complex [System.Numerics]System.Numerics.Complex::op_Multiply(valuetype [System.Numerics]System.Numerics.Complex,
                                                                                                                                    valuetype [System.Numerics]System.Numerics.Complex)
      IL_0094:  ldloc.s    c
      IL_0096:  call       valuetype [System.Numerics]System.Numerics.Complex [System.Numerics]System.Numerics.Complex::op_Addition(valuetype [System.Numerics]System.Numerics.Complex,
                                                                                                                                    valuetype [System.Numerics]System.Numerics.Complex)
      IL_009b:  stloc.s    z
//000109:                             }
      IL_009d:  nop
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
      IL_009e:  ldloc.s    iteration
      IL_00a0:  ldc.i4.1
      IL_00a1:  add
      IL_00a2:  stloc.s    iteration
      IL_00a4:  ldloc.s    iteration
      IL_00a6:  ldc.i4     0x100
      IL_00ab:  clt
      IL_00ad:  stloc.s    CS$4$0001
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
      IL_00af:  ldloc.s    CS$4$0001
      IL_00b1:  brtrue.s   IL_0067

//000110:                         }
      IL_00b3:  nop
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
      IL_00b4:  ldloc.3
      IL_00b5:  ldc.i4.1
      IL_00b6:  add
      IL_00b7:  stloc.3
      IL_00b8:  ldloc.2
      IL_00b9:  ldc.i4.1
      IL_00ba:  conv.i
      IL_00bb:  add
      IL_00bc:  stloc.2
      IL_00bd:  ldloc.3
      IL_00be:  ldarg.0
      IL_00bf:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
      IL_00c4:  clt
      IL_00c6:  stloc.s    CS$4$0001
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
      IL_00c8:  ldloc.s    CS$4$0001
      IL_00ca:  brtrue     IL_0044

//000111:                     }
      IL_00cf:  nop
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
      IL_00d0:  ldc.i4.0
      IL_00d1:  conv.u
      IL_00d2:  stloc.1
      IL_00d3:  ret
    } // end of method '<>c__DisplayClass3'::'<Create>b__1'

  } // end of class '<>c__DisplayClass3'

  .field private static valuetype [System.Drawing]System.Drawing.Color[] _paletteColors
  .method private hidebysig static valuetype [System.Drawing]System.Drawing.Color[] 
          CreatePaletteColors() cil managed
  {
    // Code size       91 (0x5b)
    .maxstack  5
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Color[] paletteColors,
             [1] int32 i,
             [2] valuetype [System.Drawing]System.Drawing.Color[] CS$1$0000,
             [3] bool CS$4$0001)
//000041:         {
    IL_0000:  nop
//000042:             Color[] paletteColors = new Color[256];
    IL_0001:  ldc.i4     0x100
    IL_0006:  newarr     [System.Drawing]System.Drawing.Color
    IL_000b:  stloc.0
//000043:             paletteColors[0] = Color.Black;
    IL_000c:  ldloc.0
    IL_000d:  ldc.i4.0
    IL_000e:  ldelema    [System.Drawing]System.Drawing.Color
    IL_0013:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Black()
    IL_0018:  stobj      [System.Drawing]System.Drawing.Color
//000044:             for (int i = 1; i < 256; i++) paletteColors[i] = Color.FromArgb(0, i * 5 % 256, i * 5 % 256); // change this at will for different colorings
    IL_001d:  ldc.i4.1
    IL_001e:  stloc.1
//000045:             return paletteColors;
//000046:         }
//000047: 
//000048:         /// <summary>Copy our precreated color palette into the target Bitmap.</summary>
//000049:         /// <param name="bmp">The Bitmap to be updated.</param>
//000050:         private static void UpdatePalette(Bitmap bmp)
//000051:         {
//000052:             ColorPalette p = bmp.Palette;
//000053:             Array.Copy(_paletteColors, p.Entries, _paletteColors.Length);
//000054:             bmp.Palette = p; // The Bitmap will only update when the Palette property's setter is used
//000055:         }
//000056: 
//000057:         /// <summary>Renders a mandelbrot fractal.</summary>
//000058:         /// <param name="position">The MandelbrotPosition representing the fractal boundaries to be rendered.</param>
//000059:         /// <param name="imageWidth">The width in pixels of the image to create.</param>
//000060:         /// <param name="imageHeight">The height in pixels of the image to create.</param>
//000061:         /// <param name="parallelRendering">Whether to render the image in parallel.</param>
//000062:         /// <returns>The rendered Bitmap.</returns>
//000063:         public unsafe static Bitmap Create(MandelbrotPosition position, int imageWidth, int imageHeight, CancellationToken cancellationToken, bool parallelRendering)
//000064:         {
//000065:             // The maximum number of iterations to perform for each pixel.  Higher number means better
//000066:             // quality but also slower.
//000067:             const int maxIterations = 256;
//000068: 
//000069:             // In order to use the Bitmap ctor that accepts a stride, the stride must be divisible by four.
//000070:             // We're using imageWidth as the stride, so shift it to be divisible by 4 as necessary.
//000071:             if (imageWidth % 4 != 0) imageWidth = (imageWidth / 4) * 4;
//000072: 
//000073:             // Based on the fractal bounds, determine its upper left coordinate
//000074:             double left = position.CenterX - (position.Width / 2);
//000075:             double top = position.CenterY - (position.Height / 2);
//000076: 
//000077:             // Get the factors that can be multiplied by row and col to arrive at specific x and y values
//000078:             double colToXTranslation = position.Width / (double)imageWidth;
//000079:             double rowToYTranslation = position.Height / (double)imageHeight;
//000080: 
//000081:             // Create the byte array that will store the rendered color indices
//000082:             int pixels = imageWidth * imageHeight;
//000083:             byte[] data = new byte[pixels]; // initialized to all 0s, which equates to all black based on the default palette
//000084: 
//000085:             // Generate the fractal using the mandelbrot formula : z = z^2 + c
//000086: 
//000087:             // Parallel implementation
//000088:             if (parallelRendering)
//000089:             {
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
//000091:                 Parallel.For(0, imageHeight, options, row =>
//000092:                 {
//000093:                     double initialY = row * rowToYTranslation + top;
//000094:                     fixed (byte* ptr = data)
//000095:                     {
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_001f:  br.s       IL_0049

//000044:             for (int i = 1; i < 256; i++) paletteColors[i] = Color.FromArgb(0, i * 5 % 256, i * 5 % 256); // change this at will for different colorings
    IL_0021:  ldloc.0
    IL_0022:  ldloc.1
    IL_0023:  ldelema    [System.Drawing]System.Drawing.Color
    IL_0028:  ldc.i4.0
    IL_0029:  ldloc.1
    IL_002a:  ldc.i4.5
    IL_002b:  mul
    IL_002c:  ldc.i4     0x100
    IL_0031:  rem
    IL_0032:  ldloc.1
    IL_0033:  ldc.i4.5
    IL_0034:  mul
    IL_0035:  ldc.i4     0x100
    IL_003a:  rem
    IL_003b:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_0040:  stobj      [System.Drawing]System.Drawing.Color
    IL_0045:  ldloc.1
    IL_0046:  ldc.i4.1
    IL_0047:  add
    IL_0048:  stloc.1
    IL_0049:  ldloc.1
    IL_004a:  ldc.i4     0x100
    IL_004f:  clt
    IL_0051:  stloc.3
//000045:             return paletteColors;
//000046:         }
//000047: 
//000048:         /// <summary>Copy our precreated color palette into the target Bitmap.</summary>
//000049:         /// <param name="bmp">The Bitmap to be updated.</param>
//000050:         private static void UpdatePalette(Bitmap bmp)
//000051:         {
//000052:             ColorPalette p = bmp.Palette;
//000053:             Array.Copy(_paletteColors, p.Entries, _paletteColors.Length);
//000054:             bmp.Palette = p; // The Bitmap will only update when the Palette property's setter is used
//000055:         }
//000056: 
//000057:         /// <summary>Renders a mandelbrot fractal.</summary>
//000058:         /// <param name="position">The MandelbrotPosition representing the fractal boundaries to be rendered.</param>
//000059:         /// <param name="imageWidth">The width in pixels of the image to create.</param>
//000060:         /// <param name="imageHeight">The height in pixels of the image to create.</param>
//000061:         /// <param name="parallelRendering">Whether to render the image in parallel.</param>
//000062:         /// <returns>The rendered Bitmap.</returns>
//000063:         public unsafe static Bitmap Create(MandelbrotPosition position, int imageWidth, int imageHeight, CancellationToken cancellationToken, bool parallelRendering)
//000064:         {
//000065:             // The maximum number of iterations to perform for each pixel.  Higher number means better
//000066:             // quality but also slower.
//000067:             const int maxIterations = 256;
//000068: 
//000069:             // In order to use the Bitmap ctor that accepts a stride, the stride must be divisible by four.
//000070:             // We're using imageWidth as the stride, so shift it to be divisible by 4 as necessary.
//000071:             if (imageWidth % 4 != 0) imageWidth = (imageWidth / 4) * 4;
//000072: 
//000073:             // Based on the fractal bounds, determine its upper left coordinate
//000074:             double left = position.CenterX - (position.Width / 2);
//000075:             double top = position.CenterY - (position.Height / 2);
//000076: 
//000077:             // Get the factors that can be multiplied by row and col to arrive at specific x and y values
//000078:             double colToXTranslation = position.Width / (double)imageWidth;
//000079:             double rowToYTranslation = position.Height / (double)imageHeight;
//000080: 
//000081:             // Create the byte array that will store the rendered color indices
//000082:             int pixels = imageWidth * imageHeight;
//000083:             byte[] data = new byte[pixels]; // initialized to all 0s, which equates to all black based on the default palette
//000084: 
//000085:             // Generate the fractal using the mandelbrot formula : z = z^2 + c
//000086: 
//000087:             // Parallel implementation
//000088:             if (parallelRendering)
//000089:             {
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
//000091:                 Parallel.For(0, imageHeight, options, row =>
//000092:                 {
//000093:                     double initialY = row * rowToYTranslation + top;
//000094:                     fixed (byte* ptr = data)
//000095:                     {
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_0052:  ldloc.3
    IL_0053:  brtrue.s   IL_0021

//000045:             return paletteColors;
    IL_0055:  ldloc.0
    IL_0056:  stloc.2
    IL_0057:  br.s       IL_0059

//000046:         }
    IL_0059:  ldloc.2
    IL_005a:  ret
  } // end of method MandelbrotGenerator::CreatePaletteColors

  .method private hidebysig static void  UpdatePalette(class [System.Drawing]System.Drawing.Bitmap bmp) cil managed
  {
    // Code size       41 (0x29)
    .maxstack  3
    .locals init ([0] class [System.Drawing]System.Drawing.Imaging.ColorPalette p)
//000047: 
//000048:         /// <summary>Copy our precreated color palette into the target Bitmap.</summary>
//000049:         /// <param name="bmp">The Bitmap to be updated.</param>
//000050:         private static void UpdatePalette(Bitmap bmp)
//000051:         {
    IL_0000:  nop
//000052:             ColorPalette p = bmp.Palette;
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.ColorPalette [System.Drawing]System.Drawing.Image::get_Palette()
    IL_0007:  stloc.0
//000053:             Array.Copy(_paletteColors, p.Entries, _paletteColors.Length);
    IL_0008:  ldsfld     valuetype [System.Drawing]System.Drawing.Color[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator::_paletteColors
    IL_000d:  ldloc.0
    IL_000e:  callvirt   instance valuetype [System.Drawing]System.Drawing.Color[] [System.Drawing]System.Drawing.Imaging.ColorPalette::get_Entries()
    IL_0013:  ldsfld     valuetype [System.Drawing]System.Drawing.Color[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator::_paletteColors
    IL_0018:  ldlen
    IL_0019:  conv.i4
    IL_001a:  call       void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,
                                                           class [mscorlib]System.Array,
                                                           int32)
    IL_001f:  nop
//000054:             bmp.Palette = p; // The Bitmap will only update when the Palette property's setter is used
    IL_0020:  ldarg.0
    IL_0021:  ldloc.0
    IL_0022:  callvirt   instance void [System.Drawing]System.Drawing.Image::set_Palette(class [System.Drawing]System.Drawing.Imaging.ColorPalette)
    IL_0027:  nop
//000055:         }
    IL_0028:  ret
  } // end of method MandelbrotGenerator::UpdatePalette

  .method public hidebysig static class [System.Drawing]System.Drawing.Bitmap 
          Create(valuetype Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition position,
                 int32 imageWidth,
                 int32 imageHeight,
                 valuetype [mscorlib]System.Threading.CancellationToken cancellationToken,
                 bool parallelRendering) cil managed
  {
    // Code size       663 (0x297)
    .maxstack  6
    .locals init ([0] int32 pixels,
             [1] class [mscorlib]System.Threading.Tasks.ParallelOptions options,
             [2] class [mscorlib]System.Threading.Tasks.ParallelOptions '<>g__initLocal0',
             [3] int32 row,
             [4] float64 initialY,
             [5] uint8& pinned ptr,
             [6] uint8* currentPixel,
             [7] int32 col,
             [8] valuetype [System.Numerics]System.Numerics.Complex c,
             [9] valuetype [System.Numerics]System.Numerics.Complex z,
             [10] int32 iteration,
             [11] class [System.Drawing]System.Drawing.Bitmap tempBitmap,
             [12] class [System.Drawing]System.Drawing.Bitmap bitmap,
             [13] class [mscorlib]System.Action`1<int32> 'CS$<>9__CachedAnonymousMethodDelegate2',
             [14] class Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3' 'CS$<>8__locals4',
             [15] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [16] bool CS$4$0001,
             [17] uint8[] CS$0$0002)
//000056: 
//000057:         /// <summary>Renders a mandelbrot fractal.</summary>
//000058:         /// <param name="position">The MandelbrotPosition representing the fractal boundaries to be rendered.</param>
//000059:         /// <param name="imageWidth">The width in pixels of the image to create.</param>
//000060:         /// <param name="imageHeight">The height in pixels of the image to create.</param>
//000061:         /// <param name="parallelRendering">Whether to render the image in parallel.</param>
//000062:         /// <returns>The rendered Bitmap.</returns>
//000063:         public unsafe static Bitmap Create(MandelbrotPosition position, int imageWidth, int imageHeight, CancellationToken cancellationToken, bool parallelRendering)
//000064:         {
//000065:             // The maximum number of iterations to perform for each pixel.  Higher number means better
//000066:             // quality but also slower.
//000067:             const int maxIterations = 256;
//000068: 
//000069:             // In order to use the Bitmap ctor that accepts a stride, the stride must be divisible by four.
//000070:             // We're using imageWidth as the stride, so shift it to be divisible by 4 as necessary.
//000071:             if (imageWidth % 4 != 0) imageWidth = (imageWidth / 4) * 4;
//000072: 
//000073:             // Based on the fractal bounds, determine its upper left coordinate
//000074:             double left = position.CenterX - (position.Width / 2);
//000075:             double top = position.CenterY - (position.Height / 2);
//000076: 
//000077:             // Get the factors that can be multiplied by row and col to arrive at specific x and y values
//000078:             double colToXTranslation = position.Width / (double)imageWidth;
//000079:             double rowToYTranslation = position.Height / (double)imageHeight;
//000080: 
//000081:             // Create the byte array that will store the rendered color indices
//000082:             int pixels = imageWidth * imageHeight;
//000083:             byte[] data = new byte[pixels]; // initialized to all 0s, which equates to all black based on the default palette
//000084: 
//000085:             // Generate the fractal using the mandelbrot formula : z = z^2 + c
//000086: 
//000087:             // Parallel implementation
//000088:             if (parallelRendering)
//000089:             {
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
//000091:                 Parallel.For(0, imageHeight, options, row =>
//000092:                 {
//000093:                     double initialY = row * rowToYTranslation + top;
//000094:                     fixed (byte* ptr = data)
//000095:                     {
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_0000:  ldnull
    IL_0001:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_0003:  newobj     instance void Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::.ctor()
    IL_0008:  stloc.s    'CS$<>8__locals4'
    IL_000a:  ldloc.s    'CS$<>8__locals4'
    IL_000c:  ldarg.1
    IL_000d:  stfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
//000064:         {
    IL_0012:  nop
//000065:             // The maximum number of iterations to perform for each pixel.  Higher number means better
//000066:             // quality but also slower.
//000067:             const int maxIterations = 256;
//000068: 
//000069:             // In order to use the Bitmap ctor that accepts a stride, the stride must be divisible by four.
//000070:             // We're using imageWidth as the stride, so shift it to be divisible by 4 as necessary.
//000071:             if (imageWidth % 4 != 0) imageWidth = (imageWidth / 4) * 4;
    IL_0013:  ldloc.s    'CS$<>8__locals4'
    IL_0015:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_001a:  ldc.i4.4
    IL_001b:  rem
    IL_001c:  ldc.i4.0
    IL_001d:  ceq
    IL_001f:  stloc.s    CS$4$0001
//000072: 
//000073:             // Based on the fractal bounds, determine its upper left coordinate
//000074:             double left = position.CenterX - (position.Width / 2);
//000075:             double top = position.CenterY - (position.Height / 2);
//000076: 
//000077:             // Get the factors that can be multiplied by row and col to arrive at specific x and y values
//000078:             double colToXTranslation = position.Width / (double)imageWidth;
//000079:             double rowToYTranslation = position.Height / (double)imageHeight;
//000080: 
//000081:             // Create the byte array that will store the rendered color indices
//000082:             int pixels = imageWidth * imageHeight;
//000083:             byte[] data = new byte[pixels]; // initialized to all 0s, which equates to all black based on the default palette
//000084: 
//000085:             // Generate the fractal using the mandelbrot formula : z = z^2 + c
//000086: 
//000087:             // Parallel implementation
//000088:             if (parallelRendering)
//000089:             {
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
//000091:                 Parallel.For(0, imageHeight, options, row =>
//000092:                 {
//000093:                     double initialY = row * rowToYTranslation + top;
//000094:                     fixed (byte* ptr = data)
//000095:                     {
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_0021:  ldloc.s    CS$4$0001
    IL_0023:  brtrue.s   IL_0037

//000071:             if (imageWidth % 4 != 0) imageWidth = (imageWidth / 4) * 4;
    IL_0025:  ldloc.s    'CS$<>8__locals4'
    IL_0027:  ldloc.s    'CS$<>8__locals4'
    IL_0029:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_002e:  ldc.i4.4
    IL_002f:  div
    IL_0030:  ldc.i4.4
    IL_0031:  mul
    IL_0032:  stfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
//000072: 
//000073:             // Based on the fractal bounds, determine its upper left coordinate
//000074:             double left = position.CenterX - (position.Width / 2);
    IL_0037:  ldloc.s    'CS$<>8__locals4'
    IL_0039:  ldarga.s   position
    IL_003b:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterX
    IL_0040:  ldarga.s   position
    IL_0042:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
    IL_0047:  ldc.r8     2.
    IL_0050:  div
    IL_0051:  sub
    IL_0052:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::left
//000075:             double top = position.CenterY - (position.Height / 2);
    IL_0057:  ldloc.s    'CS$<>8__locals4'
    IL_0059:  ldarga.s   position
    IL_005b:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::CenterY
    IL_0060:  ldarga.s   position
    IL_0062:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
    IL_0067:  ldc.r8     2.
    IL_0070:  div
    IL_0071:  sub
    IL_0072:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::top
//000076: 
//000077:             // Get the factors that can be multiplied by row and col to arrive at specific x and y values
//000078:             double colToXTranslation = position.Width / (double)imageWidth;
    IL_0077:  ldloc.s    'CS$<>8__locals4'
    IL_0079:  ldarga.s   position
    IL_007b:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Width
    IL_0080:  ldloc.s    'CS$<>8__locals4'
    IL_0082:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_0087:  conv.r8
    IL_0088:  div
    IL_0089:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::colToXTranslation
//000079:             double rowToYTranslation = position.Height / (double)imageHeight;
    IL_008e:  ldloc.s    'CS$<>8__locals4'
    IL_0090:  ldarga.s   position
    IL_0092:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotPosition::Height
    IL_0097:  ldarg.2
    IL_0098:  conv.r8
    IL_0099:  div
    IL_009a:  stfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::rowToYTranslation
//000080: 
//000081:             // Create the byte array that will store the rendered color indices
//000082:             int pixels = imageWidth * imageHeight;
    IL_009f:  ldloc.s    'CS$<>8__locals4'
    IL_00a1:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_00a6:  ldarg.2
    IL_00a7:  mul
    IL_00a8:  stloc.0
//000083:             byte[] data = new byte[pixels]; // initialized to all 0s, which equates to all black based on the default palette
    IL_00a9:  ldloc.s    'CS$<>8__locals4'
    IL_00ab:  ldloc.0
    IL_00ac:  newarr     [mscorlib]System.Byte
    IL_00b1:  stfld      uint8[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::data
//000084: 
//000085:             // Generate the fractal using the mandelbrot formula : z = z^2 + c
//000086: 
//000087:             // Parallel implementation
//000088:             if (parallelRendering)
    IL_00b6:  ldarg.s    parallelRendering
    IL_00b8:  ldc.i4.0
    IL_00b9:  ceq
    IL_00bb:  stloc.s    CS$4$0001
//000089:             {
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
//000091:                 Parallel.For(0, imageHeight, options, row =>
//000092:                 {
//000093:                     double initialY = row * rowToYTranslation + top;
//000094:                     fixed (byte* ptr = data)
//000095:                     {
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_00bd:  ldloc.s    CS$4$0001
    IL_00bf:  brtrue.s   IL_00f8

//000089:             {
    IL_00c1:  nop
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
    IL_00c2:  newobj     instance void [mscorlib]System.Threading.Tasks.ParallelOptions::.ctor()
    IL_00c7:  stloc.2
    IL_00c8:  ldloc.2
    IL_00c9:  ldarg.3
    IL_00ca:  callvirt   instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_CancellationToken(valuetype [mscorlib]System.Threading.CancellationToken)
    IL_00cf:  nop
    IL_00d0:  ldloc.2
    IL_00d1:  stloc.1
//000091:                 Parallel.For(0, imageHeight, options, row =>
    IL_00d2:  ldc.i4.0
    IL_00d3:  ldarg.2
    IL_00d4:  ldloc.1
    IL_00d5:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_00d7:  brtrue.s   IL_00ea

    IL_00d9:  ldloc.s    'CS$<>8__locals4'
    IL_00db:  ldftn      instance void Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::'<Create>b__1'(int32)
    IL_00e1:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                     native int)
    IL_00e6:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_00e8:  br.s       IL_00ea

    IL_00ea:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_00ec:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                      int32,
                                                                                                                                      class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                      class [mscorlib]System.Action`1<int32>)
    IL_00f1:  pop
//000092:                 {
//000093:                     double initialY = row * rowToYTranslation + top;
//000094:                     fixed (byte* ptr = data)
//000095:                     {
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
    IL_00f2:  nop
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_00f3:  br         IL_0207

//000116:             {
    IL_00f8:  nop
//000117:                 for (int row = 0; row < imageHeight; row++)
    IL_00f9:  ldc.i4.0
    IL_00fa:  stloc.3
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_00fb:  br         IL_01f9

//000118:                 {
    IL_0100:  nop
//000119:                     cancellationToken.ThrowIfCancellationRequested();
    IL_0101:  ldarga.s   cancellationToken
    IL_0103:  call       instance void [mscorlib]System.Threading.CancellationToken::ThrowIfCancellationRequested()
    IL_0108:  nop
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
    IL_0109:  ldloc.3
    IL_010a:  conv.r8
    IL_010b:  ldloc.s    'CS$<>8__locals4'
    IL_010d:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::rowToYTranslation
    IL_0112:  mul
    IL_0113:  ldloc.s    'CS$<>8__locals4'
    IL_0115:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::top
    IL_011a:  add
    IL_011b:  stloc.s    initialY
//000122:                     fixed (byte* ptr = data)
    IL_011d:  ldloc.s    'CS$<>8__locals4'
    IL_011f:  ldfld      uint8[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::data
    IL_0124:  dup
    IL_0125:  stloc.s    CS$0$0002
    IL_0127:  brfalse.s  IL_012f

    IL_0129:  ldloc.s    CS$0$0002
    IL_012b:  ldlen
    IL_012c:  conv.i4
    IL_012d:  brtrue.s   IL_0135

    IL_012f:  ldc.i4.0
    IL_0130:  conv.u
    IL_0131:  stloc.s    ptr
    IL_0133:  br.s       IL_013f

    IL_0135:  ldloc.s    CS$0$0002
    IL_0137:  ldc.i4.0
    IL_0138:  ldelema    [mscorlib]System.Byte
    IL_013d:  stloc.s    ptr
//000123:                     {
    IL_013f:  nop
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
    IL_0140:  ldloc.s    ptr
    IL_0142:  conv.i
    IL_0143:  ldloc.3
    IL_0144:  conv.i
    IL_0145:  ldloc.s    'CS$<>8__locals4'
    IL_0147:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_014c:  mul
    IL_014d:  add
    IL_014e:  conv.u
    IL_014f:  stloc.s    currentPixel
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
    IL_0151:  ldc.i4.0
    IL_0152:  stloc.s    col
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_0154:  br         IL_01db

//000126:                         {
    IL_0159:  nop
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
    IL_015a:  ldloca.s   c
    IL_015c:  ldloc.s    col
    IL_015e:  conv.r8
    IL_015f:  ldloc.s    'CS$<>8__locals4'
    IL_0161:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::colToXTranslation
    IL_0166:  mul
    IL_0167:  ldloc.s    'CS$<>8__locals4'
    IL_0169:  ldfld      float64 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::left
    IL_016e:  add
    IL_016f:  ldloc.s    initialY
    IL_0171:  call       instance void [System.Numerics]System.Numerics.Complex::.ctor(float64,
                                                                                       float64)
    IL_0176:  nop
//000128:                             Complex z = c;
    IL_0177:  ldloc.s    c
    IL_0179:  stloc.s    z
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
    IL_017b:  ldc.i4.0
    IL_017c:  stloc.s    iteration
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_017e:  br.s       IL_01be

//000130:                             {
    IL_0180:  nop
//000131:                                 if (z.Magnitude > 4)
    IL_0181:  ldloca.s   z
    IL_0183:  call       instance float64 [System.Numerics]System.Numerics.Complex::get_Magnitude()
    IL_0188:  ldc.r8     4.
    IL_0191:  cgt
    IL_0193:  ldc.i4.0
    IL_0194:  ceq
    IL_0196:  stloc.s    CS$4$0001
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_0198:  ldloc.s    CS$4$0001
    IL_019a:  brtrue.s   IL_01a5

//000132:                                 {
    IL_019c:  nop
//000133:                                     *currentPixel = (byte)iteration;
    IL_019d:  ldloc.s    currentPixel
    IL_019f:  ldloc.s    iteration
    IL_01a1:  conv.u1
    IL_01a2:  stind.i1
//000134:                                     break;
    IL_01a3:  br.s       IL_01cd

//000135:                                 }
//000136:                                 z = (z * z) + c;
    IL_01a5:  ldloc.s    z
    IL_01a7:  ldloc.s    z
    IL_01a9:  call       valuetype [System.Numerics]System.Numerics.Complex [System.Numerics]System.Numerics.Complex::op_Multiply(valuetype [System.Numerics]System.Numerics.Complex,
                                                                                                                                  valuetype [System.Numerics]System.Numerics.Complex)
    IL_01ae:  ldloc.s    c
    IL_01b0:  call       valuetype [System.Numerics]System.Numerics.Complex [System.Numerics]System.Numerics.Complex::op_Addition(valuetype [System.Numerics]System.Numerics.Complex,
                                                                                                                                  valuetype [System.Numerics]System.Numerics.Complex)
    IL_01b5:  stloc.s    z
//000137:                             }
    IL_01b7:  nop
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
    IL_01b8:  ldloc.s    iteration
    IL_01ba:  ldc.i4.1
    IL_01bb:  add
    IL_01bc:  stloc.s    iteration
    IL_01be:  ldloc.s    iteration
    IL_01c0:  ldc.i4     0x100
    IL_01c5:  clt
    IL_01c7:  stloc.s    CS$4$0001
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_01c9:  ldloc.s    CS$4$0001
    IL_01cb:  brtrue.s   IL_0180

//000138:                         }
    IL_01cd:  nop
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
    IL_01ce:  ldloc.s    col
    IL_01d0:  ldc.i4.1
    IL_01d1:  add
    IL_01d2:  stloc.s    col
    IL_01d4:  ldloc.s    currentPixel
    IL_01d6:  ldc.i4.1
    IL_01d7:  conv.i
    IL_01d8:  add
    IL_01d9:  stloc.s    currentPixel
    IL_01db:  ldloc.s    col
    IL_01dd:  ldloc.s    'CS$<>8__locals4'
    IL_01df:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_01e4:  clt
    IL_01e6:  stloc.s    CS$4$0001
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_01e8:  ldloc.s    CS$4$0001
    IL_01ea:  brtrue     IL_0159

//000139:                     }
    IL_01ef:  nop
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_01f0:  ldc.i4.0
    IL_01f1:  conv.u
    IL_01f2:  stloc.s    ptr
//000140:                 };
    IL_01f4:  nop
//000117:                 for (int row = 0; row < imageHeight; row++)
    IL_01f5:  ldloc.3
    IL_01f6:  ldc.i4.1
    IL_01f7:  add
    IL_01f8:  stloc.3
    IL_01f9:  ldloc.3
    IL_01fa:  ldarg.2
    IL_01fb:  clt
    IL_01fd:  stloc.s    CS$4$0001
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_01ff:  ldloc.s    CS$4$0001
    IL_0201:  brtrue     IL_0100

//000141:             }
    IL_0206:  nop
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
    IL_0207:  ldloc.s    'CS$<>8__locals4'
    IL_0209:  ldfld      uint8[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::data
    IL_020e:  dup
    IL_020f:  stloc.s    CS$0$0002
    IL_0211:  brfalse.s  IL_0219

    IL_0213:  ldloc.s    CS$0$0002
    IL_0215:  ldlen
    IL_0216:  conv.i4
    IL_0217:  brtrue.s   IL_021f

    IL_0219:  ldc.i4.0
    IL_021a:  conv.u
    IL_021b:  stloc.s    ptr
    IL_021d:  br.s       IL_0229

    IL_021f:  ldloc.s    CS$0$0002
    IL_0221:  ldc.i4.0
    IL_0222:  ldelema    [mscorlib]System.Byte
    IL_0227:  stloc.s    ptr
//000145:             {
    IL_0229:  nop
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
    IL_022a:  ldloc.s    'CS$<>8__locals4'
    IL_022c:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_0231:  ldarg.2
    IL_0232:  ldloc.s    'CS$<>8__locals4'
    IL_0234:  ldfld      int32 Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator/'<>c__DisplayClass3'::imageWidth
    IL_0239:  ldc.i4     0x30803
    IL_023e:  ldloc.s    ptr
    IL_0240:  conv.i
    IL_0241:  call       native int [mscorlib]System.IntPtr::op_Explicit(void*)
    IL_0246:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32,
                                                                                    int32,
                                                                                    valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat,
                                                                                    native int)
    IL_024b:  stloc.s    tempBitmap
//000147:                 {
    .try
    {
      IL_024d:  nop
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
      IL_024e:  ldloc.s    tempBitmap
      IL_0250:  ldc.i4.0
      IL_0251:  ldc.i4.0
      IL_0252:  ldloc.s    tempBitmap
      IL_0254:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
      IL_0259:  ldloc.s    tempBitmap
      IL_025b:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
      IL_0260:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                         int32,
                                                                                         int32,
                                                                                         int32)
      IL_0265:  ldc.i4     0x30803
      IL_026a:  callvirt   instance class [System.Drawing]System.Drawing.Bitmap [System.Drawing]System.Drawing.Bitmap::Clone(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                             valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_026f:  stloc.s    bitmap
//000149:                     UpdatePalette(bitmap);
      IL_0271:  ldloc.s    bitmap
      IL_0273:  call       void Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator::UpdatePalette(class [System.Drawing]System.Drawing.Bitmap)
      IL_0278:  nop
//000150:                     return bitmap;
      IL_0279:  ldloc.s    bitmap
      IL_027b:  stloc.s    CS$1$0000
      IL_027d:  leave.s    IL_0293

//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    }  // end .try
    finally
    {
      IL_027f:  ldloc.s    tempBitmap
      IL_0281:  ldnull
      IL_0282:  ceq
      IL_0284:  stloc.s    CS$4$0001
      IL_0286:  ldloc.s    CS$4$0001
      IL_0288:  brtrue.s   IL_0292

      IL_028a:  ldloc.s    tempBitmap
      IL_028c:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0291:  nop
      IL_0292:  endfinally
    }  // end handler
    IL_0293:  nop
    IL_0294:  ldloc.s    CS$1$0000
    IL_0296:  ret
  } // end of method MandelbrotGenerator::Create

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method MandelbrotGenerator::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  8
//000036:         private static Color[] _paletteColors = CreatePaletteColors();
    IL_0000:  call       valuetype [System.Drawing]System.Drawing.Color[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator::CreatePaletteColors()
    IL_0005:  stsfld     valuetype [System.Drawing]System.Drawing.Color[] Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator::_paletteColors
//000037: 
//000038:         /// <summary>Create the color palette to be used for all fractals.</summary>
//000039:         /// <returns>A 256-color array that can be stored into an 8bpp Bitmap's ColorPalette.</returns>
//000040:         private static Color[] CreatePaletteColors()
//000041:         {
//000042:             Color[] paletteColors = new Color[256];
//000043:             paletteColors[0] = Color.Black;
//000044:             for (int i = 1; i < 256; i++) paletteColors[i] = Color.FromArgb(0, i * 5 % 256, i * 5 % 256); // change this at will for different colorings
//000045:             return paletteColors;
//000046:         }
//000047: 
//000048:         /// <summary>Copy our precreated color palette into the target Bitmap.</summary>
//000049:         /// <param name="bmp">The Bitmap to be updated.</param>
//000050:         private static void UpdatePalette(Bitmap bmp)
//000051:         {
//000052:             ColorPalette p = bmp.Palette;
//000053:             Array.Copy(_paletteColors, p.Entries, _paletteColors.Length);
//000054:             bmp.Palette = p; // The Bitmap will only update when the Palette property's setter is used
//000055:         }
//000056: 
//000057:         /// <summary>Renders a mandelbrot fractal.</summary>
//000058:         /// <param name="position">The MandelbrotPosition representing the fractal boundaries to be rendered.</param>
//000059:         /// <param name="imageWidth">The width in pixels of the image to create.</param>
//000060:         /// <param name="imageHeight">The height in pixels of the image to create.</param>
//000061:         /// <param name="parallelRendering">Whether to render the image in parallel.</param>
//000062:         /// <returns>The rendered Bitmap.</returns>
//000063:         public unsafe static Bitmap Create(MandelbrotPosition position, int imageWidth, int imageHeight, CancellationToken cancellationToken, bool parallelRendering)
//000064:         {
//000065:             // The maximum number of iterations to perform for each pixel.  Higher number means better
//000066:             // quality but also slower.
//000067:             const int maxIterations = 256;
//000068: 
//000069:             // In order to use the Bitmap ctor that accepts a stride, the stride must be divisible by four.
//000070:             // We're using imageWidth as the stride, so shift it to be divisible by 4 as necessary.
//000071:             if (imageWidth % 4 != 0) imageWidth = (imageWidth / 4) * 4;
//000072: 
//000073:             // Based on the fractal bounds, determine its upper left coordinate
//000074:             double left = position.CenterX - (position.Width / 2);
//000075:             double top = position.CenterY - (position.Height / 2);
//000076: 
//000077:             // Get the factors that can be multiplied by row and col to arrive at specific x and y values
//000078:             double colToXTranslation = position.Width / (double)imageWidth;
//000079:             double rowToYTranslation = position.Height / (double)imageHeight;
//000080: 
//000081:             // Create the byte array that will store the rendered color indices
//000082:             int pixels = imageWidth * imageHeight;
//000083:             byte[] data = new byte[pixels]; // initialized to all 0s, which equates to all black based on the default palette
//000084: 
//000085:             // Generate the fractal using the mandelbrot formula : z = z^2 + c
//000086: 
//000087:             // Parallel implementation
//000088:             if (parallelRendering)
//000089:             {
//000090:                 var options = new ParallelOptions { CancellationToken = cancellationToken };
//000091:                 Parallel.For(0, imageHeight, options, row =>
//000092:                 {
//000093:                     double initialY = row * rowToYTranslation + top;
//000094:                     fixed (byte* ptr = data)
//000095:                     {
//000096:                         byte* currentPixel = &ptr[row * imageWidth];
//000097:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000098:                         {
//000099:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000100:                             Complex z = c;
//000101:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000102:                             {
//000103:                                 if (z.Magnitude > 4)
//000104:                                 {
//000105:                                     *currentPixel = (byte)iteration;
//000106:                                     break;
//000107:                                 }
//000108:                                 z = (z * z) + c;
//000109:                             }
//000110:                         }
//000111:                     }
//000112:                 });
//000113:             }
//000114:                 // Sequential implementation
//000115:             else
//000116:             {
//000117:                 for (int row = 0; row < imageHeight; row++)
//000118:                 {
//000119:                     cancellationToken.ThrowIfCancellationRequested();
//000120: 
//000121:                     double initialY = row * rowToYTranslation + top;
//000122:                     fixed (byte* ptr = data)
//000123:                     {
//000124:                         byte* currentPixel = &ptr[row * imageWidth];
//000125:                         for (int col = 0; col < imageWidth; col++, currentPixel++)
//000126:                         {
//000127:                             Complex c = new Complex(col * colToXTranslation + left, initialY);
//000128:                             Complex z = c;
//000129:                             for (int iteration = 0; iteration < maxIterations; iteration++)
//000130:                             {
//000131:                                 if (z.Magnitude > 4)
//000132:                                 {
//000133:                                     *currentPixel = (byte)iteration;
//000134:                                     break;
//000135:                                 }
//000136:                                 z = (z * z) + c;
//000137:                             }
//000138:                         }
//000139:                     }
//000140:                 };
//000141:             }
//000142: 
//000143:             // Produce a Bitmap from the byte array of color indices and return it
//000144:             fixed (byte* ptr = data)
//000145:             {
//000146:                 using (Bitmap tempBitmap = new Bitmap(imageWidth, imageHeight, imageWidth, PixelFormat.Format8bppIndexed, (IntPtr)ptr))
//000147:                 {
//000148:                     Bitmap bitmap = tempBitmap.Clone(new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height), PixelFormat.Format8bppIndexed);
//000149:                     UpdatePalette(bitmap);
//000150:                     return bitmap;
//000151:                 }
//000152:             }
//000153:         }
//000154:     }
//000155: }
    IL_000a:  ret
  } // end of method MandelbrotGenerator::.cctor

} // end of class Microsoft.Pcp.Pfx.InteractiveFractal.MandelbrotGenerator


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
