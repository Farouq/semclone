<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Properties\Resources.Designer.cs" startline="32" endline="35"><![CDATA[
         [global
         internal Resources()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Properties\Resources.Designer.cs" startline="36" endline="51"><![CDATA[
 
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 if ((resourceMan == null))
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
             set
             {
                 resourceCulture = value;
             }
         }
     }
 }
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Properties\Resources.Designer.cs" startline="52" endline="64"><![CDATA[
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Properties\Resources.Designer.cs" startline="65" endline="68"><![CDATA[
             set
             {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Cylinder.cs" startline="23" endline="100"><![CDATA[
         public Cylinder(double radius, double height, int resolution, Material material)
             
         {
 
             m_material = material;
             // 3 meshes per resolution of a cylineder
             // and a square that makes up the edge of the cylinder
             // this translates to 6 points
             // the center of the bottom of the cylinder, and the four points
             // that make up the square
 
             // constants
             var cylinderMeshGroup = new Model3DGroup();
             // invariant ref points
             var topCenter = new Point3D(0.0, 0.0, height);
             var bottomCenter = new Point3D(0.0, 0.0, 0.0);
             // degrees of the circle that each resolution covers
             var rotateTransform = new RotateTransform(360.0 / resolution);
             // we use this point to determine the 2d dimensional points that make 
             // up the edge of both the top and bottom circles
             var circleReferencePoint = new Point(radius, 0.0);
 
             // make one mesh object per resolution
             for (int i = 0; i < resolution; ++i)
             {
                 // 4 points that make up the edge square
                 Point3D topLeft, bottomLeft, topRight, bottomRight;
                 topLeft = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, height);
                 bottomLeft = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, 0.0);
                 // rotate again to find right edge of square
                 circleReferencePoint = rotateTransform.Transform(circleReferencePoint);
                 topRight = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, height);
                 bottomRight = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, 0.0);
 
                 // create top triangle mesh
                 var topTriangleMesh = new MeshGeometry3D();
                 topTriangleMesh.Positions.Add(topCenter);
                 topTriangleMesh.Positions.Add(topLeft);
                 topTriangleMesh.Positions.Add(topRight);
                 // create bottom triangle mesh
                 var bottomTriangleMesh = new MeshGeometry3D();
                 bottomTriangleMesh.Positions.Add(bottomCenter);
                 bottomTriangleMesh.Positions.Add(bottomRight);
                 bottomTriangleMesh.Positions.Add(bottomLeft);
                 // create side square mesh
                 var sideSquareMesh = new MeshGeometry3D();
                 sideSquareMesh.Positions.Add(topLeft);
                 sideSquareMesh.Positions.Add(bottomLeft);
                 sideSquareMesh.Positions.Add(topRight);
                 sideSquareMesh.Positions.Add(bottomRight);
                 sideSquareMesh.TriangleIndices.Add(0);
                 sideSquareMesh.TriangleIndices.Add(1);
                 sideSquareMesh.TriangleIndices.Add(2);
                 sideSquareMesh.TriangleIndices.Add(1);
                 sideSquareMesh.TriangleIndices.Add(3);
                 sideSquareMesh.TriangleIndices.Add(2);
 
                 // add the meshes to the overall cylinder
                 // top triangle
                 var topTriangleModel = new GeometryModel3D();
                 topTriangleModel.Geometry = topTriangleMesh;
                 topTriangleModel.Material = material;
                 cylinderMeshGroup.Children.Add(topTriangleModel);
                 // bottom triangle
                 var bottomTriangleModel = new GeometryModel3D();
                 bottomTriangleModel.Geometry = bottomTriangleMesh;
                 bottomTriangleModel.Material = material;
                 cylinderMeshGroup.Children.Add(bottomTriangleModel);
                 // side square
                 var sideSquareModel = new GeometryModel3D();
                 sideSquareModel.Geometry = sideSquareMesh;
                 sideSquareModel.Material = material;
                 cylinderMeshGroup.Children.Add(sideSquareModel);
             }
             this.Content = cylinderMeshGroup;
             m_centerPoint = new Point3D(0.0, 0.0, 0.0);
             Transform = new Transform3DGroup();
         }
 
         public Material Material
         {
             get
             {
                 return m_material;
             }
         }
 
         public new Transform3D Transform
         {
             get
             {
                 return base.Transform;
             }
 
             set
             {
                 //m_centerPoint = value.Transform(CenterPoint);
                 base.Transform = value;
             }
         }
 
         //public Point3D CenterPoint
         //{
         //    get
         //    {
         //        return m_centerPoint;
         //    }
         //}
         private Point3D m_centerPoint;
 
         public void MoveTo(Point3D newCenterPoint)
         {
 
             (Transform as Transform3DGroup).Children.Add( new TranslateTransform3D(Point3D.Subtract(newCenterPoint, m_centerPoint)));
         }
         
    
     }
 }
 
             {
                 // 4 points that make up the edge square
                 Point3D topLeft, bottomLeft, topRight, bottomRight;
                 topLeft = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, height);
                 bottomLeft = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, 0.0);
                 // rotate again to find right edge of square
                 circleReferencePoint = rotateTransform.Transform(circleReferencePoint);
                 topRight = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, height);
                 bottomRight = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, 0.0);
 
                 // create top triangle mesh
                 var topTriangleMesh = new MeshGeometry3D();
                 topTriangleMesh.Positions.Add(topCenter);
                 topTriangleMesh.Positions.Add(topLeft);
                 topTriangleMesh.Positions.Add(topRight);
                 // create bottom triangle mesh
                 var bottomTriangleMesh = new MeshGeometry3D();
                 bottomTriangleMesh.Positions.Add(bottomCenter);
                 bottomTriangleMesh.Positions.Add(bottomRight);
                 bottomTriangleMesh.Positions.Add(bottomLeft);
                 // create side square mesh
                 var sideSquareMesh = new MeshGeometry3D();
                 sideSquareMesh.Positions.Add(topLeft);
                 sideSquareMesh.Positions.Add(bottomLeft);
                 sideSquareMesh.Positions.Add(topRight);
                 sideSquareMesh.Positions.Add(bottomRight);
                 sideSquareMesh.TriangleIndices.Add(0);
                 sideSquareMesh.TriangleIndices.Add(1);
                 sideSquareMesh.TriangleIndices.Add(2);
                 sideSquareMesh.TriangleIndices.Add(1);
                 sideSquareMesh.TriangleIndices.Add(3);
                 sideSquareMesh.TriangleIndices.Add(2);
 
                 // add the meshes to the overall cylinder
                 // top triangle
                 var topTriangleModel = new GeometryModel3D();
                 topTriangleModel.Geometry = topTriangleMesh;
                 topTriangleModel.Material = material;
                 cylinderMeshGroup.Children.Add(topTriangleModel);
                 // bottom triangle
                 var bottomTriangleModel = new GeometryModel3D();
                 bottomTriangleModel.Geometry = bottomTriangleMesh;
                 bottomTriangleModel.Material = material;
                 cylinderMeshGroup.Children.Add(bottomTriangleModel);
                 // side square
                 var sideSquareModel = new GeometryModel3D();
                 sideSquareModel.Geometry = sideSquareMesh;
                 sideSquareModel.Material = material;
                 cylinderMeshGroup.Children.Add(sideSquareModel);
             }
             for (int i = 0; i < resolution; ++i)
             {
                 // 4 points that make up the edge square
                 Point3D topLeft, bottomLeft, topRight, bottomRight;
                 topLeft = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, height);
                 bottomLeft = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, 0.0);
                 // rotate again to find right edge of square
                 circleReferencePoint = rotateTransform.Transform(circleReferencePoint);
                 topRight = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, height);
                 bottomRight = new Point3D(circleReferencePoint.X, circleReferencePoint.Y, 0.0);
 
                 // create top triangle mesh
                 var topTriangleMesh = new MeshGeometry3D();
                 topTriangleMesh.Positions.Add(topCenter);
                 topTriangleMesh.Positions.Add(topLeft);
                 topTriangleMesh.Positions.Add(topRight);
                 // create bottom triangle mesh
                 var bottomTriangleMesh = new MeshGeometry3D();
                 bottomTriangleMesh.Positions.Add(bottomCenter);
                 bottomTriangleMesh.Positions.Add(bottomRight);
                 bottomTriangleMesh.Positions.Add(bottomLeft);
                 // create side square mesh
                 var sideSquareMesh = new MeshGeometry3D();
                 sideSquareMesh.Positions.Add(topLeft);
                 sideSquareMesh.Positions.Add(bottomLeft);
                 sideSquareMesh.Positions.Add(topRight);
                 sideSquareMesh.Positions.Add(bottomRight);
                 sideSquareMesh.TriangleIndices.Add(0);
                 sideSquareMesh.TriangleIndices.Add(1);
                 sideSquareMesh.TriangleIndices.Add(2);
                 sideSquareMesh.TriangleIndices.Add(1);
                 sideSquareMesh.TriangleIndices.Add(3);
                 sideSquareMesh.TriangleIndices.Add(2);
 
                 // add the meshes to the overall cylinder
                 // top triangle
                 var topTriangleModel = new GeometryModel3D();
                 topTriangleModel.Geometry = topTriangleMesh;
                 topTriangleModel.Material = material;
                 cylinderMeshGroup.Children.Add(topTriangleModel);
                 // bottom triangle
                 var bottomTriangleModel = new GeometryModel3D();
                 bottomTriangleModel.Geometry = bottomTriangleMesh;
                 bottomTriangleModel.Material = material;
                 cylinderMeshGroup.Children.Add(bottomTriangleModel);
                 // side square
                 var sideSquareModel = new GeometryModel3D();
                 sideSquareModel.Geometry = sideSquareMesh;
                 sideSquareModel.Material = material;
                 cylinderMeshGroup.Children.Add(sideSquareModel);
             }
             this.Content = cylinderMeshGroup;
             m_centerPoint = new Point3D(0.0, 0.0, 0.0);
             Transform = new Transform3DGroup();
         }
 
         public Material Material
         {
             get
             {
                 return m_material;
             }
         }
 
         public new Transform3D Transform
         {
             get
             {
                 return base.Transform;
             }
 
             set
             {
                 //m_centerPoint = value.Transform(CenterPoint);
                 base.Transform = value;
             }
         }
 
         //public Point3D CenterPoint
         //{
         //    get
         //    {
         //        return m_centerPoint;
         //    }
         //}
         private Point3D m_centerPoint;
 
         public void MoveTo(Point3D newCenterPoint)
         {
 
             (Transform as Transform3DGroup).Children.Add( new TranslateTransform3D(Point3D.Subtract(newCenterPoint, m_centerPoint)));
         }
         
    
     }
 }
 
             this.Content = cylinderMeshGroup;
             m_centerPoint = new Point3D(0.0, 0.0, 0.0);
             Transform = new Transform3DGroup();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Cylinder.cs" startline="101" endline="107"><![CDATA[
 
         public Material Material
         {
             get
             {
                 return m_material;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Cylinder.cs" startline="108" endline="115"><![CDATA[
         }
 
         public new Transform3D Transform
         {
             get
             {
                 return base.Transform;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Cylinder.cs" startline="116" endline="121"><![CDATA[
 
             set
             {
                 //m_centerPoint = value.Transform(CenterPoint);
                 base.Transform = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Cylinder.cs" startline="122" endline="137"><![CDATA[
         }
 
         //public Point3D CenterPoint
         //{
         //    get
         //    {
         //        return m_centerPoint;
         //    }
         //}
         private Point3D m_centerPoint;
 
         public void MoveTo(Point3D newCenterPoint)
         {
 
             (Transform as Transform3DGroup).Children.Add( new TranslateTransform3D(Point3D.Subtract(newCenterPoint, m_centerPoint)));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="95" endline="138"><![CDATA[
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++;
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             // If there are valid moves, recurse on each.
             bool consideredLocalMoves = false;
             foreach (MinimaxMove move in validMoves)
             {
                 consideredLocalMoves = true;
 
                 MinimaxMove curMove = move;
                 curMove.Value = InternalSearch(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1).Value;
                 if (isLightPlayer)
                 {
                     if (curMove.Value > bestMove.Value) bestMove = curMove;
                     if (bestMove.Value >= beta) break;
                     alpha = Math.Max(alpha, bestMove.Value.Value);
                 }
                 else
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             {
                 m_movesConsidered++;
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             // If there are valid moves, recurse on each.
             bool consideredLocalMoves = false;
             foreach (MinimaxMove move in validMoves)
             {
                 consideredLocalMoves = true;
 
                 MinimaxMove curMove = move;
                 curMove.Value = InternalSearch(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1).Value;
                 if (isLightPlayer)
                 {
                     if (curMove.Value > bestMove.Value) bestMove = curMove;
                     if (bestMove.Value >= beta) break;
                     alpha = Math.Max(alpha, bestMove.Value.Value);
                 }
                 else
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             foreach (MinimaxMove move in validMoves)
             {
                 consideredLocalMoves = true;
 
                 MinimaxMove curMove = move;
                 curMove.Value = InternalSearch(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1).Value;
                 if (isLightPlayer)
                 {
                     if (curMove.Value > bestMove.Value) bestMove = curMove;
                     if (bestMove.Value >= beta) break;
                     alpha = Math.Max(alpha, bestMove.Value.Value);
                 }
                 else
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                 {
                     if (curMove.Value > bestMove.Value) bestMove = curMove;
                     if (bestMove.Value >= beta) break;
                     alpha = Math.Max(alpha, bestMove.Value.Value);
                 }
                 else
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     if (curMove.Value > bestMove.Value) bestMove = curMove;
                     if (bestMove.Value >= beta) break;
                     alpha = Math.Max(alpha, bestMove.Value.Value);
                 }
                 else
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     if (bestMove.Value >= beta) break;
                     alpha = Math.Max(alpha, bestMove.Value.Value);
                 }
                 else
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
             foreach (MinimaxMove move in validMoves)
             {
                 consideredLocalMoves = true;
 
                 MinimaxMove curMove = move;
                 curMove.Value = InternalSearch(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1).Value;
                 if (isLightPlayer)
                 {
                     if (curMove.Value > bestMove.Value) bestMove = curMove;
                     if (bestMove.Value >= beta) break;
                     alpha = Math.Max(alpha, bestMove.Value.Value);
                 }
                 else
                 {
                     if (curMove.Value < bestMove.Value) bestMove = curMove;
                     if (bestMove.Value <= alpha) break;
                     beta = Math.Min(beta, bestMove.Value.Value);
                 }
             }
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             {
                 bestMove.Value = InternalSearch(state, !isLightPlayer, alpha, beta, depth + 1).Value;
             }
 
             return bestMove;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="139" endline="259"><![CDATA[
 
         /// <summary>
         /// Should only be called through the public Search method.
         /// </summary>
         /// <param name="state">The game state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="alpha">The alpha pruning value.</param>
         /// <param name="beta">The beta pruning value.</param>
         /// <param name="depth">The current search depth.</param>
         /// <param name="token">The pruning token.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// The initial alpha value should be Int32.MinValue, the initial beta value 
         /// should be Int32.MaxValue, the initial depth value should be 0, and the 
         /// initial token should be a non-settable token.
         /// 
         /// The search will terminate ASAP if the m_ct cancellation token is signaled.
         /// 
         /// This method is thread-safe.
         /// </remarks>
         private MinimaxMove InternalSearchTPL(MinimaxSpot[,] state, bool isLightPlayer, int alpha, int beta, int depth, CancellationToken token)
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
         {
             // Stop the search if...
             if (TerminalTest(state) || depth >= m_maxDepth || m_ct.IsCancellationRequested)
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             {
                 m_movesConsidered++; // NOTE
                 return new MinimaxMove(EvaluateHeuristic(state));
             }
 
             // Initialize the best move for this recursive call.
             MinimaxMove bestMove = new MinimaxMove(isLightPlayer ? Int32.MinValue 
 
             // Get the valid moves for this recursive call.
             IEnumerable<MinimaxMove> validMoves = GetValidMoves(state, isLightPlayer);
 
             bool consideredLocalMoves = false;
             Queue<Task> workers = new Queue<Task>();
             object bigLock = new object();
             CancellationTokenSource cts = new CancellationTokenSource();
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
             foreach (MinimaxMove move in validMoves)
             {
                 // SHARED STATE
                 //     The local variables (bestMove, alpha, beta) are protected by a lock.
                 //     The non-local variables (m_taskCount) are modified using Interlocked
                 consideredLocalMoves = true;
 
                 // If the pruning token is signaled, stop this loop.
                 if (token.IsCancellationRequested)
                 {
                     cts.Cancel();
                     break;
                 }
 
                 MinimaxMove curMove = move;
                 if (m_taskCount < m_degOfParallelism && depth <= m_maxDepth - 1)
                 {
                     Interlocked.Increment(ref m_taskCount);
                     workers.Enqueue(Task.Factory.StartNew(() =>
                     {
                         curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
                         lock (bigLock)
                         {
                             if (isLightPlayer)
                             {
                                 if (curMove.Value > bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value >= beta) cts.Cancel();
                                 alpha = Math.Max(alpha, bestMove.Value.Value);
                             }
                             else
                             {
                                 if (curMove.Value < bestMove.Value) bestMove = curMove;
                                 if (bestMove.Value <= alpha) cts.Cancel();
                                 beta = Math.Min(beta, bestMove.Value.Value);
                             }
                         }
                         Interlocked.Decrement(ref m_taskCount);
                     }));
                 }
                 else
                 {
                     bool isPruning = false;
                     curMove.Value = InternalSearchTPL(GetInsight(state, curMove, isLightPlayer), !isLightPlayer, alpha, beta, depth + 1, cts.Token).Value;
 
                     // If there are no tasks, no need to lock.
                     bool lockTaken = false;
                     try
                     {
                         if (workers.Count > 0) Monitor.Enter(bigLock, ref lockTaken);
                         if (isLightPlayer)
                         {
                             if (curMove.Value > bestMove.Value) bestMove = curMove;
                             if (bestMove.Value >= beta) isPruning = true;
                             alpha = Math.Max(alpha, bestMove.Value.Value);
                         }
                         else
                         {
                             if (curMove.Value < bestMove.Value) bestMove = curMove;
                             if (bestMove.Value <= alpha) isPruning = true;
                             beta = Math.Min(beta, bestMove.Value.Value);
                         }
                     }
                     finally { if (lockTaken) Monitor.Exit(bigLock); }
 
                     if (isPruning)
                     {
                         cts.Cancel();
                         break;
                     }
                 }
             }
 
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             Task.WaitAll(workers.ToArray());
 
             // If there were no valid moves, still calculate the value.
             if (!consideredLocalMoves)
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             {
                 bestMove.Value = InternalSearchTPL(state, !isLightPlayer, alpha, beta, depth + 1, token).Value;
             }
 
             return bestMove;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="260" endline="310"><![CDATA[
 
         /// <summary>
         /// Returns the best move resulting from a Minimax, alpha-beta pruning search on the given state.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player to move.</param>
         /// <param name="inParallel">A boolean indicating whether to use the parallel algorithm.</param>
         /// <returns>A MinimaxMove that represents the best move found.</returns>
         /// <remarks>
         /// This method will only return a MinimaxMove(-1...) if there are no valid moves.
         /// </remarks>
         public MinimaxMove Search(MinimaxSpot[,] state, bool isLightPlayer, bool inParallel)
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
         {
             // Initialize a bunch of state.
             m_maxDepth = MaxDepth == -1 ? Int32.MaxValue 
             m_degOfParallelism = DegreeOfParallelism;
             m_timeLimit = TimeLimit;
             m_taskCount = 0;
             m_movesConsidered = 0;
             var curCts = m_cts = new CancellationTokenSource();
             m_ct = m_cts.Token;
 
             MinimaxMove aiMove = new MinimaxMove(-1, -1, null);
 
             // Start the timeout timer.  Done using a dedicated thread to minimize delay 
             // in cancellation due to lack of threads in the pool to run the callback.
             var timeoutTask = Task.Factory.StartNew(() =>
             {
                 Thread.Sleep(m_timeLimit);
                 curCts.Cancel();
             }, TaskCreationOptions.LongRunning);
 
             // Do the search
             aiMove = inParallel ?
                 InternalSearchTPL(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0, CancellationToken.None) 
                 InternalSearch(state, isLightPlayer, Int32.MinValue, Int32.MaxValue, 0);
 
             // Make sure that MinimaxMove(-1...) is only returned if there are no valid moves, because
             // InternalSearch* may return MinimaxMove(-1...) if none of the valid moves beats Int32.Min/Max.
             if (aiMove.Row == -1)
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             {
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 foreach (var move in GetValidMoves(state, isLightPlayer))
                 {
                     aiMove = move;
                     aiMove.Value = isLightPlayer ? Int32.MinValue 
                     break;
                 }
             }
 
             return aiMove;
         }
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
             }
 
             return aiMove;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="311" endline="319"><![CDATA[
 
         /// <summary>
         /// Cancel the ongoing operation, if there is one.
         /// </summary>
         public void Cancel()
         {
             if(m_cts!=null)
                 m_cts.Cancel();
         }
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
     }
 }
                 m_cts.Cancel();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="320" endline="326"><![CDATA[
 
         /// <summary>
         /// Returns the number of moves considered by the most recent Search.
         /// </summary>
         public int MovesConsidered
         {
             get { return m_movesConsidered; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="327" endline="361"><![CDATA[
         }
 
         private int m_maxDepth, m_degOfParallelism;
         private TimeSpan m_timeLimit;
         private int m_taskCount;
         private volatile int m_movesConsidered;
         private CancellationTokenSource m_cts;
         private CancellationToken m_ct;
     }
 
     /// <summary>
     /// An enum that represents the state of a board game spot.
     /// </summary>
     public enum MinimaxSpot
     {
         Empty = 0,
         Dark = -1,
         Light = 1
     }
 
     /// <summary>
     /// A struct that represents a board game move.  The value field
     /// should only be manipulated by Minimax.
     /// </summary>
     public struct MinimaxMove
     {
         public int Row, Col;
         public int? Value;
 
         public MinimaxMove(int row, int col)
         {
             Row = row;
             Col = col;
             Value = null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="362" endline="367"><![CDATA[
 
         public MinimaxMove(int? value)
         {
             Row = Col = -1;
             Value = value;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Minimax.cs" startline="368" endline="374"><![CDATA[
 
         public MinimaxMove(int row, int col, int? value)
         {
             Row = row;
             Col = col;
             Value = value;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="42" endline="92"><![CDATA[
         private readonly Color S_DARK_COLOR = Color.FromRgb(30, 30, 30);
         private readonly Color S_LIGHT_COLOR = Colors.White;
 
         private ReversiGame m_game;
         private MinimaxSpot[,] m_GUIboard;
         private Task m_aiUITask;
         private CancellationTokenSource m_aiUICts;
         private TaskScheduler m_UIScheduler;
         private bool m_isGameOver, m_isAIMoving, m_isAIParallel, m_isAuto;
         private Duration m_progBarDuration;
         private DoubleAnimation m_progBarAnim;
 
         private bool m_useAnimation;
 
         public Window1()
         {
             InitializeComponent();
             m_gamePieces = new Dictionary<Point, Cylinder>();
             m_ghostPieces = new Dictionary<Cylinder, Point>();
 
             // some animation/UI initialization
             NameScope.SetNameScope(mainViewport, new NameScope());
 
             ui_dopSlider.Minimum = 1.0;
             ui_dopSlider.Maximum = Environment.ProcessorCount * 2;
             ui_dopSlider.Value = Environment.ProcessorCount;
             ui_depthSlider.Minimum = 8.0;
             ui_depthSlider.Maximum = 24.0;
             ui_depthSlider.Value = 18.0;
             ui_timeoutSlider.Minimum = 1.0;
             ui_timeoutSlider.Maximum = 60.0;
             ui_timeoutSlider.Value = 8.0;
             m_useAnimation = true;
 
             // Set the UI scheduler
             m_UIScheduler = TaskScheduler.FromCurrentSynchronizationContext();
 
             // Initialize the game
             m_game = new ReversiGame(8, 8);
             m_isGameOver = false;
             m_isAIMoving = false;
             m_isAIParallel = true;
             m_isAuto = false;
 
             // Initialize the GUI's board
             m_GUIboard = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     m_GUIboard[i, j] = MinimaxSpot.Empty;
             UpdateBoard();
         }
 
         private void GoAI()
         {
             if (m_isGameOver)
                 return;
 
             m_isAIMoving = true;
 
             m_progBarAnim = new DoubleAnimation(0.0, 100.0, m_progBarDuration);
             if (m_isAIParallel)
             {
                 ui_parProgBar.Visibility = Visibility.Visible;
                 ui_parProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
             else
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 for (int j = 0; j < 8; j++)
                     m_GUIboard[i, j] = MinimaxSpot.Empty;
             UpdateBoard();
         }
 
         private void GoAI()
         {
             if (m_isGameOver)
                 return;
 
             m_isAIMoving = true;
 
             m_progBarAnim = new DoubleAnimation(0.0, 100.0, m_progBarDuration);
             if (m_isAIParallel)
             {
                 ui_parProgBar.Visibility = Visibility.Visible;
                 ui_parProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
             else
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                     m_GUIboard[i, j] = MinimaxSpot.Empty;
                 for (int j = 0; j < 8; j++)
                     m_GUIboard[i, j] = MinimaxSpot.Empty;
             UpdateBoard();
         }
 
         private void GoAI()
         {
             if (m_isGameOver)
                 return;
 
             m_isAIMoving = true;
 
             m_progBarAnim = new DoubleAnimation(0.0, 100.0, m_progBarDuration);
             if (m_isAIParallel)
             {
                 ui_parProgBar.Visibility = Visibility.Visible;
                 ui_parProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
             else
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     m_GUIboard[i, j] = MinimaxSpot.Empty;
             UpdateBoard();
         }
 
         private void GoAI()
         {
             if (m_isGameOver)
                 return;
 
             m_isAIMoving = true;
 
             m_progBarAnim = new DoubleAnimation(0.0, 100.0, m_progBarDuration);
             if (m_isAIParallel)
             {
                 ui_parProgBar.Visibility = Visibility.Visible;
                 ui_parProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
             else
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             UpdateBoard();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="93" endline="152"><![CDATA[
 
         private void GoAI()
         {
             if (m_isGameOver)
                 return;
 
             m_isAIMoving = true;
 
             m_progBarAnim = new DoubleAnimation(0.0, 100.0, m_progBarDuration);
             if (m_isAIParallel)
             {
                 ui_parProgBar.Visibility = Visibility.Visible;
                 ui_parProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
             else
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 return;
 
             m_isAIMoving = true;
 
             m_progBarAnim = new DoubleAnimation(0.0, 100.0, m_progBarDuration);
             if (m_isAIParallel)
             {
                 ui_parProgBar.Visibility = Visibility.Visible;
                 ui_parProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
             else
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 ui_parProgBar.Visibility = Visibility.Visible;
                 ui_parProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
             else
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 ui_seqProgBar.Visibility = Visibility.Visible;
                 ui_seqProgBar.BeginAnimation(ProgressBar.ValueProperty, m_progBarAnim, HandoffBehavior.SnapshotAndReplace);
             }
 
             m_aiUICts = new CancellationTokenSource();
             m_aiUITask = Task.Factory.StartNew(() =>
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="153" endline="212"><![CDATA[
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                     {
                         FlipPiece(i, j);
                     }
                 }
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             }
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="213" endline="232"><![CDATA[
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="233" endline="248"><![CDATA[
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="249" endline="292"><![CDATA[
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="293" endline="316"><![CDATA[
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="317" endline="324"><![CDATA[
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 FlipPieceUnanimated(row, col);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="325" endline="342"><![CDATA[
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="343" endline="409"><![CDATA[
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="410" endline="430"><![CDATA[
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="431" endline="443"><![CDATA[
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="444" endline="450"><![CDATA[
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="451" endline="492"><![CDATA[
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                     GoAI();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="493" endline="510"><![CDATA[
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="511" endline="551"><![CDATA[
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="552" endline="556"><![CDATA[
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="557" endline="563"><![CDATA[
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\obj\Debug\Window1.g.cs" startline="1" endline="1"><![CDATA[
 ?<Window x
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\obj\Debug\Window1.g.cs" startline="6" endline="139"><![CDATA[
     KeyDown="Window_KeyDown"
     Loaded="Window_Loaded" MinWidth="733" MinHeight="487">
             <Viewport3D x
         <Button Name="ui_startStopButton" Width="150" Click="ui_startStopButton_Click" FontWeight="Normal" VerticalAlignment="Top" Margin="10" Content="Start Sequential vs. Parallel"
                 <CheckBox Content="Animation"  Foreground="LightGreen"  Margin="10" Height="16" HorizontalAlignment="Left" Name="m_animationCheckBox" VerticalAlignment="Top" Width="120" Checked="Animation_Toggled" Unchecked="Animation_Toggled" IsChecked="True" />
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="120" endline="565"><![CDATA[
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Window1.xaml.cs" startline="115" endline="565"><![CDATA[
             {
                 return m_game.GetAIMove(m_isAIParallel);
 
             }, m_aiUICts.Token, TaskCreationOptions.None, TaskScheduler.Default)
             .ContinueWith(completedTask =>
             {
                 MinimaxMove aiMove = completedTask.Result;
                 if (aiMove.Row != -1)
                     m_game.MakeMove(aiMove.Row, aiMove.Col);
                 else
                     m_game.PassMove();
 
                 string s;
                 if (m_isAIParallel)
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_parLabel.Content = s;
                     ui_parProgBar.Visibility = Visibility.Hidden;
                 }
                 else
                 {
                     s = String.Format("{0
                     s = s.Substring(0, s.Length - 3);
                     ui_seqLabel.Content = s;
                     ui_seqProgBar.Visibility = Visibility.Hidden;
                 }
 
                 UpdateBoard();
                 m_isAIMoving = false;
 
                 if (m_isAuto)
                 {
                     m_isAIParallel = !m_isAIParallel;
                     GoAI();
                 }
             }, m_aiUICts.Token, TaskContinuationOptions.None, m_UIScheduler);
         }
 
         private bool UpdateBoard()
         {
             if (m_isGameOver)
                 return false;
 
             MinimaxSpot[,] game = m_game.Board;
             MinimaxSpot[,] gui = m_GUIboard;
 
             for (int i = 0; i < 8; i++)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (gui[i, j] == MinimaxSpot.Empty && game[i, j] != MinimaxSpot.Empty)
                     {
                         AddPiece(i, j, game[i, j] == MinimaxSpot.Light ? true 
                     }
                     else if ((gui[i, j] == MinimaxSpot.Light && game[i, j] == MinimaxSpot.Dark) ||
                         (gui[i, j] == MinimaxSpot.Dark && game[i, j] == MinimaxSpot.Light))
                     {
                         FlipPiece(i, j);
                     }
                 }
             }
 
             // Remove old ghost pieces.
             foreach (var c in m_ghostPieces)
             {
                 mainViewport.Children.Remove(c.Key);
             }
             m_ghostPieces.Clear();
 
             // Generate new ghost pieces.
             IEnumerable<MinimaxMove> moves = m_game.GetValidMoves();
             foreach (var m in moves)
             {
                 ShowGhost(m.Row, m.Col, m_game.IsLightMove);
             }
 
             ReversiGameResult gs = m_game.GetGameResult();
             if (gs.GameState == ReversiGameState.LightWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Light Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.DarkWon)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Dark Won! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             if (gs.GameState == ReversiGameState.Draw)
             {
                 m_isGameOver = true;
                 MessageBox.Show(String.Format("Draw! {0}-{1}", gs.NumLightPieces, gs.NumDarkPieces), "GAME OVER");
                 return false;
             }
             return true;
         }
 
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             var cameraPos = mainCamera.Position;
             if (e.Key == Key.Up)
                 cameraPos.Z += 1;
             if (e.Key == Key.Down)
                 cameraPos.Z -= 1;
             if (e.Key == Key.T)
                 mainCamera.FieldOfView += 10;
             if (e.Key == Key.G)
                 mainCamera.FieldOfView -= 10;
             if (e.Key == Key.D)
             {
                 m_game.Dump("");
                 MessageBox.Show("Dumped.");
             }
 
             mainCamera.Position = cameraPos;
         }
 
         #region IReversiView Members
 
         /// <summary>
         /// Collection of pieces on the board.
         /// </summary>
         private Dictionary<Point, Cylinder> m_gamePieces;
         private Dictionary<Cylinder, Point> m_ghostPieces;
 
         public void AddPiece(int row, int col, bool isPlayerLight)
         {
             if (m_useAnimation)
                 AddPieceAnimated(row, col, isPlayerLight);
             else
                 AddPieceUnanimated(row, col, isPlayerLight);
         }
 
         const int CYLINDER_RESOLUTION = 50;
 
         /// <summary>
         /// Places a piece on the gameboard by visually "dropping the piece."
         /// </summary>
         /// <param name="row">The row of the piece to place.</param>
         /// <param name="col">The column of the piece to place.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceAnimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             newPiece.MoveTo(new Point3D(centerX, centerY, 20.0));
             mainViewport.Children.Add(newPiece);
 
             // animate it's descent
             var animationStoryboard = new Storyboard();
 
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, 20.0);
             var moveDownAnimation = new DoubleAnimation(0, new Duration(TimeSpan.FromMilliseconds(500)));
             mainViewport.RegisterName("GamePieceDrop", translateTransform);
             Storyboard.SetTargetName(moveDownAnimation, "GamePieceDrop");
             Storyboard.SetTargetProperty(moveDownAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationStoryboard.Children.Add(moveDownAnimation);
             newPiece.Transform = translateTransform;
 
             animationStoryboard.Begin(mainViewport);
 
             mainViewport.UnregisterName("GamePieceDrop");
 
             m_gamePieces[new Point(row, col)] = newPiece;
         }
 
         /// <summary>
         /// Adds a piece to the game board without animation.  This method is called when the board is
         /// initialized.
         /// </summary>
         /// <param name="col">The column of the piece to add.</param>
         /// <param name="row">The row of the piece to add.</param>
         /// <param name="isBlack">If true, the piece color is black; otherwise, it's white.</param>
         public void AddPieceUnanimated(int row, int col, bool isPlayerLight)
         {
             // Update the GUI board
             m_GUIboard[row, col] = isPlayerLight ? MinimaxSpot.Light 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             MovePiece(newPiece, col, row);
             m_gamePieces[new Point(row, col)] = newPiece;
             mainViewport.Children.Add(newPiece);
         }
 
         public void FlipPiece( int row, int col )
         {
             if (m_useAnimation)
                 FlipPieceAnimated(row, col);
             else
                 FlipPieceUnanimated(row, col);
         }
 
         public void FlipPieceUnanimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             diffMaterialBrush.Color = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
         }
 
         /// <summary>
         /// "Flips" the game piece by lifting it, rotating it, and fading it's color from black to white, or vice versa.
         /// </summary>
         /// <param name="col">The column of the piece to flip.</param>
         /// <param name="row">The row of the piece to flip.</param>
         public void FlipPieceAnimated(int row, int col)
         {
             // Update the GUI board
             m_GUIboard[row, col] = m_GUIboard[row, col] == MinimaxSpot.Light ? MinimaxSpot.Dark 
 
             // Hack to match danny's orientation
             row = 7 - row;
 
             // get the piece's world coordinates
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             var gamePiece = m_gamePieces[new Point(row, col)];
 
             // define an animation storyboard and a transform group
             var animationsStoryboard = new Storyboard();
             var transformGroup = new Transform3DGroup();
 
             // setup the lift animation
             var translateTransform = new TranslateTransform3D(
                 centerX, centerY, S_CYLINDER_HEIGHT / 2.0);
             var moveUpAnimation = new DoubleAnimation(10, new Duration(TimeSpan.FromMilliseconds(500)));
             moveUpAnimation.AutoReverse = true;
             mainViewport.RegisterName("GamePieceMoveUp", translateTransform);
             Storyboard.SetTargetName(moveUpAnimation, "GamePieceMoveUp");
             Storyboard.SetTargetProperty(moveUpAnimation, new PropertyPath(TranslateTransform3D.OffsetZProperty));
             animationsStoryboard.Children.Add(moveUpAnimation);
 
 
             // setup the rotate animation
             var axisAngleRotation = new AxisAngleRotation3D(new Vector3D(0, 1, 0), 0);
             var rotateTransform = new RotateTransform3D(axisAngleRotation, new Point3D(-0, 0, S_CYLINDER_HEIGHT / 2.0));
             rotateTransform.Rotation = axisAngleRotation;
             var flipOverAnimation = new DoubleAnimation(0, 180, new Duration(TimeSpan.FromMilliseconds(1000)));
             mainViewport.RegisterName("GamePieceFlipOver", axisAngleRotation);
             Storyboard.SetTargetName(flipOverAnimation, "GamePieceFlipOver");
             Storyboard.SetTargetProperty(flipOverAnimation, new PropertyPath(AxisAngleRotation3D.AngleProperty));
             animationsStoryboard.Children.Add(flipOverAnimation);
 
             // setup the recolor animation
             // get the diffuse material
             var diffMaterialBrush = (gamePiece.Material as DiffuseMaterial).Brush as SolidColorBrush;
             var changeColorAnimation = new ColorAnimation();
             changeColorAnimation.To = diffMaterialBrush.Color.Equals(S_LIGHT_COLOR) ? S_DARK_COLOR 
             changeColorAnimation.Duration = TimeSpan.FromMilliseconds(1000);
             mainViewport.RegisterName("GamePieceChangeColor", diffMaterialBrush);
             Storyboard.SetTargetName(changeColorAnimation, "GamePieceChangeColor");
             Storyboard.SetTargetProperty(changeColorAnimation, new PropertyPath(SolidColorBrush.ColorProperty));
             animationsStoryboard.Children.Add(changeColorAnimation);
 
             // start the animation
             // note the transforms are applied in this specific order so that the piece ends up in the right location
             transformGroup.Children.Add(rotateTransform);
             transformGroup.Children.Add(translateTransform);
             gamePiece.Transform = transformGroup;
             animationsStoryboard.Begin(mainViewport);
 
             // unregister all animations so they can be performed again
             mainViewport.UnregisterName("GamePieceMoveUp");
             mainViewport.UnregisterName("GamePieceFlipOver");
             mainViewport.UnregisterName("GamePieceChangeColor");
         }
 
         public void ShowGhost(int row, int col, bool isPlayerLight)
         {
             // Hack to match danny's orientation
             row = 7 - row;
 
             // create the piece and place it above the destination square
             var newPiece = new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, isPlayerLight
                 ? new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))
                 
             double centerX, centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             // make the piece transparent
             var pieceColor = (newPiece.Material as DiffuseMaterial).Color;
             pieceColor.A = 70;
             (newPiece.Material as DiffuseMaterial).Color = pieceColor;
             newPiece.MoveTo(new Point3D(centerX, centerY, 0.0));
             mainViewport.Children.Add(newPiece);
 
             m_ghostPieces.Add(newPiece, new Point(col, row));
         }
 
         #endregion
 
         #region View Helper Functions
 
         // moves a cylinder piece to a place on the gameboard
         private void MovePiece(Cylinder piece, int col, int row)
         {
             double centerX;
             double centerY;
             GetViewCoordinates(col, row, out centerX, out centerY);
             piece.MoveTo(new Point3D(centerX, centerY, S_CYLINDER_HEIGHT / 2.0));
         }
 
         private static void GetViewCoordinates(int col, int row, out double centerX, out double centerY)
         {
             // width of cell * number of row/col - center point of first col/row
             centerY = -(row * 10.0 - 35.0);
             centerX = col * 10.0 - 35.0;
         }
         #endregion
 
         private void mainViewport_MouseUp(object sender, MouseButtonEventArgs e)
         {
             if (m_isGameOver)
             {
                 MessageBox.Show("Game is over.", "GAME OVER");
                 return;
             }
 
             if (m_isAIMoving)
             {
                 MessageBox.Show("AI is moving.  Wait for your opponent.", "INVALID");
                 return;
             }
 
             Point ghostPos;
             var res = GetGhostPiecePosition(e.GetPosition(mainViewport), out ghostPos);
             if (res)
             {
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 int row = 7 - (int)ghostPos.Y;
                 int col = (int)ghostPos.X;
                 if (m_game.MakeMove(row, col))
                 {
                     if (UpdateBoard())
                         GoAI();
                 }
                 else
                 {
                     MessageBox.Show("Can't move there. Shouldn't be seeing this message.", "ERROR");
                 }
             }
             else
             {
                 MessageBox.Show("You chose to pass.", "USER MOVE");
                 m_game.PassMove();
                 if (UpdateBoard())
                     GoAI();
             }
         }
 
         private bool GetGhostPiecePosition(Point mousePosition, out Point ghostPosition)
         {
             ghostPosition = new Point();
             var hitTestResult = VisualTreeHelper.HitTest(mainViewport, mousePosition);
             if (hitTestResult.VisualHit is Cylinder)
             {
                 var cylinder = hitTestResult.VisualHit as Cylinder;
                 if (!m_ghostPieces.ContainsKey(cylinder)) return false;
                 ghostPosition = m_ghostPieces[cylinder];
                 return true;
             }
             else
             {
 
                 return false;
             }
         }
 
 
         private void ui_startStopButton_Click(object sender, RoutedEventArgs e)
         {
             if (!m_isAuto)
             {
                 ui_dopSlider.IsEnabled = false;
                 ui_depthSlider.IsEnabled = false;
                 ui_timeoutSlider.IsEnabled = false;
 
                 ui_startStopButton.Content = "Stop Sequential vs. Parallel";
 
                 m_game.SetMinimaxKnobs((int)ui_depthSlider.Value, TimeSpan.FromSeconds((int)ui_timeoutSlider.Value), (int)ui_dopSlider.Value);
                 m_progBarDuration = new Duration(m_game.TimeLimit);
                 m_isAuto = true;
                 m_isAIParallel = false;
 
                 ui_seqPlayerLabel.Content = "Sequential Player";
                 GoAI();
             }
             else
             {
                 m_game.Cancel();
                 m_aiUICts.Cancel();
                 ui_seqProgBar.Visibility = Visibility.Hidden;
                 ui_parProgBar.Visibility = Visibility.Hidden;
 
                 ui_dopSlider.IsEnabled = true;
                 ui_depthSlider.IsEnabled = true;
                 ui_timeoutSlider.IsEnabled = true;
 
                 ui_startStopButton.Content = "Start Sequential vs. Parallel";
 
                 m_isAuto = false;
                 m_isAIMoving = false;
                 m_isAIParallel = true;
 
                 ui_seqPlayerLabel.Content = "You";
             }
             ui_settings.Focus(); // stop the button from blinking due to it having focus
         }
 
         private void Animation_Toggled(object sender, RoutedEventArgs e)
         {
             m_useAnimation = !m_useAnimation;
         }
 
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             // add piece icons to the player badges
             seqPlayerViewport.Children.Add( new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_DARK_COLOR))));
             parPlayerViewport.Children.Add(new Cylinder(S_CYLINDER_WIDTH, S_CYLINDER_HEIGHT, CYLINDER_RESOLUTION, new DiffuseMaterial(new SolidColorBrush(S_LIGHT_COLOR))));
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\obj\Debug\App.g.cs" startline="47" endline="4"><![CDATA[
         public void InitializeComponent() {
              StartupUri="Window1.xaml">
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\obj\Debug\App.g.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\obj\Debug\App.g.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Properties\Settings.Designer.cs" startline="25" endline="27"><![CDATA[
             {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\Properties\Settings.Designer.cs" startline="20" endline="30"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
 
         public static Settings Default
         {
             get
             {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="18" endline="33"><![CDATA[
         public ReversiGame(int numRows, int numCols)
         {
             m_numRows = numRows;
             m_numCols = numCols;
             m_board = new MinimaxSpot[numRows, numCols];
             for (int i = 0; i < numRows; i++)
                 for (int j = 0; j < numCols; j++)
                     m_board[i, j] = MinimaxSpot.Empty;
 
             m_board[3, 3] = MinimaxSpot.Light;
             m_board[4, 4] = MinimaxSpot.Light;
             m_board[4, 3] = MinimaxSpot.Dark;
             m_board[3, 4] = MinimaxSpot.Dark;
 
             m_isLightMove = false;
         }
 
         public void SetMinimaxKnobs(int maxDepth, TimeSpan timeLimit, int degOfParallelism)
         {
             m_depth = maxDepth;
             m_time = timeLimit;
             m_degPar = degOfParallelism;
         }
 
         /// <summary>
         /// Returns whether a move on the given row and column on the given state by the given player
         /// is valid.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player ot move.</param>
         /// <param name="row">The move row.</param>
         /// <param name="col">The move column.</param>
         /// <returns></returns>
         private bool IsValidMove(MinimaxSpot[,] state, bool isLightPlayer, int row, int col)
         {
             if (state[row, col] != MinimaxSpot.Empty)
                 return false;
 
             MinimaxSpot you = isLightPlayer ? MinimaxSpot.Light 
             MinimaxSpot enemy = isLightPlayer ? MinimaxSpot.Dark 
 
             // Check above.
             if (row + 1 < m_numRows && state[row + 1, col] == enemy)
             {
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 for (int j = 0; j < numCols; j++)
                     m_board[i, j] = MinimaxSpot.Empty;
 
             m_board[3, 3] = MinimaxSpot.Light;
             m_board[4, 4] = MinimaxSpot.Light;
             m_board[4, 3] = MinimaxSpot.Dark;
             m_board[3, 4] = MinimaxSpot.Dark;
 
             m_isLightMove = false;
         }
 
         public void SetMinimaxKnobs(int maxDepth, TimeSpan timeLimit, int degOfParallelism)
         {
             m_depth = maxDepth;
             m_time = timeLimit;
             m_degPar = degOfParallelism;
         }
 
         /// <summary>
         /// Returns whether a move on the given row and column on the given state by the given player
         /// is valid.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player ot move.</param>
         /// <param name="row">The move row.</param>
         /// <param name="col">The move column.</param>
         /// <returns></returns>
         private bool IsValidMove(MinimaxSpot[,] state, bool isLightPlayer, int row, int col)
         {
             if (state[row, col] != MinimaxSpot.Empty)
                 return false;
 
             MinimaxSpot you = isLightPlayer ? MinimaxSpot.Light 
             MinimaxSpot enemy = isLightPlayer ? MinimaxSpot.Dark 
 
             // Check above.
             if (row + 1 < m_numRows && state[row + 1, col] == enemy)
             {
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     m_board[i, j] = MinimaxSpot.Empty;
                 for (int j = 0; j < numCols; j++)
                     m_board[i, j] = MinimaxSpot.Empty;
 
             m_board[3, 3] = MinimaxSpot.Light;
             m_board[4, 4] = MinimaxSpot.Light;
             m_board[4, 3] = MinimaxSpot.Dark;
             m_board[3, 4] = MinimaxSpot.Dark;
 
             m_isLightMove = false;
         }
 
         public void SetMinimaxKnobs(int maxDepth, TimeSpan timeLimit, int degOfParallelism)
         {
             m_depth = maxDepth;
             m_time = timeLimit;
             m_degPar = degOfParallelism;
         }
 
         /// <summary>
         /// Returns whether a move on the given row and column on the given state by the given player
         /// is valid.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player ot move.</param>
         /// <param name="row">The move row.</param>
         /// <param name="col">The move column.</param>
         /// <returns></returns>
         private bool IsValidMove(MinimaxSpot[,] state, bool isLightPlayer, int row, int col)
         {
             if (state[row, col] != MinimaxSpot.Empty)
                 return false;
 
             MinimaxSpot you = isLightPlayer ? MinimaxSpot.Light 
             MinimaxSpot enemy = isLightPlayer ? MinimaxSpot.Dark 
 
             // Check above.
             if (row + 1 < m_numRows && state[row + 1, col] == enemy)
             {
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             for (int i = 0; i < numRows; i++)
                 for (int j = 0; j < numCols; j++)
                     m_board[i, j] = MinimaxSpot.Empty;
 
             m_board[3, 3] = MinimaxSpot.Light;
             m_board[4, 4] = MinimaxSpot.Light;
             m_board[4, 3] = MinimaxSpot.Dark;
             m_board[3, 4] = MinimaxSpot.Dark;
 
             m_isLightMove = false;
         }
 
         public void SetMinimaxKnobs(int maxDepth, TimeSpan timeLimit, int degOfParallelism)
         {
             m_depth = maxDepth;
             m_time = timeLimit;
             m_degPar = degOfParallelism;
         }
 
         /// <summary>
         /// Returns whether a move on the given row and column on the given state by the given player
         /// is valid.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player ot move.</param>
         /// <param name="row">The move row.</param>
         /// <param name="col">The move column.</param>
         /// <returns></returns>
         private bool IsValidMove(MinimaxSpot[,] state, bool isLightPlayer, int row, int col)
         {
             if (state[row, col] != MinimaxSpot.Empty)
                 return false;
 
             MinimaxSpot you = isLightPlayer ? MinimaxSpot.Light 
             MinimaxSpot enemy = isLightPlayer ? MinimaxSpot.Dark 
 
             // Check above.
             if (row + 1 < m_numRows && state[row + 1, col] == enemy)
             {
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             m_board[3, 3] = MinimaxSpot.Light;
             m_board[4, 4] = MinimaxSpot.Light;
             m_board[4, 3] = MinimaxSpot.Dark;
             m_board[3, 4] = MinimaxSpot.Dark;
 
             m_isLightMove = false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="34" endline="40"><![CDATA[
 
         public void SetMinimaxKnobs(int maxDepth, TimeSpan timeLimit, int degOfParallelism)
         {
             m_depth = maxDepth;
             m_time = timeLimit;
             m_degPar = degOfParallelism;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="41" endline="156"><![CDATA[
 
         /// <summary>
         /// Returns whether a move on the given row and column on the given state by the given player
         /// is valid.
         /// </summary>
         /// <param name="state">The state to consider.</param>
         /// <param name="isLightPlayer">The player ot move.</param>
         /// <param name="row">The move row.</param>
         /// <param name="col">The move column.</param>
         /// <returns></returns>
         private bool IsValidMove(MinimaxSpot[,] state, bool isLightPlayer, int row, int col)
         {
             if (state[row, col] != MinimaxSpot.Empty)
                 return false;
 
             MinimaxSpot you = isLightPlayer ? MinimaxSpot.Light 
             MinimaxSpot enemy = isLightPlayer ? MinimaxSpot.Dark 
 
             // Check above.
             if (row + 1 < m_numRows && state[row + 1, col] == enemy)
             {
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 return false;
 
             MinimaxSpot you = isLightPlayer ? MinimaxSpot.Light 
             MinimaxSpot enemy = isLightPlayer ? MinimaxSpot.Dark 
 
             // Check above.
             if (row + 1 < m_numRows && state[row + 1, col] == enemy)
             {
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             // Check below.
             if (row - 1 >= 0 && state[row - 1, col] == enemy)
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (state[r, col] == you)
                         return true;
                     if (state[r, col] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             // Check right.
             if (col + 1 < m_numCols && state[row, col + 1] == enemy)
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             // Check left.
             if (col - 1 >= 0 && state[row, col - 1] == enemy)
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (state[row, c] == you)
                         return true;
                     if (state[row, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             // Check above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && state[row + 1, col + 1] == enemy)
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             // Check above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && state[row + 1, col - 1] == enemy)
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             // Check below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && state[row - 1, col + 1] == enemy)
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             // Check below-left
             if (row - 1 >= 0 && col - 1 >= 0 && state[row - 1, col - 1] == enemy)
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                 }
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (state[r, c] == you)
                         return true;
                     if (state[r, c] == MinimaxSpot.Empty)
                         break;
                 }
             }
 
             return false;
         }
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
 
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="157" endline="166"><![CDATA[
 
         /// <summary>
         /// Returns the valid moves for the state maintained by this ReversiGame
         /// (delegates to another overload).
         /// </summary>
         /// <returns>The valid moves.</returns>
         public IEnumerable<MinimaxMove> GetValidMoves()
         {
             return GetValidMoves(m_board, m_isLightMove);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="167" endline="338"><![CDATA[
 
         /// <summary>
         /// Makes a move on the given row and column.
         /// </summary>
         /// <param name="row">The move row</param>
         /// <param name="col">The move column</param>
         /// <returns>Whether or not the operation succeeded.</returns>
         public bool MakeMove(int row, int col)
         {
             if (!IsValidMove(m_board, m_isLightMove, row, col))
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 return false;
             }
 
             MinimaxSpot you = m_isLightMove ? MinimaxSpot.Light 
             MinimaxSpot enemy = m_isLightMove ? MinimaxSpot.Dark 
 
             var backup = new MinimaxSpot[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     backup[i, j] = m_board[i, j];
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                     backup[i, j] = m_board[i, j];
 
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             m_board[row, col] = you;
 
             // Conquer above.
             if (row + 1 < m_numRows && m_board[row + 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int r = row + 2; r < m_numRows; r++)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, col] = you;
                     for (int r = row + 1; m_board[r, col] != you; r++)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             // Conquer below.
             if (row - 1 >= 0 && m_board[row - 1, col] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int r = row - 2; r >= 0; r--)
                 {
                     if (m_board[r, col] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, col] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, col] = you;
                     for (int r = row - 1; m_board[r, col] != you; r--)
                         m_board[r, col] = you;
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             // Conquer right.
             if (col + 1 < m_numCols && m_board[row, col + 1] == enemy)
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int c = col + 2; c < m_numCols; c++)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[row, c] = you;
                     for (int c = col + 1; m_board[row, c] != you; c++)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             // Conquer left.
             if (col - 1 >= 0 && m_board[row, col - 1] == enemy)
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int c = col - 2; c >= 0; c--)
                 {
                     if (m_board[row, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[row, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[row, c] = you;
                     for (int c = col - 1; m_board[row, c] != you; c--)
                         m_board[row, c] = you;
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             // Conquer above-right
             if (row + 1 < m_numRows && col + 1 < m_numCols && m_board[row + 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int r = row + 2, c = col + 2; r < m_numRows && c < m_numCols; r++, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, c] = you;
                     for (int r = row + 1, c = col + 1; m_board[r, c] != you; r++, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             // Conquer above-left
             if (row + 1 < m_numRows && col - 1 >= 0 && m_board[row + 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int r = row + 2, c = col - 2; r < m_numRows && c >= 0; r++, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, c] = you;
                     for (int r = row + 1, c = col - 1; m_board[r, c] != you; r++, c--)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             // Conquer below-right
             if (row - 1 >= 0 && col + 1 < m_numCols && m_board[row - 1, col + 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int r = row - 2, c = col + 2; r >= 0 && c < m_numCols; r--, c++)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, c] = you;
                     for (int r = row - 1, c = col + 1; m_board[r, c] != you; r--, c++)
                         m_board[r, c] = you;
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             // Conquer below-left
             if (row - 1 >= 0 && col - 1 >= 0 && m_board[row - 1, col - 1] == enemy)
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 bool b = false;
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         b = true;
                 }
                 for (int r = row - 2, c = col - 2; r >= 0 && c >= 0; r--, c--)
                 {
                     if (m_board[r, c] == MinimaxSpot.Empty)
                         break;
                     if (m_board[r, c] == you)
                         b = true;
                 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 if (b)
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, c] = you;
                     for (int r = row - 1, c = col - 1; m_board[r, c] != you; r--, c--)
                         m_board[r, c] = you;
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 }
             }
 
             m_isLightMove = !m_isLightMove;
 
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="339" endline="346"><![CDATA[
 
         /// <summary>
         /// Passes on the current player's move.
         /// </summary>
         public void PassMove()
         {
             m_isLightMove = !m_isLightMove;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="347" endline="380"><![CDATA[
 
         /// <summary>
         /// Returns the game result.
         /// </summary>
         /// <returns>The game result</returns>
         public ReversiGameResult GetGameResult()
         {
             ReversiGameResult gr = new ReversiGameResult();
 
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         gr.NumDarkPieces++;
                 }
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         gr.NumLightPieces++;
                     if (m_board[i, j] == MinimaxSpot.Dark)
                         gr.NumDarkPieces++;
                 }
             }
 
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             if (TerminalTest(m_board))
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 if (gr.NumLightPieces > gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     gr.GameState = ReversiGameState.LightWon;
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 else if (gr.NumLightPieces < gr.NumDarkPieces)
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     gr.GameState = ReversiGameState.DarkWon;
                 else
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     gr.GameState = ReversiGameState.Draw;
             }
             else
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 gr.GameState = ReversiGameState.Ongoing;
 
             return gr;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="381" endline="385"><![CDATA[
 
         public MinimaxMove GetAIMove(bool inParallel)
         {
             return Search(m_board, m_isLightMove, inParallel);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="386" endline="390"><![CDATA[
 
         #region Minimax_routines
         public override int MaxDepth
         {
             get { return m_depth; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="391" endline="395"><![CDATA[
         }
 
         public override TimeSpan TimeLimit
         {
             get { return m_time; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="396" endline="400"><![CDATA[
         }
 
         public override int DegreeOfParallelism
         {
             get { return m_degPar; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="401" endline="410"><![CDATA[
         }
 
         protected override bool TerminalTest(MinimaxSpot[,] state)
         {
             int n = GetValidMoves(state, true).Count();
             // Can either player move?
             if (GetValidMoves(state, true).Count() == 0 && GetValidMoves(state, false).Count() == 0)
                 return true;
             return false;
         }
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 return true;
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="411" endline="473"><![CDATA[
 
         protected override int EvaluateHeuristic(MinimaxSpot[,] state)
         {
             int boardValue = 0;
 
             // +1 for light pieces, -1 for dark pieces
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         boardValue--;
                 }
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             }
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (state[i, j] == MinimaxSpot.Light)
                         boardValue++;
                     if (state[i, j] == MinimaxSpot.Dark)
                         boardValue--;
                 }
             }
 
             // +-X for corner pieces
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             int cornerPieceValue = 13;
             if (state[0, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue += cornerPieceValue;
             if (state[0, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue -= cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue += cornerPieceValue;
             if (state[0, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue -= cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue += cornerPieceValue;
             if (state[7, 0] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue -= cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Light)
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue += cornerPieceValue;
             if (state[7, 7] == MinimaxSpot.Dark)
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 boardValue -= cornerPieceValue;
 
             // +-X for edge pieces
             int edgePieceValue = 9;
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numRows; i++)
             {
                 if (state[i, 0] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[i, m_numCols - 1] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     boardValue -= edgePieceValue;
             }
             for (int i = 0; i < m_numCols; i++)
             {
                 if (state[0, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[0, 0] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Light)
                     boardValue += edgePieceValue;
                 if (state[m_numRows - 1, i] == MinimaxSpot.Dark)
                     boardValue -= edgePieceValue;
             }
 
             return boardValue;
         }
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             return boardValue;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="474" endline="495"><![CDATA[
 
         protected override IEnumerable<MinimaxMove> GetValidMoves(MinimaxSpot[,] state, bool isLightPlayer)
         {
             for (int i = 0; i < m_numRows; i++)
             {
                 for (int j = 0; j < m_numCols; j++)
                 {
                     if (IsValidMove(state, isLightPlayer, i, j))
                         yield return new MinimaxMove(i, j);
                 }
             }
         }
 
         protected override MinimaxSpot[,] GetInsight(MinimaxSpot[,] state, MinimaxMove move, bool isLightPlayer)
         {
             MinimaxSpot[,] insightState = new MinimaxSpot[m_numRows, m_numCols];
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     insightState[i, j] = state[i, j];
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             for (int i = 0; i < m_numRows; i++)
                 for (int j = 0; j < m_numCols; j++)
                     insightState[i, j] = state[i, j];
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             insightState[move.Row, move.Col] = isLightPlayer ? MinimaxSpot.Light 
             return insightState;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="496" endline="519"><![CDATA[
         #endregion
 
         #region DEBUG_ROUTINES
         private void ReadDump()
         {
             var sr = new StreamReader("./dump.txt");
 
             string s = sr.ReadLine();
             int r = 7;
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 r--;
                 s = sr.ReadLine();
             }
             while (s != null)
             {
                 char[] line = s.ToCharArray();
                 for (int c = 0; c < 8; c++)
                 {
                     if (line[c] == 'w')
                         m_board[r, c] = MinimaxSpot.Light;
                     if (line[c] == 'b')
                         m_board[r, c] = MinimaxSpot.Dark;
                 }
                 r--;
                 s = sr.ReadLine();
             }
             sr.Close();
         }
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             sr.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="520" endline="539"><![CDATA[
 
         public void Dump(string msg)
         {
             var sw = new StreamWriter("./dump.txt");
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                         sw.Write('-');
                 }
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
                 sw.WriteLine();
             }
             for (int i = 7; i >= 0; i--)
             {
                 for (int j = 0; j < 8; j++)
                 {
                     if (m_board[i, j] == MinimaxSpot.Light)
                         sw.Write('w');
                     else if (m_board[i, j] == MinimaxSpot.Dark)
                         sw.Write('b');
                     else
                         sw.Write('-');
                 }
                 sw.WriteLine();
             }
             sw.WriteLine(msg);
             sw.Close();
         }
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
         }
     }
 
     public struct ReversiGameResult
     {
         public ReversiGameState GameState;
         public int NumLightPieces, NumDarkPieces;
     }
 
     public enum ReversiGameState
     {
         Ongoing = 42,
         LightWon = 1,
         DarkWon = -1,
         Draw = 0
     }
 }
             sw.WriteLine(msg);
             sw.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="540" endline="550"><![CDATA[
         #endregion
 
         private int m_numRows, m_numCols;
         private MinimaxSpot[,] m_board;
         private int m_depth, m_degPar;
         private TimeSpan m_time;
         private bool m_isLightMove;
 
         public MinimaxSpot[,] Board
         {
             get { return m_board; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Reversi\Reversi\ReversiGame.cs" startline="551" endline="555"><![CDATA[
         }
 
         public bool IsLightMove
         {
             get { return m_isLightMove; }
]]></source>
</source_elements></project>
