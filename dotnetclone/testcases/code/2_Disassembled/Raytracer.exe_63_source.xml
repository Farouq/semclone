<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Ray.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Ray.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\SceneObject.cs" startline="17" endline="17"><![CDATA[
         public SceneObject(Surface surface) { Surface = surface; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Plane.cs" startline="16" endline="16"><![CDATA[
         public Plane(Vector norm, double offset, Surface surface) 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Plane.cs" startline="17" endline="23"><![CDATA[
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return ISect.Null;
             return new ISect(this, ray, (Vector.Dot(Norm, ray.Start) + Offset) / (-denom));
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 }
             if (denom > 0) return ISect.Null;
             return new ISect(this, ray, (Vector.Dot(Norm, ray.Start) + Offset) / (-denom));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Plane.cs" startline="24" endline="28"><![CDATA[
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\ISect.cs" startline="18" endline="18"><![CDATA[
         public ISect(SceneObject thing, Ray ray, double dist) { Thing = thing; Ray = ray; Dist = dist; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\ISect.cs" startline="19" endline="20"><![CDATA[
 
         public static bool IsNull(ISect sect) { return sect == null; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\ISect.cs" startline="21" endline="23"><![CDATA[
         public readonly static ISect Null = null;
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="27" endline="23"><![CDATA[
         private int _degreeOfParallelism = Environment.ProcessorCount;
         private System.ComponentModel.IContainer components = null;
         public MainForm() { InitializeComponent(); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="24" endline="65"><![CDATA[
 
         private bool _showThreads;
         private bool _parallel;
         private int _degreeOfParallelism = Environment.ProcessorCount;
         private CancellationTokenSource _cancellation;
 
         private int _width, _height;
         private Bitmap _bitmap;
         private Rectangle _rect;
         private ObjectPool<int[]> _freeBuffers;
 
         private void btnStartStop_Click(object sender, EventArgs e)
         {
             // If we already have the rendering task created, then we're currently running.
             // In that case, stop the renderer.
             if (_cancellation != null)
             {
                 btnStartStop.Enabled = false;
                 _cancellation.Cancel();
             }
             else
             {
                 // Set up the image in the picture box and start the rendering loop with a new rendering task
                 ConfigureImage();
                 _showThreads = chkShowThreads.Checked;
                 _cancellation = new CancellationTokenSource();
                 Task.Factory.StartNew(RenderLoop, 
                     _cancellation.Token, _cancellation.Token).
                     ContinueWith(delegate
                 {
                     chkParallel.Enabled = true;
                     chkShowThreads.Enabled = chkParallel.Checked;
                     btnStartStop.Enabled = true;
                     btnStartStop.Text = "Start";
                     _cancellation = null;
                 }, TaskScheduler.FromCurrentSynchronizationContext());
                 
                 chkShowThreads.Enabled = false;
                 chkParallel.Enabled = false;
                 btnStartStop.Text = "Stop";
             }
         }
 
         private void ConfigureImage()
         {
             // If we need to create a new bitmap, do so
             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
             {
                 // Dispose of the old one if one exists
                 if (_bitmap != null)
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
         {
             // If we already have the rendering task created, then we're currently running.
             // In that case, stop the renderer.
             if (_cancellation != null)
             {
                 btnStartStop.Enabled = false;
                 _cancellation.Cancel();
             }
             else
             {
                 // Set up the image in the picture box and start the rendering loop with a new rendering task
                 ConfigureImage();
                 _showThreads = chkShowThreads.Checked;
                 _cancellation = new CancellationTokenSource();
                 Task.Factory.StartNew(RenderLoop, 
                     _cancellation.Token, _cancellation.Token).
                     ContinueWith(delegate
                 {
                     chkParallel.Enabled = true;
                     chkShowThreads.Enabled = chkParallel.Checked;
                     btnStartStop.Enabled = true;
                     btnStartStop.Text = "Start";
                     _cancellation = null;
                 }, TaskScheduler.FromCurrentSynchronizationContext());
                 
                 chkShowThreads.Enabled = false;
                 chkParallel.Enabled = false;
                 btnStartStop.Text = "Stop";
             }
         }
 
         private void ConfigureImage()
         {
             // If we need to create a new bitmap, do so
             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
             {
                 // Dispose of the old one if one exists
                 if (_bitmap != null)
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
             {
                 btnStartStop.Enabled = false;
                 _cancellation.Cancel();
             }
             else
             {
                 // Set up the image in the picture box and start the rendering loop with a new rendering task
                 ConfigureImage();
                 _showThreads = chkShowThreads.Checked;
                 _cancellation = new CancellationTokenSource();
                 Task.Factory.StartNew(RenderLoop, 
                     _cancellation.Token, _cancellation.Token).
                     ContinueWith(delegate
                 {
                     chkParallel.Enabled = true;
                     chkShowThreads.Enabled = chkParallel.Checked;
                     btnStartStop.Enabled = true;
                     btnStartStop.Text = "Start";
                     _cancellation = null;
                 }, TaskScheduler.FromCurrentSynchronizationContext());
                 
                 chkShowThreads.Enabled = false;
                 chkParallel.Enabled = false;
                 btnStartStop.Text = "Stop";
             }
         }
 
         private void ConfigureImage()
         {
             // If we need to create a new bitmap, do so
             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
             {
                 // Dispose of the old one if one exists
                 if (_bitmap != null)
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
             {
                 // Set up the image in the picture box and start the rendering loop with a new rendering task
                 ConfigureImage();
                 _showThreads = chkShowThreads.Checked;
                 _cancellation = new CancellationTokenSource();
                 Task.Factory.StartNew(RenderLoop, 
                     _cancellation.Token, _cancellation.Token).
                     ContinueWith(delegate
                 {
                     chkParallel.Enabled = true;
                     chkShowThreads.Enabled = chkParallel.Checked;
                     btnStartStop.Enabled = true;
                     btnStartStop.Text = "Start";
                     _cancellation = null;
                 }, TaskScheduler.FromCurrentSynchronizationContext());
                 
                 chkShowThreads.Enabled = false;
                 chkParallel.Enabled = false;
                 btnStartStop.Text = "Stop";
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="66" endline="90"><![CDATA[
 
         private void ConfigureImage()
         {
             // If we need to create a new bitmap, do so
             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
             {
                 // Dispose of the old one if one exists
                 if (_bitmap != null)
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
         {
             // If we need to create a new bitmap, do so
             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
             {
                 // Dispose of the old one if one exists
                 if (_bitmap != null)
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
             {
                 // Dispose of the old one if one exists
                 if (_bitmap != null)
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="91" endline="142"><![CDATA[
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="143" endline="151"><![CDATA[
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="152" endline="157"><![CDATA[
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="158" endline="165"><![CDATA[
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.Designer.cs" startline="15" endline="21"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.chkParallel = new System.Windows.Forms.CheckBox();
             this.btnStartStop = new System.Windows.Forms.Button();
             this.pbRenderedImage = new System.Windows.Forms.PictureBox();
             this.chkShowThreads = new System.Windows.Forms.CheckBox();
             this.tbNumProcs = new System.Windows.Forms.TrackBar();
             this.lblNumProcs = new System.Windows.Forms.Label();
             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).BeginInit();
             this.SuspendLayout();
             // 
             // chkParallel
             // 
             this.chkParallel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.chkParallel.AutoSize = true;
             this.chkParallel.Location = new System.Drawing.Point(108, 426);
             this.chkParallel.Name = "chkParallel";
             this.chkParallel.Size = new System.Drawing.Size(60, 17);
             this.chkParallel.TabIndex = 20;
             this.chkParallel.Text = "Parallel";
             this.chkParallel.UseVisualStyleBackColor = true;
             this.chkParallel.CheckedChanged += new System.EventHandler(this.chkParallel_CheckedChanged);
             // 
             // btnStartStop
             // 
             this.btnStartStop.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.btnStartStop.Location = new System.Drawing.Point(13, 421);
             this.btnStartStop.Name = "btnStartStop";
             this.btnStartStop.Size = new System.Drawing.Size(88, 23);
             this.btnStartStop.TabIndex = 19;
             this.btnStartStop.Text = "Start";
             this.btnStartStop.UseVisualStyleBackColor = true;
             this.btnStartStop.Click += new System.EventHandler(this.btnStartStop_Click);
             // 
             // pbRenderedImage
             // 
             this.pbRenderedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbRenderedImage.BackColor = System.Drawing.Color.Black;
             this.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None;
             this.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
             this.pbRenderedImage.Location = new System.Drawing.Point(13, 15);
             this.pbRenderedImage.Name = "pbRenderedImage";
             this.pbRenderedImage.Size = new System.Drawing.Size(469, 400);
             this.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
             this.pbRenderedImage.TabIndex = 18;
             this.pbRenderedImage.TabStop = false;
             // 
             // chkShowThreads
             // 
             this.chkShowThreads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.chkShowThreads.AutoSize = true;
             this.chkShowThreads.Enabled = false;
             this.chkShowThreads.Location = new System.Drawing.Point(174, 426);
             this.chkShowThreads.Name = "chkShowThreads";
             this.chkShowThreads.Size = new System.Drawing.Size(95, 17);
             this.chkShowThreads.TabIndex = 21;
             this.chkShowThreads.Text = "Show Threads";
             this.chkShowThreads.UseVisualStyleBackColor = true;
             // 
             // tbNumProcs
             // 
             this.tbNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.tbNumProcs.Enabled = false;
             this.tbNumProcs.Location = new System.Drawing.Point(304, 421);
             this.tbNumProcs.Maximum = 24;
             this.tbNumProcs.Minimum = 1;
             this.tbNumProcs.Name = "tbNumProcs";
             this.tbNumProcs.Size = new System.Drawing.Size(178, 45);
             this.tbNumProcs.TabIndex = 22;
             this.tbNumProcs.Value = 1;
             this.tbNumProcs.ValueChanged += new System.EventHandler(this.tbNumProcs_ValueChanged);
             // 
             // lblNumProcs
             // 
             this.lblNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.lblNumProcs.AutoSize = true;
             this.lblNumProcs.Enabled = false;
             this.lblNumProcs.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.lblNumProcs.Location = new System.Drawing.Point(295, 431);
             this.lblNumProcs.Name = "lblNumProcs";
             this.lblNumProcs.Size = new System.Drawing.Size(14, 13);
             this.lblNumProcs.TabIndex = 23;
             this.lblNumProcs.Text = "1";
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(495, 459);
             this.Controls.Add(this.lblNumProcs);
             this.Controls.Add(this.tbNumProcs);
             this.Controls.Add(this.chkShowThreads);
             this.Controls.Add(this.chkParallel);
             this.Controls.Add(this.btnStartStop);
             this.Controls.Add(this.pbRenderedImage);
             this.Name = "MainForm";
             this.Text = "Ray Tracer";
             this.Load += new System.EventHandler(this.MainForm_Load);
             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
 
         #endregion
 
         internal System.Windows.Forms.CheckBox chkParallel;
         private System.Windows.Forms.Button btnStartStop;
         private System.Windows.Forms.PictureBox pbRenderedImage;
         internal System.Windows.Forms.CheckBox chkShowThreads;
         private System.Windows.Forms.TrackBar tbNumProcs;
         private System.Windows.Forms.Label lblNumProcs;
     }
 }
 
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.Designer.cs" startline="22" endline="135"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.chkParallel = new System.Windows.Forms.CheckBox();
             this.btnStartStop = new System.Windows.Forms.Button();
             this.pbRenderedImage = new System.Windows.Forms.PictureBox();
             this.chkShowThreads = new System.Windows.Forms.CheckBox();
             this.tbNumProcs = new System.Windows.Forms.TrackBar();
             this.lblNumProcs = new System.Windows.Forms.Label();
             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).BeginInit();
             this.SuspendLayout();
             // 
             // chkParallel
             // 
             this.chkParallel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.chkParallel.AutoSize = true;
             this.chkParallel.Location = new System.Drawing.Point(108, 426);
             this.chkParallel.Name = "chkParallel";
             this.chkParallel.Size = new System.Drawing.Size(60, 17);
             this.chkParallel.TabIndex = 20;
             this.chkParallel.Text = "Parallel";
             this.chkParallel.UseVisualStyleBackColor = true;
             this.chkParallel.CheckedChanged += new System.EventHandler(this.chkParallel_CheckedChanged);
             // 
             // btnStartStop
             // 
             this.btnStartStop.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.btnStartStop.Location = new System.Drawing.Point(13, 421);
             this.btnStartStop.Name = "btnStartStop";
             this.btnStartStop.Size = new System.Drawing.Size(88, 23);
             this.btnStartStop.TabIndex = 19;
             this.btnStartStop.Text = "Start";
             this.btnStartStop.UseVisualStyleBackColor = true;
             this.btnStartStop.Click += new System.EventHandler(this.btnStartStop_Click);
             // 
             // pbRenderedImage
             // 
             this.pbRenderedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbRenderedImage.BackColor = System.Drawing.Color.Black;
             this.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None;
             this.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
             this.pbRenderedImage.Location = new System.Drawing.Point(13, 15);
             this.pbRenderedImage.Name = "pbRenderedImage";
             this.pbRenderedImage.Size = new System.Drawing.Size(469, 400);
             this.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
             this.pbRenderedImage.TabIndex = 18;
             this.pbRenderedImage.TabStop = false;
             // 
             // chkShowThreads
             // 
             this.chkShowThreads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.chkShowThreads.AutoSize = true;
             this.chkShowThreads.Enabled = false;
             this.chkShowThreads.Location = new System.Drawing.Point(174, 426);
             this.chkShowThreads.Name = "chkShowThreads";
             this.chkShowThreads.Size = new System.Drawing.Size(95, 17);
             this.chkShowThreads.TabIndex = 21;
             this.chkShowThreads.Text = "Show Threads";
             this.chkShowThreads.UseVisualStyleBackColor = true;
             // 
             // tbNumProcs
             // 
             this.tbNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.tbNumProcs.Enabled = false;
             this.tbNumProcs.Location = new System.Drawing.Point(304, 421);
             this.tbNumProcs.Maximum = 24;
             this.tbNumProcs.Minimum = 1;
             this.tbNumProcs.Name = "tbNumProcs";
             this.tbNumProcs.Size = new System.Drawing.Size(178, 45);
             this.tbNumProcs.TabIndex = 22;
             this.tbNumProcs.Value = 1;
             this.tbNumProcs.ValueChanged += new System.EventHandler(this.tbNumProcs_ValueChanged);
             // 
             // lblNumProcs
             // 
             this.lblNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.lblNumProcs.AutoSize = true;
             this.lblNumProcs.Enabled = false;
             this.lblNumProcs.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.lblNumProcs.Location = new System.Drawing.Point(295, 431);
             this.lblNumProcs.Name = "lblNumProcs";
             this.lblNumProcs.Size = new System.Drawing.Size(14, 13);
             this.lblNumProcs.TabIndex = 23;
             this.lblNumProcs.Text = "1";
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(495, 459);
             this.Controls.Add(this.lblNumProcs);
             this.Controls.Add(this.tbNumProcs);
             this.Controls.Add(this.chkShowThreads);
             this.Controls.Add(this.chkParallel);
             this.Controls.Add(this.btnStartStop);
             this.Controls.Add(this.pbRenderedImage);
             this.Name = "MainForm";
             this.Text = "Ray Tracer";
             this.Load += new System.EventHandler(this.MainForm_Load);
             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="53" endline="167"><![CDATA[
                 {
                     chkParallel.Enabled = true;
                     chkShowThreads.Enabled = chkParallel.Checked;
                     btnStartStop.Enabled = true;
                     btnStartStop.Text = "Start";
                     _cancellation = null;
                 }, TaskScheduler.FromCurrentSynchronizationContext());
                 
                 chkShowThreads.Enabled = false;
                 chkParallel.Enabled = false;
                 btnStartStop.Text = "Stop";
             }
         }
 
         private void ConfigureImage()
         {
             // If we need to create a new bitmap, do so
             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
             {
                 // Dispose of the old one if one exists
                 if (_bitmap != null)
                 {
                     pbRenderedImage.Image = null;
                     _bitmap.Dispose();
                 }
 
                 // We always render a square even if the window isn't square
                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
 
                 // Create a new object pool for the rendering arrays
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs" startline="83" endline="167"><![CDATA[
                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
 
                 // Create a new Bitmap and set it into the picture box
                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
                 pbRenderedImage.Image = _bitmap;
             }
         }
 
         private void RenderLoop(object boxedToken)
         {
             var cancellationToken = (CancellationToken)boxedToken;
 
             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
             var rayTracer = new RayTracer(_width, _height);
             var scene = rayTracer.DefaultScene;
             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
             var baseY = sphere2.Radius;
             sphere2.Center.Y = sphere2.Radius;
 
             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
             var renderingTime = new Stopwatch();
             var totalTime = Stopwatch.StartNew();
 
             // Keep rendering until the rendering task has been canceled
             while (!cancellationToken.IsCancellationRequested)
             {
                 // Get the next buffer
                 var rgb = _freeBuffers.GetObject();
 
                 // Determine the new position of the sphere based on the current time elapsed
                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
                 sphere2.Center.Y = baseY + dy2;
 
                 // Render the scene
                 renderingTime.Reset();
                 renderingTime.Start();
                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
                     else rayTracer.RenderParallel(scene, rgb, options);
                 renderingTime.Stop();
 
                 // Update the bitmap in the UI thread
                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
                 BeginInvoke((Action)delegate
                 {
                     // Copy the pixel array into the bitmap
                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _bitmap.UnlockBits(bmpData);
                     _freeBuffers.PutObject(rgb);
 
                     // Refresh the UI
                     pbRenderedImage.Invalidate();
                     Text = "Ray Tracer - FPS
                 });
             }
         }
 
         private void chkParallel_CheckedChanged(object sender, EventArgs e)
         {
             _parallel = 
                 lblNumProcs.Enabled = 
                 tbNumProcs.Enabled = 
                 chkShowThreads.Enabled = 
                 chkParallel.Checked;
         }
 
         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
         {
             lblNumProcs.Text = tbNumProcs.Value.ToString();
             _degreeOfParallelism = tbNumProcs.Value;
         }
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             tbNumProcs.Minimum = 1;
             tbNumProcs.Maximum = Environment.ProcessorCount;
             tbNumProcs.Value = tbNumProcs.Maximum;
             lblNumProcs.Text = tbNumProcs.Value.ToString();
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="19" endline="19"><![CDATA[
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="20" endline="27"><![CDATA[
         public Color(string str)
         {
             string[] nums = str.Split(',');
             if (nums.Length != 3) throw new ArgumentException();
             R = double.Parse(nums[0]);
             G = double.Parse(nums[1]);
             B = double.Parse(nums[2]);
         }
 
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = new Color(0, 0, 0);
         public static readonly Color DefaultColor = new Color(0, 0, 0);
 
         public static double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public static byte ToByte(double c)
         {
             return (byte)(255 * Legalize(c));
         }
 
         public static Int32 ToInt32(double c)
         {
             Int32 r = (Int32)(255 * c);
             return (r > 255 ? 255 
         }
 
         public Int32 ToInt32()
         {
             return (ToInt32(B) | ToInt32(G) << 8 | ToInt32(R) << 16 | 255 << 24);
         }
 
         internal System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb(ToInt32());
         }
 
         public void ChangeHue(double hue)
         {
             double H, S, L;
 
             System.Drawing.Color c = System.Drawing.Color.FromArgb(ToInt32());
             S = c.GetSaturation();
             L = c.GetBrightness();
             H = c.GetHue();
 
             H = hue;
             S = 0.9;
             L = ((L - 0.5) * 0.5) + 0.5;
 
             if (L == 0)
             {
                 R = G = B = 0;
             }
             else
             {
                 if (S == 0)
                 {
                     R = G = B = L;
                 }
                 else
                 {
                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) 
                     double temp1 = 2.0 * L - temp2;
 
                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
                     double[] clr = new double[] { 0, 0, 0 };
 
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
             if (nums.Length != 3) throw new ArgumentException();
             R = double.Parse(nums[0]);
             G = double.Parse(nums[1]);
             B = double.Parse(nums[2]);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="28" endline="33"><![CDATA[
 
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="34" endline="37"><![CDATA[
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="38" endline="42"><![CDATA[
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="43" endline="46"><![CDATA[
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="47" endline="54"><![CDATA[
 
         public static readonly Color Background = new Color(0, 0, 0);
         public static readonly Color DefaultColor = new Color(0, 0, 0);
 
         public static double Legalize(double d)
         {
             return d > 1 ? 1 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="55" endline="59"><![CDATA[
 
         public static byte ToByte(double c)
         {
             return (byte)(255 * Legalize(c));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="60" endline="65"><![CDATA[
 
         public static Int32 ToInt32(double c)
         {
             Int32 r = (Int32)(255 * c);
             return (r > 255 ? 255 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="66" endline="70"><![CDATA[
 
         public Int32 ToInt32()
         {
             return (ToInt32(B) | ToInt32(G) << 8 | ToInt32(R) << 16 | 255 << 24);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="71" endline="75"><![CDATA[
 
         internal System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb(ToInt32());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="76" endline="128"><![CDATA[
 
         public void ChangeHue(double hue)
         {
             double H, S, L;
 
             System.Drawing.Color c = System.Drawing.Color.FromArgb(ToInt32());
             S = c.GetSaturation();
             L = c.GetBrightness();
             H = c.GetHue();
 
             H = hue;
             S = 0.9;
             L = ((L - 0.5) * 0.5) + 0.5;
 
             if (L == 0)
             {
                 R = G = B = 0;
             }
             else
             {
                 if (S == 0)
                 {
                     R = G = B = L;
                 }
                 else
                 {
                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) 
                     double temp1 = 2.0 * L - temp2;
 
                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
                     double[] clr = new double[] { 0, 0, 0 };
 
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
             {
                 R = G = B = 0;
             }
             else
             {
                 if (S == 0)
                 {
                     R = G = B = L;
                 }
                 else
                 {
                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) 
                     double temp1 = 2.0 * L - temp2;
 
                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
                     double[] clr = new double[] { 0, 0, 0 };
 
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
             {
                 if (S == 0)
                 {
                     R = G = B = L;
                 }
                 else
                 {
                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) 
                     double temp1 = 2.0 * L - temp2;
 
                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
                     double[] clr = new double[] { 0, 0, 0 };
 
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                 {
                     R = G = B = L;
                 }
                 else
                 {
                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) 
                     double temp1 = 2.0 * L - temp2;
 
                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
                     double[] clr = new double[] { 0, 0, 0 };
 
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                 {
                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) 
                     double temp1 = 2.0 * L - temp2;
 
                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
                     double[] clr = new double[] { 0, 0, 0 };
 
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                             clr[i] = temp1;
                     }
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs" startline="48" endline="130"><![CDATA[
         public static readonly Color Background = new Color(0, 0, 0);
         public static readonly Color DefaultColor = new Color(0, 0, 0);
 
         public static double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public static byte ToByte(double c)
         {
             return (byte)(255 * Legalize(c));
         }
 
         public static Int32 ToInt32(double c)
         {
             Int32 r = (Int32)(255 * c);
             return (r > 255 ? 255 
         }
 
         public Int32 ToInt32()
         {
             return (ToInt32(B) | ToInt32(G) << 8 | ToInt32(R) << 16 | 255 << 24);
         }
 
         internal System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb(ToInt32());
         }
 
         public void ChangeHue(double hue)
         {
             double H, S, L;
 
             System.Drawing.Color c = System.Drawing.Color.FromArgb(ToInt32());
             S = c.GetSaturation();
             L = c.GetBrightness();
             H = c.GetHue();
 
             H = hue;
             S = 0.9;
             L = ((L - 0.5) * 0.5) + 0.5;
 
             if (L == 0)
             {
                 R = G = B = 0;
             }
             else
             {
                 if (S == 0)
                 {
                     R = G = B = L;
                 }
                 else
                 {
                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) 
                     double temp1 = 2.0 * L - temp2;
 
                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
                     double[] clr = new double[] { 0, 0, 0 };
 
                     for (int i = 0; i < 3; i++)
                     {
 
                         if (t3[i] < 0) t3[i] += 1.0;
                         if (t3[i] > 1) t3[i] -= 1.0;
                         if (6.0 * t3[i] < 1.0)
                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
                         else if (2.0 * t3[i] < 1.0)
                             clr[i] = temp2;
                         else if (3.0 * t3[i] < 2.0)
                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
                         else
                             clr[i] = temp1;
                     }
 
                     R = clr[0];
                     G = clr[1];
                     B = clr[2];
                 }
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surface.cs" startline="20" endline="29"><![CDATA[
         public Surface(Func<Vector, Color> Diffuse,
                         Func<Vector, Color> Specular,
                         Func<Vector, double> Reflect,
                         double Roughness)
         {
             this.Diffuse = Diffuse;
             this.Specular = Specular;
             this.Reflect = Reflect;
             this.Roughness = Roughness;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Resources.Designer.cs" startline="31" endline="33"><![CDATA[
         [global
         internal Resources() {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Resources.Designer.cs" startline="34" endline="47"><![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
             set {
                 resourceCulture = value;
             }
         }
     }
 }
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Resources.Designer.cs" startline="48" endline="58"><![CDATA[
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Resources.Designer.cs" startline="59" endline="61"><![CDATA[
             set {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Camera.cs" startline="19" endline="19"><![CDATA[
         public Camera(Vector pos, Vector forward, Vector up, Vector right) { Pos = pos; Forward = forward; Up = up; Right = right; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Camera.cs" startline="20" endline="29"><![CDATA[
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera(pos, forward, up, right);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="19" endline="19"><![CDATA[
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="20" endline="27"><![CDATA[
         public Vector(string str)
         {
             string[] nums = str.Split(',');
             if (nums.Length != 3) throw new ArgumentException();
             X = double.Parse(nums[0]);
             Y = double.Parse(nums[1]);
             Z = double.Parse(nums[2]);
         }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
 
         public readonly static Vector Null = new Vector(0, 0, 0);
     }
 }
             if (nums.Length != 3) throw new ArgumentException();
             X = double.Parse(nums[0]);
             Y = double.Parse(nums[1]);
             Z = double.Parse(nums[2]);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="28" endline="31"><![CDATA[
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="32" endline="35"><![CDATA[
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="36" endline="39"><![CDATA[
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="40" endline="43"><![CDATA[
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="44" endline="44"><![CDATA[
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="45" endline="50"><![CDATA[
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="51" endline="56"><![CDATA[
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="57" endline="60"><![CDATA[
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs" startline="61" endline="64"><![CDATA[
 
         public readonly static Vector Null = new Vector(0, 0, 0);
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Program.cs" startline="21" endline="25"><![CDATA[
         {
             Application.EnableVisualStyles();
             Application.SetCompatibleTextRenderingDefault(false);
             Application.Run(new MainForm());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Settings.Designer.cs" startline="21" endline="23"><![CDATA[
             get {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Settings.Designer.cs" startline="18" endline="26"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
         
         public static Settings Default {
             get {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Scene.cs" startline="19" endline="19"><![CDATA[
         public Scene(SceneObject[] things, Light[] lights, Camera camera) { Things = things; Lights = lights; Camera = camera; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Scene.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="16" endline="50"><![CDATA[
         public static readonly Surface CheckerBoard =
             new Surface(
                 delegate(Vector pos)
                 {
                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                  ? new Color(1, 1, 1)
                  
                 },
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos)
                 {
                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                  ? .1
                  
                 },
                 150);
 
 
 
         public static readonly Surface Shiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.5, .5, .5); },
                 delegate(Vector pos) { return .7; },
                 250);
 
         public static readonly Surface MatteShiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="19" endline="50"><![CDATA[
                 {
                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                  ? new Color(1, 1, 1)
                  
                 },
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos)
                 {
                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                  ? .1
                  
                 },
                 150);
 
 
 
         public static readonly Surface Shiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.5, .5, .5); },
                 delegate(Vector pos) { return .7; },
                 250);
 
         public static readonly Surface MatteShiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="24" endline="50"><![CDATA[
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos)
                 {
                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                  ? .1
                  
                 },
                 150);
 
 
 
         public static readonly Surface Shiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.5, .5, .5); },
                 delegate(Vector pos) { return .7; },
                 250);
 
         public static readonly Surface MatteShiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="26" endline="50"><![CDATA[
                 {
                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                  ? .1
                  
                 },
                 150);
 
 
 
         public static readonly Surface Shiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.5, .5, .5); },
                 delegate(Vector pos) { return .7; },
                 250);
 
         public static readonly Surface MatteShiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="37" endline="50"><![CDATA[
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.5, .5, .5); },
                 delegate(Vector pos) { return .7; },
                 250);
 
         public static readonly Surface MatteShiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="38" endline="50"><![CDATA[
                 delegate(Vector pos) { return new Color(.5, .5, .5); },
                 delegate(Vector pos) { return .7; },
                 250);
 
         public static readonly Surface MatteShiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="39" endline="50"><![CDATA[
                 delegate(Vector pos) { return .7; },
                 250);
 
         public static readonly Surface MatteShiny =
             new Surface(
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="44" endline="50"><![CDATA[
                 delegate(Vector pos) { return new Color(1, 1, 1); },
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="45" endline="50"><![CDATA[
                 delegate(Vector pos) { return new Color(.25, .25, .25); },
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs" startline="46" endline="50"><![CDATA[
                 delegate(Vector pos) { return .7; },
                 250);
 
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="74" endline="26"><![CDATA[
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
         public RayTracer(int screenWidth, int screenHeight)
         {
             this.screenWidth = screenWidth;
             this.screenHeight = screenHeight;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="27" endline="40"><![CDATA[
 
         internal void RenderSequential(Scene scene, Int32[] rgb)
         {
             for (int y = 0; y < screenHeight; y++)
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             }
         }
 
         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             Parallel.For(0, screenHeight, options, y =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             });
         }
 
         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             int id = 0;
             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     color.ChangeHue(hue);
                     rgb[x + stride] = color.ToInt32();
                 }
                 return hue;
             }, 
             hue => Interlocked.Decrement(ref id));
         }
 
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             }
         }
 
         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             Parallel.For(0, screenHeight, options, y =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             });
         }
 
         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             int id = 0;
             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     color.ChangeHue(hue);
                     rgb[x + stride] = color.ToInt32();
                 }
                 return hue;
             }, 
             hue => Interlocked.Decrement(ref id));
         }
 
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             }
         }
 
         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             Parallel.For(0, screenHeight, options, y =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             });
         }
 
         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             int id = 0;
             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     color.ChangeHue(hue);
                     rgb[x + stride] = color.ToInt32();
                 }
                 return hue;
             }, 
             hue => Interlocked.Decrement(ref id));
         }
 
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             }
             for (int y = 0; y < screenHeight; y++)
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             }
         }
 
         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             Parallel.For(0, screenHeight, options, y =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             });
         }
 
         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             int id = 0;
             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     color.ChangeHue(hue);
                     rgb[x + stride] = color.ToInt32();
                 }
                 return hue;
             }, 
             hue => Interlocked.Decrement(ref id));
         }
 
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="41" endline="54"><![CDATA[
 
         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             Parallel.For(0, screenHeight, options, y =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             });
         }
 
         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             int id = 0;
             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     color.ChangeHue(hue);
                     rgb[x + stride] = color.ToInt32();
                 }
                 return hue;
             }, 
             hue => Interlocked.Decrement(ref id));
         }
 
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
         {
             Parallel.For(0, screenHeight, options, y =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     rgb[x + stride] = color.ToInt32();
                 }
             });
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="55" endline="72"><![CDATA[
 
         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
         {
             int id = 0;
             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     color.ChangeHue(hue);
                     rgb[x + stride] = color.ToInt32();
                 }
                 return hue;
             }, 
             hue => Interlocked.Decrement(ref id));
         }
 
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
         {
             int id = 0;
             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
             {
                 int stride = y * screenWidth;
                 Camera camera = scene.Camera;
                 for (int x = 0; x < screenWidth; x++)
                 {
                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
                     color.ChangeHue(hue);
                     rgb[x + stride] = color.ToInt32();
                 }
                 return hue;
             }, 
             hue => Interlocked.Decrement(ref id));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="73" endline="89"><![CDATA[
 
         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
         private Random _rand = new Random();
 
         private double GetHueShift(int id)
         {
             double shift;
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             lock (_numToHueShiftLookup)
             {
                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
                 {
                     shift = _rand.NextDouble();
                     _numToHueShiftLookup.Add(id, shift);
                 }
             }
             return shift;
         }
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             return shift;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="90" endline="107"><![CDATA[
 
         internal readonly Scene DefaultScene = CreateDefaultScene();
 
         static Scene CreateDefaultScene()
         {
             SceneObject[] things =  {
                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
             };
             Light[] lights = {
                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
             };
             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
 
             return new Scene(things, lights, camera);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="108" endline="125"><![CDATA[
 
 
         private ISect MinIntersection(Ray ray, Scene scene)
         {
             ISect min = ISect.Null;
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             foreach (SceneObject obj in scene.Things)
             {
                 ISect isect = obj.Intersect(ray);
                 if (!ISect.IsNull(isect))
                 {
                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
                     {
                         min = isect;
                     }
                 }
             }
             return min;
         }
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             return min;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="126" endline="133"><![CDATA[
 
         private double TestRay(Ray ray, Scene scene)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return 0;
             return isect.Dist;
         }
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
                 return 0;
             return isect.Dist;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="134" endline="141"><![CDATA[
 
         private Color TraceRay(Ray ray, Scene scene, int depth)
         {
             ISect isect = MinIntersection(ray, scene);
             if (ISect.IsNull(isect))
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
                 return Color.Background;
             return Shade(isect, scene, depth);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="142" endline="163"><![CDATA[
 
         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
         {
             Color ret = new Color(0, 0, 0);
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             foreach (Light light in scene.Lights)
             {
                 Vector ldis = Vector.Minus(light.Pos, pos);
                 Vector livec = Vector.Norm(ldis);
                 double neatIsect = TestRay(new Ray(pos, livec), scene);
                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
                 if (!isInShadow)
                 {
                     double illum = Vector.Dot(livec, norm);
                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                     double specular = Vector.Dot(livec, Vector.Norm(rd));
                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) 
                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
                 }
             }
             return ret;
         }
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             return ret;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="164" endline="168"><![CDATA[
 
         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
         {
             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="169" endline="183"><![CDATA[
 
         private Color Shade(ISect isect, Scene scene, int depth)
         {
             Vector d = isect.Ray.Dir;
             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
             Vector normal = isect.Thing.Normal(pos);
             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
             Color ret = Color.DefaultColor;
             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
             if (depth >= MaxDepth)
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
     }
 }
             {
                 return Color.Plus(ret, new Color(.5, .5, .5));
             }
             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="184" endline="188"><![CDATA[
 
         private double RecenterX(double x)
         {
             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="189" endline="192"><![CDATA[
         private double RecenterY(double y)
         {
             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs" startline="193" endline="198"><![CDATA[
 
         private Vector GetPoint(double x, double y, Camera camera)
         {
             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                        Vector.Times(RecenterY(y), camera.Up))));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Sphere.cs" startline="18" endline="18"><![CDATA[
         public Sphere(Vector center, double radius, Surface surface) 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Sphere.cs" startline="19" endline="36"><![CDATA[
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return ISect.Null;
             return new ISect(this, ray, dist);
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 }
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return ISect.Null;
             return new ISect(this, ray, dist);
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 }
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return ISect.Null;
             return new ISect(this, ray, dist);
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 }
             if (dist == 0) return ISect.Null;
             return new ISect(this, ray, dist);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Sphere.cs" startline="37" endline="41"><![CDATA[
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Light.cs" startline="16" endline="16"><![CDATA[
         public Light(Vector pos, Color color) { Pos = pos; Color = color; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Ray.cs" startline="16" endline="16"><![CDATA[
         public Ray(Vector start, Vector dir) { Start = start; Dir = dir; }
]]></source>
</source_elements></project>
