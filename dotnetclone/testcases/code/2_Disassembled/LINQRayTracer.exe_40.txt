
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System.Core
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly LINQRayTracer
{

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 35 31 30 62 39 38 64 36 2D 38 65 35 35   // ..$510b98d6-8e55
                                                                                                  2D 34 36 34 61 2D 39 31 61 62 2D 30 37 63 62 39   // -464a-91ab-07cb9
                                                                                                  31 61 62 65 32 34 32 00 00 )                      // 1abe242..
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 0D 4C 49 4E 51 52 61 79 54 72 61 63 65 72   // ...LINQRayTracer
                                                                                              00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 0D 4C 49 4E 51 52 61 79 54 72 61 63 65 72   // ...LINQRayTracer
                                                                                                00 00 ) 
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.resources
{
  // Offset: 0x00000000 Length: 0x000000B4
}
.mresource public Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm.resources
{
  // Offset: 0x000000B8 Length: 0x000000B4
}
.module LINQRayTracer.exe
// MVID: {60F262DB-8359-4DC0-A0C4-68040D02D2B3}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x00310000


// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // Code size       26 (0x1a)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Program.cs' 
//000019:         {
    IL_0000:  nop
//000020:             Application.EnableVisualStyles();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
    IL_0006:  nop
//000021:             Application.SetCompatibleTextRenderingDefault(false);
    IL_0007:  ldc.i4.0
    IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
    IL_000d:  nop
//000022:             Application.Run(new MainForm());
    IL_000e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::.ctor()
    IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_0018:  nop
//000023:         }
    IL_0019:  ret
  } // end of method Program::Main

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method Program::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Program

.class private auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Settings.Designer.cs' 
//000021:             get {
    IL_0000:  nop
//000022:                 return defaultInstance;
    IL_0001:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000023:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000018:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
    IL_000f:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::defaultInstance
//000019:         
//000020:         public static Settings Default {
//000021:             get {
//000022:                 return defaultInstance;
//000023:             }
//000024:         }
//000025:     }
//000026: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
          Default()
  {
    .get class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings

.class public auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass4'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32[] rgb
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass4'::.ctor

    .method public hidebysig instance void 
            '<BackgroundRender>b__3'() cil managed
    {
      // Code size       109 (0x6d)
      .maxstack  4
      .locals init ([0] class [System.Drawing]System.Drawing.Imaging.BitmapData bmpData)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs' 
//000084:                 {
      IL_0000:  nop
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::'<>4__this'
      IL_0007:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_image
      IL_000c:  ldarg.0
      IL_000d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::'<>4__this'
      IL_0012:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_rect
      IL_0017:  ldc.i4.2
      IL_0018:  ldarg.0
      IL_0019:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::'<>4__this'
      IL_001e:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_image
      IL_0023:  callvirt   instance valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat [System.Drawing]System.Drawing.Image::get_PixelFormat()
      IL_0028:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.BitmapData [System.Drawing]System.Drawing.Bitmap::LockBits(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.ImageLockMode,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_002d:  stloc.0
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
      IL_002e:  ldarg.0
      IL_002f:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::rgb
      IL_0034:  ldc.i4.0
      IL_0035:  ldloc.0
      IL_0036:  callvirt   instance native int [System.Drawing]System.Drawing.Imaging.BitmapData::get_Scan0()
      IL_003b:  ldarg.0
      IL_003c:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::rgb
      IL_0041:  ldlen
      IL_0042:  conv.i4
      IL_0043:  call       void [mscorlib]System.Runtime.InteropServices.Marshal::Copy(int32[],
                                                                                       int32,
                                                                                       native int,
                                                                                       int32)
      IL_0048:  nop
//000087:                     _image.UnlockBits(bmpData);
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::'<>4__this'
      IL_004f:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_image
      IL_0054:  ldloc.0
      IL_0055:  callvirt   instance void [System.Drawing]System.Drawing.Bitmap::UnlockBits(class [System.Drawing]System.Drawing.Imaging.BitmapData)
      IL_005a:  nop
//000088:                     pbImage.Refresh();
      IL_005b:  ldarg.0
      IL_005c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::'<>4__this'
      IL_0061:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
      IL_0066:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
      IL_006b:  nop
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
      IL_006c:  ret
    } // end of method '<>c__DisplayClass4'::'<BackgroundRender>b__3'

  } // end of class '<>c__DisplayClass4'

  .field private class [mscorlib]System.Threading.Tasks.TaskScheduler _uiScheduler
  .field private int32 _width
  .field private int32 _height
  .field private class [System.Drawing]System.Drawing.Bitmap _image
  .field private valuetype [System.Drawing]System.Drawing.Rectangle _rect
  .field private bool _parallel
  .field private class [System]System.Diagnostics.Stopwatch _sw
  .field private class [mscorlib]System.Threading.CancellationTokenSource _cancellation
  .field private class [System]System.ComponentModel.IContainer components
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox pbImage
  .field private class [System.Windows.Forms]System.Windows.Forms.RadioButton rbLINQ
  .field private class [System.Windows.Forms]System.Windows.Forms.RadioButton rbPLINQ
  .field private class [System.Windows.Forms]System.Windows.Forms.Button btnRender
  .field private class [System.Windows.Forms]System.Windows.Forms.Label lbTimeToComplete
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       24 (0x18)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.Designer.cs' 
//000008:         private System.ComponentModel.IContainer components = null;
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  stfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs' 
//000022:         public MainForm()
    IL_0007:  ldarg.0
    IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_000d:  nop
//000023:         {
    IL_000e:  nop
//000024:             InitializeComponent();
    IL_000f:  ldarg.0
    IL_0010:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InitializeComponent()
    IL_0015:  nop
//000025:         }
    IL_0016:  nop
    IL_0017:  ret
  } // end of method MainForm::.ctor

  .method private hidebysig instance void 
          MainForm_Load(object sender,
                        class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       13 (0xd)
    .maxstack  8
//000026: 
//000027:         private TaskScheduler _uiScheduler;
//000028:         private int _width, _height;
//000029:         private Bitmap _image;
//000030:         private Rectangle _rect;
//000031:         private bool _parallel;
//000032:         private Stopwatch _sw;
//000033:         private CancellationTokenSource _cancellation;
//000034: 
//000035:         private void MainForm_Load(object sender, EventArgs e)
//000036:         {
    IL_0000:  nop
//000037:             _uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
    IL_0001:  ldarg.0
    IL_0002:  call       class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskScheduler::FromCurrentSynchronizationContext()
    IL_0007:  stfld      class [mscorlib]System.Threading.Tasks.TaskScheduler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_uiScheduler
//000038:         }
    IL_000c:  ret
  } // end of method MainForm::MainForm_Load

  .method private hidebysig instance void 
          btnRender_Click(object sender,
                          class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       361 (0x169)
    .maxstack  6
    .locals init ([0] class [System.Drawing]System.Drawing.Image oldBmp,
             [1] class [mscorlib]System.Threading.Tasks.Task background,
             [2] class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task> 'CS$<>9__CachedAnonymousMethodDelegate1',
             [3] bool CS$4$0000,
             [4] int32 CS$0$0001)
//000039: 
//000040:         private void btnRender_Click(object sender, EventArgs e)
//000041:         {
//000042:             if (_cancellation == null)
//000043:             {
//000044:                 btnRender.Text = "Cancel";
//000045:                 rbLINQ.Enabled = false;
//000046:                 rbPLINQ.Enabled = false;
//000047: 
//000048:                 _width = _height = Math.Min(pbImage.Width, pbImage.Height);
//000049:                 _image = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000050:                 _rect = new Rectangle(0, 0, _width, _height);
//000051: 
//000052:                 Image oldBmp = pbImage.Image;
//000053:                 pbImage.Image = _image;
//000054:                 if (oldBmp != null) oldBmp.Dispose();
//000055: 
//000056:                 _parallel = rbPLINQ.Checked;
//000057:                 _cancellation = new CancellationTokenSource();
//000058:                 _sw = Stopwatch.StartNew();
//000059: 
//000060:                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
//000061:                 background.ContinueWith(_ =>
//000062:                 {
//000063:                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
//000064:                     btnRender.Enabled = true;
//000065:                     btnRender.Text = "Render";
//000066:                     rbLINQ.Enabled = true;
//000067:                     rbPLINQ.Enabled = true;
//000068:                     _cancellation = null;
//000069:                 }, _uiScheduler);
//000070:             }
//000071:             else
//000072:             {
//000073:                 btnRender.Enabled = false;
//000074:                 _cancellation.Cancel();
//000075:             }
//000076:         }
//000077: 
//000078:         private void BackgroundRender(object state)
//000079:         {
//000080:             var cancellationToken = (CancellationToken)state;
//000081:             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
//000082:             {
//000083:                 Task.Factory.StartNew(() =>
//000084:                 {
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000087:                     _image.UnlockBits(bmpData);
//000088:                     pbImage.Refresh();
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_0000:  ldnull
    IL_0001:  stloc.2
//000041:         {
    IL_0002:  nop
//000042:             if (_cancellation == null)
    IL_0003:  ldarg.0
    IL_0004:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.3
//000043:             {
//000044:                 btnRender.Text = "Cancel";
//000045:                 rbLINQ.Enabled = false;
//000046:                 rbPLINQ.Enabled = false;
//000047: 
//000048:                 _width = _height = Math.Min(pbImage.Width, pbImage.Height);
//000049:                 _image = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000050:                 _rect = new Rectangle(0, 0, _width, _height);
//000051: 
//000052:                 Image oldBmp = pbImage.Image;
//000053:                 pbImage.Image = _image;
//000054:                 if (oldBmp != null) oldBmp.Dispose();
//000055: 
//000056:                 _parallel = rbPLINQ.Checked;
//000057:                 _cancellation = new CancellationTokenSource();
//000058:                 _sw = Stopwatch.StartNew();
//000059: 
//000060:                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
//000061:                 background.ContinueWith(_ =>
//000062:                 {
//000063:                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
//000064:                     btnRender.Enabled = true;
//000065:                     btnRender.Text = "Render";
//000066:                     rbLINQ.Enabled = true;
//000067:                     rbPLINQ.Enabled = true;
//000068:                     _cancellation = null;
//000069:                 }, _uiScheduler);
//000070:             }
//000071:             else
//000072:             {
//000073:                 btnRender.Enabled = false;
//000074:                 _cancellation.Cancel();
//000075:             }
//000076:         }
//000077: 
//000078:         private void BackgroundRender(object state)
//000079:         {
//000080:             var cancellationToken = (CancellationToken)state;
//000081:             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
//000082:             {
//000083:                 Task.Factory.StartNew(() =>
//000084:                 {
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000087:                     _image.UnlockBits(bmpData);
//000088:                     pbImage.Refresh();
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_0010:  ldloc.3
    IL_0011:  brtrue     IL_014c

//000043:             {
    IL_0016:  nop
//000044:                 btnRender.Text = "Cancel";
    IL_0017:  ldarg.0
    IL_0018:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_001d:  ldstr      "Cancel"
    IL_0022:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0027:  nop
//000045:                 rbLINQ.Enabled = false;
    IL_0028:  ldarg.0
    IL_0029:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_002e:  ldc.i4.0
    IL_002f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0034:  nop
//000046:                 rbPLINQ.Enabled = false;
    IL_0035:  ldarg.0
    IL_0036:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_003b:  ldc.i4.0
    IL_003c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0041:  nop
//000047: 
//000048:                 _width = _height = Math.Min(pbImage.Width, pbImage.Height);
    IL_0042:  ldarg.0
    IL_0043:  ldarg.0
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_004a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_004f:  ldarg.0
    IL_0050:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0055:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_005a:  call       int32 [mscorlib]System.Math::Min(int32,
                                                          int32)
    IL_005f:  dup
    IL_0060:  stloc.s    CS$0$0001
    IL_0062:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_0067:  ldloc.s    CS$0$0001
    IL_0069:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
//000049:                 _image = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
    IL_006e:  ldarg.0
    IL_006f:  ldarg.0
    IL_0070:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
    IL_0075:  ldarg.0
    IL_0076:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_007b:  ldc.i4     0x22009
    IL_0080:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32,
                                                                                    valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
    IL_0085:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_image
//000050:                 _rect = new Rectangle(0, 0, _width, _height);
    IL_008a:  ldarg.0
    IL_008b:  ldc.i4.0
    IL_008c:  ldc.i4.0
    IL_008d:  ldarg.0
    IL_008e:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
    IL_0093:  ldarg.0
    IL_0094:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_0099:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                       int32,
                                                                                       int32,
                                                                                       int32)
    IL_009e:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_rect
//000051: 
//000052:                 Image oldBmp = pbImage.Image;
    IL_00a3:  ldarg.0
    IL_00a4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00a9:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00ae:  stloc.0
//000053:                 pbImage.Image = _image;
    IL_00af:  ldarg.0
    IL_00b0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00b5:  ldarg.0
    IL_00b6:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_image
    IL_00bb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_00c0:  nop
//000054:                 if (oldBmp != null) oldBmp.Dispose();
    IL_00c1:  ldloc.0
    IL_00c2:  ldnull
    IL_00c3:  ceq
    IL_00c5:  stloc.3
//000055: 
//000056:                 _parallel = rbPLINQ.Checked;
//000057:                 _cancellation = new CancellationTokenSource();
//000058:                 _sw = Stopwatch.StartNew();
//000059: 
//000060:                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
//000061:                 background.ContinueWith(_ =>
//000062:                 {
//000063:                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
//000064:                     btnRender.Enabled = true;
//000065:                     btnRender.Text = "Render";
//000066:                     rbLINQ.Enabled = true;
//000067:                     rbPLINQ.Enabled = true;
//000068:                     _cancellation = null;
//000069:                 }, _uiScheduler);
//000070:             }
//000071:             else
//000072:             {
//000073:                 btnRender.Enabled = false;
//000074:                 _cancellation.Cancel();
//000075:             }
//000076:         }
//000077: 
//000078:         private void BackgroundRender(object state)
//000079:         {
//000080:             var cancellationToken = (CancellationToken)state;
//000081:             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
//000082:             {
//000083:                 Task.Factory.StartNew(() =>
//000084:                 {
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000087:                     _image.UnlockBits(bmpData);
//000088:                     pbImage.Refresh();
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_00c6:  ldloc.3
    IL_00c7:  brtrue.s   IL_00d0

//000054:                 if (oldBmp != null) oldBmp.Dispose();
    IL_00c9:  ldloc.0
    IL_00ca:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_00cf:  nop
//000055: 
//000056:                 _parallel = rbPLINQ.Checked;
    IL_00d0:  ldarg.0
    IL_00d1:  ldarg.0
    IL_00d2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_00d7:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.RadioButton::get_Checked()
    IL_00dc:  stfld      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_parallel
//000057:                 _cancellation = new CancellationTokenSource();
    IL_00e1:  ldarg.0
    IL_00e2:  newobj     instance void [mscorlib]System.Threading.CancellationTokenSource::.ctor()
    IL_00e7:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
//000058:                 _sw = Stopwatch.StartNew();
    IL_00ec:  ldarg.0
    IL_00ed:  call       class [System]System.Diagnostics.Stopwatch [System]System.Diagnostics.Stopwatch::StartNew()
    IL_00f2:  stfld      class [System]System.Diagnostics.Stopwatch Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_sw
//000059: 
//000060:                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
    IL_00f7:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_00fc:  ldarg.0
    IL_00fd:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::BackgroundRender(object)
    IL_0103:  newobj     instance void class [mscorlib]System.Action`1<object>::.ctor(object,
                                                                                      native int)
    IL_0108:  ldarg.0
    IL_0109:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_010e:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_0113:  box        [mscorlib]System.Threading.CancellationToken
    IL_0118:  ldarg.0
    IL_0119:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_011e:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_0123:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action`1<object>,
                                                                                                                                     object,
                                                                                                                                     valuetype [mscorlib]System.Threading.CancellationToken)
    IL_0128:  stloc.1
//000061:                 background.ContinueWith(_ =>
    IL_0129:  ldloc.1
    IL_012a:  ldloc.2
    IL_012b:  brtrue.s   IL_013c

    IL_012d:  ldarg.0
    IL_012e:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<btnRender_Click>b__0'(class [mscorlib]System.Threading.Tasks.Task)
    IL_0134:  newobj     instance void class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>::.ctor(object,
                                                                                                                           native int)
    IL_0139:  stloc.2
    IL_013a:  br.s       IL_013c

    IL_013c:  ldloc.2
    IL_013d:  ldarg.0
    IL_013e:  ldfld      class [mscorlib]System.Threading.Tasks.TaskScheduler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_uiScheduler
    IL_0143:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.Task::ContinueWith(class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>,
                                                                                                                                  class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_0148:  pop
//000062:                 {
//000063:                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
//000064:                     btnRender.Enabled = true;
//000065:                     btnRender.Text = "Render";
//000066:                     rbLINQ.Enabled = true;
//000067:                     rbPLINQ.Enabled = true;
//000068:                     _cancellation = null;
//000069:                 }, _uiScheduler);
//000070:             }
    IL_0149:  nop
//000071:             else
//000072:             {
//000073:                 btnRender.Enabled = false;
//000074:                 _cancellation.Cancel();
//000075:             }
//000076:         }
//000077: 
//000078:         private void BackgroundRender(object state)
//000079:         {
//000080:             var cancellationToken = (CancellationToken)state;
//000081:             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
//000082:             {
//000083:                 Task.Factory.StartNew(() =>
//000084:                 {
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000087:                     _image.UnlockBits(bmpData);
//000088:                     pbImage.Refresh();
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_014a:  br.s       IL_0167

//000072:             {
    IL_014c:  nop
//000073:                 btnRender.Enabled = false;
    IL_014d:  ldarg.0
    IL_014e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0153:  ldc.i4.0
    IL_0154:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0159:  nop
//000074:                 _cancellation.Cancel();
    IL_015a:  ldarg.0
    IL_015b:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_0160:  callvirt   instance void [mscorlib]System.Threading.CancellationTokenSource::Cancel()
    IL_0165:  nop
//000075:             }
    IL_0166:  nop
//000076:         }
    IL_0167:  nop
    IL_0168:  ret
  } // end of method MainForm::btnRender_Click

  .method private hidebysig instance void 
          BackgroundRender(object state) cil managed
  {
    // Code size       82 (0x52)
    .maxstack  5
    .locals init ([0] valuetype [mscorlib]System.Threading.CancellationToken cancellationToken,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer rayTracer,
             [2] bool CS$4$0000)
//000077: 
//000078:         private void BackgroundRender(object state)
//000079:         {
    IL_0000:  nop
//000080:             var cancellationToken = (CancellationToken)state;
    IL_0001:  ldarg.1
    IL_0002:  unbox.any  [mscorlib]System.Threading.CancellationToken
    IL_0007:  stloc.0
//000081:             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
    IL_0008:  ldarg.0
    IL_0009:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
    IL_000e:  ldarg.0
    IL_000f:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_0014:  ldarg.0
    IL_0015:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<BackgroundRender>b__2'(int32[])
    IL_001b:  newobj     instance void class [mscorlib]System.Action`1<int32[]>::.ctor(object,
                                                                                       native int)
    IL_0020:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::.ctor(int32,
                                                                                                                       int32,
                                                                                                                       class [mscorlib]System.Action`1<int32[]>)
    IL_0025:  stloc.1
//000082:             {
//000083:                 Task.Factory.StartNew(() =>
//000084:                 {
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000087:                     _image.UnlockBits(bmpData);
//000088:                     pbImage.Refresh();
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
    IL_0026:  ldarg.0
    IL_0027:  ldfld      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_parallel
    IL_002c:  ldc.i4.0
    IL_002d:  ceq
    IL_002f:  stloc.2
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_0030:  ldloc.2
    IL_0031:  brtrue.s   IL_0043

//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
    IL_0033:  ldloc.1
    IL_0034:  ldloc.1
    IL_0035:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::DefaultScene
    IL_003a:  ldloc.0
    IL_003b:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::RenderParallel(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                valuetype [mscorlib]System.Threading.CancellationToken)
    IL_0040:  nop
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_0041:  br.s       IL_0051

//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
    IL_0043:  ldloc.1
    IL_0044:  ldloc.1
    IL_0045:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::DefaultScene
    IL_004a:  ldloc.0
    IL_004b:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::RenderSequential(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                  valuetype [mscorlib]System.Threading.CancellationToken)
    IL_0050:  nop
//000094:         }
    IL_0051:  ret
  } // end of method MainForm::BackgroundRender

  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.Designer.cs' 
//000015:         {
    IL_0000:  nop
//000016:             if (disposing && (components != null))
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000f

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_000a:  ldnull
    IL_000b:  ceq
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000017:             {
//000018:                 components.Dispose();
//000019:             }
//000020:             base.Dispose(disposing);
//000021:         }
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
//000031:             this.pbImage = new System.Windows.Forms.PictureBox();
//000032:             this.rbLINQ = new System.Windows.Forms.RadioButton();
//000033:             this.rbPLINQ = new System.Windows.Forms.RadioButton();
//000034:             this.btnRender = new System.Windows.Forms.Button();
//000035:             this.lbTimeToComplete = new System.Windows.Forms.Label();
//000036:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
//000037:             this.SuspendLayout();
//000038:             // 
//000039:             // pbImage
//000040:             // 
//000041:             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
//000042:                         | System.Windows.Forms.AnchorStyles.Left)
//000043:                         | System.Windows.Forms.AnchorStyles.Right)));
//000044:             this.pbImage.BackColor = System.Drawing.Color.Black;
//000045:             this.pbImage.Location = new System.Drawing.Point(13, 13);
//000046:             this.pbImage.Name = "pbImage";
//000047:             this.pbImage.Size = new System.Drawing.Size(359, 352);
//000048:             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
//000049:             this.pbImage.TabIndex = 0;
//000050:             this.pbImage.TabStop = false;
//000051:             // 
//000052:             // rbLINQ
//000053:             // 
//000054:             this.rbLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000055:             this.rbLINQ.AutoSize = true;
//000056:             this.rbLINQ.Location = new System.Drawing.Point(12, 374);
//000057:             this.rbLINQ.Name = "rbLINQ";
//000058:             this.rbLINQ.Size = new System.Drawing.Size(75, 17);
//000059:             this.rbLINQ.TabIndex = 1;
//000060:             this.rbLINQ.TabStop = true;
//000061:             this.rbLINQ.Text = "Sequential";
//000062:             this.rbLINQ.UseVisualStyleBackColor = true;
//000063:             // 
//000064:             // rbPLINQ
//000065:             // 
//000066:             this.rbPLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000067:             this.rbPLINQ.AutoSize = true;
//000068:             this.rbPLINQ.Location = new System.Drawing.Point(93, 374);
//000069:             this.rbPLINQ.Name = "rbPLINQ";
//000070:             this.rbPLINQ.Size = new System.Drawing.Size(59, 17);
//000071:             this.rbPLINQ.TabIndex = 2;
//000072:             this.rbPLINQ.TabStop = true;
//000073:             this.rbPLINQ.Text = "Parallel";
//000074:             this.rbPLINQ.UseVisualStyleBackColor = true;
//000075:             // 
//000076:             // btnRender
//000077:             // 
//000078:             this.btnRender.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000079:             this.btnRender.Location = new System.Drawing.Point(158, 371);
//000080:             this.btnRender.Name = "btnRender";
//000081:             this.btnRender.Size = new System.Drawing.Size(75, 23);
//000082:             this.btnRender.TabIndex = 3;
//000083:             this.btnRender.Text = "Render";
//000084:             this.btnRender.UseVisualStyleBackColor = true;
//000085:             this.btnRender.Click += new System.EventHandler(this.btnRender_Click);
//000086:             // 
//000087:             // lbTimeToComplete
//000088:             // 
//000089:             this.lbTimeToComplete.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000090:             this.lbTimeToComplete.AutoSize = true;
//000091:             this.lbTimeToComplete.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
//000092:             this.lbTimeToComplete.Location = new System.Drawing.Point(240, 376);
//000093:             this.lbTimeToComplete.Name = "lbTimeToComplete";
//000094:             this.lbTimeToComplete.Size = new System.Drawing.Size(0, 13);
//000095:             this.lbTimeToComplete.TabIndex = 4;
//000096:             // 
//000097:             // MainForm
//000098:             // 
//000099:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
//000100:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
//000101:             this.ClientSize = new System.Drawing.Size(388, 401);
//000102:             this.Controls.Add(this.lbTimeToComplete);
//000103:             this.Controls.Add(this.btnRender);
//000104:             this.Controls.Add(this.rbPLINQ);
//000105:             this.Controls.Add(this.rbLINQ);
//000106:             this.Controls.Add(this.pbImage);
//000107:             this.Name = "MainForm";
//000108:             this.Text = "LINQ Ray Tracer";
//000109:             this.Load += new System.EventHandler(this.MainForm_Load);
//000110:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
//000111:             this.ResumeLayout(false);
//000112:             this.PerformLayout();
//000113: 
//000114:         }
//000115: 
//000116:         #endregion
//000117: 
//000118:         private System.Windows.Forms.PictureBox pbImage;
//000119:         private System.Windows.Forms.RadioButton rbLINQ;
//000120:         private System.Windows.Forms.RadioButton rbPLINQ;
//000121:         private System.Windows.Forms.Button btnRender;
//000122:         private System.Windows.Forms.Label lbTimeToComplete;
//000123:     }
//000124: }
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_0022

//000017:             {
    IL_0014:  nop
//000018:                 components.Dispose();
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_001b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_0020:  nop
//000019:             }
    IL_0021:  nop
//000020:             base.Dispose(disposing);
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0029:  nop
//000021:         }
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       989 (0x3dd)
    .maxstack  7
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
    IL_0000:  nop
//000031:             this.pbImage = new System.Windows.Forms.PictureBox();
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_0007:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
//000032:             this.rbLINQ = new System.Windows.Forms.RadioButton();
    IL_000c:  ldarg.0
    IL_000d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::.ctor()
    IL_0012:  stfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
//000033:             this.rbPLINQ = new System.Windows.Forms.RadioButton();
    IL_0017:  ldarg.0
    IL_0018:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::.ctor()
    IL_001d:  stfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
//000034:             this.btnRender = new System.Windows.Forms.Button();
    IL_0022:  ldarg.0
    IL_0023:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Button::.ctor()
    IL_0028:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
//000035:             this.lbTimeToComplete = new System.Windows.Forms.Label();
    IL_002d:  ldarg.0
    IL_002e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_0033:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
//000036:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_003e:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_0043:  nop
//000037:             this.SuspendLayout();
    IL_0044:  ldarg.0
    IL_0045:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_004a:  nop
//000038:             // 
//000039:             // pbImage
//000040:             // 
//000041:             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
    IL_004b:  ldarg.0
    IL_004c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0051:  ldc.i4.s   15
    IL_0053:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0058:  nop
//000042:                         | System.Windows.Forms.AnchorStyles.Left)
//000043:                         | System.Windows.Forms.AnchorStyles.Right)));
//000044:             this.pbImage.BackColor = System.Drawing.Color.Black;
    IL_0059:  ldarg.0
    IL_005a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_005f:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Black()
    IL_0064:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0069:  nop
//000045:             this.pbImage.Location = new System.Drawing.Point(13, 13);
    IL_006a:  ldarg.0
    IL_006b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0070:  ldc.i4.s   13
    IL_0072:  ldc.i4.s   13
    IL_0074:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0079:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_007e:  nop
//000046:             this.pbImage.Name = "pbImage";
    IL_007f:  ldarg.0
    IL_0080:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0085:  ldstr      "pbImage"
    IL_008a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_008f:  nop
//000047:             this.pbImage.Size = new System.Drawing.Size(359, 352);
    IL_0090:  ldarg.0
    IL_0091:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0096:  ldc.i4     0x167
    IL_009b:  ldc.i4     0x160
    IL_00a0:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_00a5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_00aa:  nop
//000048:             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
    IL_00ab:  ldarg.0
    IL_00ac:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00b1:  ldc.i4.3
    IL_00b2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_00b7:  nop
//000049:             this.pbImage.TabIndex = 0;
    IL_00b8:  ldarg.0
    IL_00b9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00be:  ldc.i4.0
    IL_00bf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_00c4:  nop
//000050:             this.pbImage.TabStop = false;
    IL_00c5:  ldarg.0
    IL_00c6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00cb:  ldc.i4.0
    IL_00cc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_00d1:  nop
//000051:             // 
//000052:             // rbLINQ
//000053:             // 
//000054:             this.rbLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_00d2:  ldarg.0
    IL_00d3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_00d8:  ldc.i4.6
    IL_00d9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_00de:  nop
//000055:             this.rbLINQ.AutoSize = true;
    IL_00df:  ldarg.0
    IL_00e0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_00e5:  ldc.i4.1
    IL_00e6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_00eb:  nop
//000056:             this.rbLINQ.Location = new System.Drawing.Point(12, 374);
    IL_00ec:  ldarg.0
    IL_00ed:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_00f2:  ldc.i4.s   12
    IL_00f4:  ldc.i4     0x176
    IL_00f9:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_00fe:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0103:  nop
//000057:             this.rbLINQ.Name = "rbLINQ";
    IL_0104:  ldarg.0
    IL_0105:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_010a:  ldstr      "rbLINQ"
    IL_010f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0114:  nop
//000058:             this.rbLINQ.Size = new System.Drawing.Size(75, 17);
    IL_0115:  ldarg.0
    IL_0116:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_011b:  ldc.i4.s   75
    IL_011d:  ldc.i4.s   17
    IL_011f:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0124:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0129:  nop
//000059:             this.rbLINQ.TabIndex = 1;
    IL_012a:  ldarg.0
    IL_012b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_0130:  ldc.i4.1
    IL_0131:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0136:  nop
//000060:             this.rbLINQ.TabStop = true;
    IL_0137:  ldarg.0
    IL_0138:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_013d:  ldc.i4.1
    IL_013e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::set_TabStop(bool)
    IL_0143:  nop
//000061:             this.rbLINQ.Text = "Sequential";
    IL_0144:  ldarg.0
    IL_0145:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_014a:  ldstr      "Sequential"
    IL_014f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0154:  nop
//000062:             this.rbLINQ.UseVisualStyleBackColor = true;
    IL_0155:  ldarg.0
    IL_0156:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_015b:  ldc.i4.1
    IL_015c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_0161:  nop
//000063:             // 
//000064:             // rbPLINQ
//000065:             // 
//000066:             this.rbPLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_0162:  ldarg.0
    IL_0163:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_0168:  ldc.i4.6
    IL_0169:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_016e:  nop
//000067:             this.rbPLINQ.AutoSize = true;
    IL_016f:  ldarg.0
    IL_0170:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_0175:  ldc.i4.1
    IL_0176:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_017b:  nop
//000068:             this.rbPLINQ.Location = new System.Drawing.Point(93, 374);
    IL_017c:  ldarg.0
    IL_017d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_0182:  ldc.i4.s   93
    IL_0184:  ldc.i4     0x176
    IL_0189:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_018e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0193:  nop
//000069:             this.rbPLINQ.Name = "rbPLINQ";
    IL_0194:  ldarg.0
    IL_0195:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_019a:  ldstr      "rbPLINQ"
    IL_019f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_01a4:  nop
//000070:             this.rbPLINQ.Size = new System.Drawing.Size(59, 17);
    IL_01a5:  ldarg.0
    IL_01a6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_01ab:  ldc.i4.s   59
    IL_01ad:  ldc.i4.s   17
    IL_01af:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_01b4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_01b9:  nop
//000071:             this.rbPLINQ.TabIndex = 2;
    IL_01ba:  ldarg.0
    IL_01bb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_01c0:  ldc.i4.2
    IL_01c1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_01c6:  nop
//000072:             this.rbPLINQ.TabStop = true;
    IL_01c7:  ldarg.0
    IL_01c8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_01cd:  ldc.i4.1
    IL_01ce:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::set_TabStop(bool)
    IL_01d3:  nop
//000073:             this.rbPLINQ.Text = "Parallel";
    IL_01d4:  ldarg.0
    IL_01d5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_01da:  ldstr      "Parallel"
    IL_01df:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_01e4:  nop
//000074:             this.rbPLINQ.UseVisualStyleBackColor = true;
    IL_01e5:  ldarg.0
    IL_01e6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_01eb:  ldc.i4.1
    IL_01ec:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_01f1:  nop
//000075:             // 
//000076:             // btnRender
//000077:             // 
//000078:             this.btnRender.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_01f2:  ldarg.0
    IL_01f3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_01f8:  ldc.i4.6
    IL_01f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_01fe:  nop
//000079:             this.btnRender.Location = new System.Drawing.Point(158, 371);
    IL_01ff:  ldarg.0
    IL_0200:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0205:  ldc.i4     0x9e
    IL_020a:  ldc.i4     0x173
    IL_020f:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0214:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0219:  nop
//000080:             this.btnRender.Name = "btnRender";
    IL_021a:  ldarg.0
    IL_021b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0220:  ldstr      "btnRender"
    IL_0225:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_022a:  nop
//000081:             this.btnRender.Size = new System.Drawing.Size(75, 23);
    IL_022b:  ldarg.0
    IL_022c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0231:  ldc.i4.s   75
    IL_0233:  ldc.i4.s   23
    IL_0235:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_023a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_023f:  nop
//000082:             this.btnRender.TabIndex = 3;
    IL_0240:  ldarg.0
    IL_0241:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0246:  ldc.i4.3
    IL_0247:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_024c:  nop
//000083:             this.btnRender.Text = "Render";
    IL_024d:  ldarg.0
    IL_024e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0253:  ldstr      "Render"
    IL_0258:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_025d:  nop
//000084:             this.btnRender.UseVisualStyleBackColor = true;
    IL_025e:  ldarg.0
    IL_025f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0264:  ldc.i4.1
    IL_0265:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_026a:  nop
//000085:             this.btnRender.Click += new System.EventHandler(this.btnRender_Click);
    IL_026b:  ldarg.0
    IL_026c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0271:  ldarg.0
    IL_0272:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender_Click(object,
                                                                                                                                class [mscorlib]System.EventArgs)
    IL_0278:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_027d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Click(class [mscorlib]System.EventHandler)
    IL_0282:  nop
//000086:             // 
//000087:             // lbTimeToComplete
//000088:             // 
//000089:             this.lbTimeToComplete.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_0283:  ldarg.0
    IL_0284:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_0289:  ldc.i4.6
    IL_028a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_028f:  nop
//000090:             this.lbTimeToComplete.AutoSize = true;
    IL_0290:  ldarg.0
    IL_0291:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_0296:  ldc.i4.1
    IL_0297:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_029c:  nop
//000091:             this.lbTimeToComplete.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
    IL_029d:  ldarg.0
    IL_029e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_02a3:  ldstr      "Microsoft Sans Serif"
    IL_02a8:  ldc.r4     8.25
    IL_02ad:  ldc.i4.1
    IL_02ae:  ldc.i4.3
    IL_02af:  ldc.i4.0
    IL_02b0:  newobj     instance void [System.Drawing]System.Drawing.Font::.ctor(string,
                                                                                  float32,
                                                                                  valuetype [System.Drawing]System.Drawing.FontStyle,
                                                                                  valuetype [System.Drawing]System.Drawing.GraphicsUnit,
                                                                                  uint8)
    IL_02b5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Font(class [System.Drawing]System.Drawing.Font)
    IL_02ba:  nop
//000092:             this.lbTimeToComplete.Location = new System.Drawing.Point(240, 376);
    IL_02bb:  ldarg.0
    IL_02bc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_02c1:  ldc.i4     0xf0
    IL_02c6:  ldc.i4     0x178
    IL_02cb:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_02d0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_02d5:  nop
//000093:             this.lbTimeToComplete.Name = "lbTimeToComplete";
    IL_02d6:  ldarg.0
    IL_02d7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_02dc:  ldstr      "lbTimeToComplete"
    IL_02e1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_02e6:  nop
//000094:             this.lbTimeToComplete.Size = new System.Drawing.Size(0, 13);
    IL_02e7:  ldarg.0
    IL_02e8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_02ed:  ldc.i4.0
    IL_02ee:  ldc.i4.s   13
    IL_02f0:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_02f5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_02fa:  nop
//000095:             this.lbTimeToComplete.TabIndex = 4;
    IL_02fb:  ldarg.0
    IL_02fc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_0301:  ldc.i4.4
    IL_0302:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0307:  nop
//000096:             // 
//000097:             // MainForm
//000098:             // 
//000099:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
    IL_0308:  ldarg.0
    IL_0309:  ldc.r4     6.
    IL_030e:  ldc.r4     13.
    IL_0313:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_0318:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_031d:  nop
//000100:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    IL_031e:  ldarg.0
    IL_031f:  ldc.i4.1
    IL_0320:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_0325:  nop
//000101:             this.ClientSize = new System.Drawing.Size(388, 401);
    IL_0326:  ldarg.0
    IL_0327:  ldc.i4     0x184
    IL_032c:  ldc.i4     0x191
    IL_0331:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0336:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_033b:  nop
//000102:             this.Controls.Add(this.lbTimeToComplete);
    IL_033c:  ldarg.0
    IL_033d:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0342:  ldarg.0
    IL_0343:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_0348:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_034d:  nop
//000103:             this.Controls.Add(this.btnRender);
    IL_034e:  ldarg.0
    IL_034f:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0354:  ldarg.0
    IL_0355:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_035a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_035f:  nop
//000104:             this.Controls.Add(this.rbPLINQ);
    IL_0360:  ldarg.0
    IL_0361:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0366:  ldarg.0
    IL_0367:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_036c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0371:  nop
//000105:             this.Controls.Add(this.rbLINQ);
    IL_0372:  ldarg.0
    IL_0373:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0378:  ldarg.0
    IL_0379:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_037e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0383:  nop
//000106:             this.Controls.Add(this.pbImage);
    IL_0384:  ldarg.0
    IL_0385:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_038a:  ldarg.0
    IL_038b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0390:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0395:  nop
//000107:             this.Name = "MainForm";
    IL_0396:  ldarg.0
    IL_0397:  ldstr      "MainForm"
    IL_039c:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_03a1:  nop
//000108:             this.Text = "LINQ Ray Tracer";
    IL_03a2:  ldarg.0
    IL_03a3:  ldstr      "LINQ Ray Tracer"
    IL_03a8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_03ad:  nop
//000109:             this.Load += new System.EventHandler(this.MainForm_Load);
    IL_03ae:  ldarg.0
    IL_03af:  ldarg.0
    IL_03b0:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::MainForm_Load(object,
                                                                                                                              class [mscorlib]System.EventArgs)
    IL_03b6:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_03bb:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::add_Load(class [mscorlib]System.EventHandler)
    IL_03c0:  nop
//000110:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
    IL_03c1:  ldarg.0
    IL_03c2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_03c7:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_03cc:  nop
//000111:             this.ResumeLayout(false);
    IL_03cd:  ldarg.0
    IL_03ce:  ldc.i4.0
    IL_03cf:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_03d4:  nop
//000112:             this.PerformLayout();
    IL_03d5:  ldarg.0
    IL_03d6:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_03db:  nop
//000113: 
//000114:         }
    IL_03dc:  ret
  } // end of method MainForm::InitializeComponent

  .method private hidebysig instance void 
          '<btnRender_Click>b__0'(class [mscorlib]System.Threading.Tasks.Task _) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       102 (0x66)
    .maxstack  2
    .locals init ([0] valuetype [mscorlib]System.TimeSpan CS$0$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs' 
//000062:                 {
    IL_0000:  nop
//000063:                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lbTimeToComplete
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [System]System.Diagnostics.Stopwatch Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_sw
    IL_000d:  callvirt   instance valuetype [mscorlib]System.TimeSpan [System]System.Diagnostics.Stopwatch::get_Elapsed()
    IL_0012:  stloc.0
    IL_0013:  ldloca.s   CS$0$0000
    IL_0015:  constrained. [mscorlib]System.TimeSpan
    IL_001b:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0020:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0025:  nop
//000064:                     btnRender.Enabled = true;
    IL_0026:  ldarg.0
    IL_0027:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_002c:  ldc.i4.1
    IL_002d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0032:  nop
//000065:                     btnRender.Text = "Render";
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnRender
    IL_0039:  ldstr      "Render"
    IL_003e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0043:  nop
//000066:                     rbLINQ.Enabled = true;
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbLINQ
    IL_004a:  ldc.i4.1
    IL_004b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0050:  nop
//000067:                     rbPLINQ.Enabled = true;
    IL_0051:  ldarg.0
    IL_0052:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::rbPLINQ
    IL_0057:  ldc.i4.1
    IL_0058:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_005d:  nop
//000068:                     _cancellation = null;
    IL_005e:  ldarg.0
    IL_005f:  ldnull
    IL_0060:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
//000069:                 }, _uiScheduler);
//000070:             }
//000071:             else
//000072:             {
//000073:                 btnRender.Enabled = false;
//000074:                 _cancellation.Cancel();
//000075:             }
//000076:         }
//000077: 
//000078:         private void BackgroundRender(object state)
//000079:         {
//000080:             var cancellationToken = (CancellationToken)state;
//000081:             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
//000082:             {
//000083:                 Task.Factory.StartNew(() =>
//000084:                 {
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000087:                     _image.UnlockBits(bmpData);
//000088:                     pbImage.Refresh();
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_0065:  ret
  } // end of method MainForm::'<btnRender_Click>b__0'

  .method private hidebysig instance void 
          '<BackgroundRender>b__2'(int32[] rgb) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       58 (0x3a)
    .maxstack  5
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4' 'CS$<>8__locals5')
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::rgb
    IL_000d:  ldloc.0
    IL_000e:  ldarg.0
    IL_000f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::'<>4__this'
//000082:             {
    IL_0014:  nop
//000083:                 Task.Factory.StartNew(() =>
    IL_0015:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_001a:  ldloc.0
    IL_001b:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass4'::'<BackgroundRender>b__3'()
    IL_0021:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_0026:  call       valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationToken::get_None()
    IL_002b:  ldc.i4.4
    IL_002c:  ldarg.0
    IL_002d:  ldfld      class [mscorlib]System.Threading.Tasks.TaskScheduler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_uiScheduler
    IL_0032:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action,
                                                                                                                                     valuetype [mscorlib]System.Threading.CancellationToken,
                                                                                                                                     valuetype [mscorlib]System.Threading.Tasks.TaskCreationOptions,
                                                                                                                                     class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_0037:  pop
//000084:                 {
//000085:                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
//000086:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000087:                     _image.UnlockBits(bmpData);
//000088:                     pbImage.Refresh();
//000089:                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
//000090:             });
    IL_0038:  nop
//000091: 
//000092:             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
//000093:             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
//000094:         }
//000095:     }
//000096: }
    IL_0039:  ret
  } // end of method MainForm::'<BackgroundRender>b__2'

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm

.class public auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer
       extends [mscorlib]System.Object
{
  .class auto ansi nested private beforefieldinit Wrap`1<T>
         extends [mscorlib]System.Object
  {
    .field public initonly class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<!T>,!T> It
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor(class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<!T>,!T> it) cil managed
    {
      // Code size       17 (0x11)
      .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs' 
//000039:             public Wrap(Func<Wrap<T>, T> it) { It = it; }
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  nop
      IL_0007:  nop
      IL_0008:  ldarg.0
      IL_0009:  ldarg.1
      IL_000a:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<!0>,!0> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<!T>::It
      IL_000f:  nop
      IL_0010:  ret
    } // end of method Wrap`1::.ctor

  } // end of class Wrap`1

  .class auto ansi nested private beforefieldinit TraceRayArgs
         extends [mscorlib]System.Object
  {
    .field public initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Ray
    .field public initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Scene
    .field public initonly int32 Depth
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray,
                                 class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                                 int32 depth) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  8
//000040:         }
//000041: 
//000042:         public static Func<T, U> Y<T, U>(Func<Func<T, U>, Func<T, U>> f)
//000043:         {
//000044:             Func<Wrap<Func<T, U>>, Func<T, U>> g = wx => f(wx.It(wx));
//000045:             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
//000046:         }
//000047: 
//000048:         class TraceRayArgs
//000049:         {
//000050:             public readonly Ray Ray;
//000051:             public readonly Scene Scene;
//000052:             public readonly int Depth;
//000053: 
//000054:             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  nop
      IL_0007:  nop
      IL_0008:  ldarg.0
      IL_0009:  ldarg.1
      IL_000a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Ray
      IL_000f:  ldarg.0
      IL_0010:  ldarg.2
      IL_0011:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
      IL_0016:  ldarg.0
      IL_0017:  ldarg.3
      IL_0018:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Depth
      IL_001d:  nop
      IL_001e:  ret
    } // end of method TraceRayArgs::.ctor

  } // end of class TraceRayArgs

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassb`2'<T,U>
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassd'<T,U>
           extends [mscorlib]System.Object
    {
      .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!T,!U> 'CS$<>8__localsc'
      .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!T,!U>> wx
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClassd'::.ctor

      .method public hidebysig instance !U 
              '<Y>b__a'(!T y) cil managed
      {
        // Code size       33 (0x21)
        .maxstack  2
        .locals init ([0] !U CS$1$0000)
//000045:             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
        IL_0000:  ldarg.0
        IL_0001:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!0,!1>> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'/'<>c__DisplayClassd'<!T,!U>::wx
        IL_0006:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<!0>,!0> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!T,!U>>::It
        IL_000b:  ldarg.0
        IL_000c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!0,!1>> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'/'<>c__DisplayClassd'<!T,!U>::wx
        IL_0011:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!T,!U>>,class [mscorlib]System.Func`2<!T,!U>>::Invoke(!0)
        IL_0016:  ldarg.1
        IL_0017:  callvirt   instance !1 class [mscorlib]System.Func`2<!T,!U>::Invoke(!0)
        IL_001c:  stloc.0
        IL_001d:  br.s       IL_001f

//000046:         }
//000047: 
//000048:         class TraceRayArgs
//000049:         {
//000050:             public readonly Ray Ray;
//000051:             public readonly Scene Scene;
//000052:             public readonly int Depth;
//000053: 
//000054:             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
//000055:         }
//000056: 
//000057:         internal void RenderSequential(Scene scene, CancellationToken cancellationToken)
//000058:         {
//000059:             int[] rgb = new int[screenWidth * screenHeight];
//000060: 
//000061:             var pixelsQuery =
//000062:                 from y in Enumerable.Range(0, screenHeight)
//000063:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000064:                 select from x in Enumerable.Range(0, screenWidth)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_001f:  ldloc.0
        IL_0020:  ret
      } // end of method '<>c__DisplayClassd'::'<Y>b__a'

    } // end of class '<>c__DisplayClassd'

    .field public class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!T,!U>,class [mscorlib]System.Func`2<!T,!U>> f
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassb`2'::.ctor

    .method public hidebysig instance class [mscorlib]System.Func`2<!T,!U> 
            '<Y>b__8'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!T,!U>> wx) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  3
      .locals init ([0] class [mscorlib]System.Func`2<!T,!U> CS$1$0000)
//000044:             Func<Wrap<Func<T, U>>, Func<T, U>> g = wx => f(wx.It(wx));
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!0,!1>,class [mscorlib]System.Func`2<!0,!1>> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!T,!U>::f
      IL_0006:  ldarg.1
      IL_0007:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<!0>,!0> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!T,!U>>::It
      IL_000c:  ldarg.1
      IL_000d:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!T,!U>>,class [mscorlib]System.Func`2<!T,!U>>::Invoke(!0)
      IL_0012:  callvirt   instance !1 class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!T,!U>,class [mscorlib]System.Func`2<!T,!U>>::Invoke(!0)
      IL_0017:  stloc.0
      IL_0018:  br.s       IL_001a

//000045:             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
//000046:         }
//000047: 
//000048:         class TraceRayArgs
//000049:         {
//000050:             public readonly Ray Ray;
//000051:             public readonly Scene Scene;
//000052:             public readonly int Depth;
//000053: 
//000054:             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
//000055:         }
//000056: 
//000057:         internal void RenderSequential(Scene scene, CancellationToken cancellationToken)
//000058:         {
//000059:             int[] rgb = new int[screenWidth * screenHeight];
//000060: 
//000061:             var pixelsQuery =
//000062:                 from y in Enumerable.Range(0, screenHeight)
//000063:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000064:                 select from x in Enumerable.Range(0, screenWidth)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_001a:  ldloc.0
      IL_001b:  ret
    } // end of method '<>c__DisplayClassb`2'::'<Y>b__8'

    .method public hidebysig instance class [mscorlib]System.Func`2<!T,!U> 
            '<Y>b__9'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!T,!U>> wx) cil managed
    {
      // Code size       48 (0x30)
      .maxstack  4
      .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'/'<>c__DisplayClassd'<!T,!U> 'CS$<>8__localse',
               [1] class [mscorlib]System.Func`2<!T,!U> CS$1$0000)
      IL_0000:  newobj     instance void class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'/'<>c__DisplayClassd'<!T,!U>::.ctor()
      IL_0005:  stloc.0
      IL_0006:  ldloc.0
      IL_0007:  ldarg.0
      IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!0,!1> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'/'<>c__DisplayClassd'<!T,!U>::'CS$<>8__localsc'
      IL_000d:  ldloc.0
      IL_000e:  ldarg.1
      IL_000f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!0,!1>> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'/'<>c__DisplayClassd'<!T,!U>::wx
//000045:             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
      IL_0014:  ldarg.0
      IL_0015:  ldfld      class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!0,!1>,class [mscorlib]System.Func`2<!0,!1>> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!T,!U>::f
      IL_001a:  ldloc.0
      IL_001b:  ldftn      instance !1 class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'/'<>c__DisplayClassd'<!T,!U>::'<Y>b__a'(!0)
      IL_0021:  newobj     instance void class [mscorlib]System.Func`2<!T,!U>::.ctor(object,
                                                                                     native int)
      IL_0026:  callvirt   instance !1 class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!T,!U>,class [mscorlib]System.Func`2<!T,!U>>::Invoke(!0)
      IL_002b:  stloc.1
      IL_002c:  br.s       IL_002e

//000046:         }
//000047: 
//000048:         class TraceRayArgs
//000049:         {
//000050:             public readonly Ray Ray;
//000051:             public readonly Scene Scene;
//000052:             public readonly int Depth;
//000053: 
//000054:             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
//000055:         }
//000056: 
//000057:         internal void RenderSequential(Scene scene, CancellationToken cancellationToken)
//000058:         {
//000059:             int[] rgb = new int[screenWidth * screenHeight];
//000060: 
//000061:             var pixelsQuery =
//000062:                 from y in Enumerable.Range(0, screenHeight)
//000063:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000064:                 select from x in Enumerable.Range(0, screenWidth)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_002e:  ldloc.1
      IL_002f:  ret
    } // end of method '<>c__DisplayClassb`2'::'<Y>b__9'

  } // end of class '<>c__DisplayClassb`2'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass50'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass54'
           extends [mscorlib]System.Object
    {
      .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' 'CS$<>8__locals51'
      .field public class '<>f__AnonymousType0`2'<int32,float64> '<>h__TransparentIdentifierf'
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClass54'::.ctor

      .method public hidebysig instance class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderSequential>b__2d'(class '<>f__AnonymousType1`2'<int32,float64> '<>h__TransparentIdentifier10') cil managed
      {
        // Code size       116 (0x74)
        .maxstack  5
        .locals init ([0] class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000066:                        let point =
        IL_0000:  ldarg.1
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'CS$<>8__locals51'
        IL_0007:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::scene
        IL_000c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_0011:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Forward
        IL_0016:  ldarg.1
        IL_0017:  callvirt   instance !1 class '<>f__AnonymousType1`2'<int32,float64>::get_recenterX()
        IL_001c:  ldarg.0
        IL_001d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'CS$<>8__locals51'
        IL_0022:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::scene
        IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_002c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Right
        IL_0031:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0036:  ldarg.0
        IL_0037:  ldfld      class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'<>h__TransparentIdentifierf'
        IL_003c:  callvirt   instance !1 class '<>f__AnonymousType0`2'<int32,float64>::get_recenterY()
        IL_0041:  ldarg.0
        IL_0042:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'CS$<>8__locals51'
        IL_0047:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::scene
        IL_004c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_0051:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Up
        IL_0056:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_005b:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0060:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0065:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_006a:  newobj     instance void class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                          !1)
        IL_006f:  stloc.0
        IL_0070:  br.s       IL_0072

//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0072:  ldloc.0
        IL_0073:  ret
      } // end of method '<>c__DisplayClass54'::'<RenderSequential>b__2d'

      .method public hidebysig instance class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> 
              '<RenderSequential>b__2e'(class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier11') cil managed
      {
        // Code size       57 (0x39)
        .maxstack  3
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray '<>g__initLocal27',
                 [1] class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> CS$1$0000)
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
        IL_0000:  ldarg.1
        IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor()
        IL_0006:  stloc.0
        IL_0007:  ldloc.0
        IL_0008:  ldarg.0
        IL_0009:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'CS$<>8__locals51'
        IL_000e:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::scene
        IL_0013:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_0018:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Pos
        IL_001d:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
        IL_0022:  ldloc.0
        IL_0023:  ldarg.1
        IL_0024:  callvirt   instance !1 class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_point()
        IL_0029:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
        IL_002e:  ldloc.0
        IL_002f:  newobj     instance void class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                  !1)
        IL_0034:  stloc.1
        IL_0035:  br.s       IL_0037

//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0037:  ldloc.1
        IL_0038:  ret
      } // end of method '<>c__DisplayClass54'::'<RenderSequential>b__2e'

      .method public hidebysig instance class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
              '<RenderSequential>b__4f'(class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> '<>h__TransparentIdentifier14') cil managed
      {
        // Code size       91 (0x5b)
        .maxstack  7
        .locals init ([0] class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
        IL_0000:  ldarg.1
        IL_0001:  callvirt   instance !0 class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier13'()
        IL_0006:  callvirt   instance !0 class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::'get_<>h__TransparentIdentifier12'()
        IL_000b:  callvirt   instance !0 class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier11'()
        IL_0010:  callvirt   instance !0 class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier10'()
        IL_0015:  callvirt   instance !0 class '<>f__AnonymousType1`2'<int32,float64>::get_x()
        IL_001a:  ldarg.0
        IL_001b:  ldfld      class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'<>h__TransparentIdentifierf'
        IL_0020:  callvirt   instance !0 class '<>f__AnonymousType0`2'<int32,float64>::get_y()
        IL_0025:  ldarg.1
        IL_0026:  callvirt   instance !1 class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::get_traceRay()
        IL_002b:  ldarg.1
        IL_002c:  callvirt   instance !0 class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier13'()
        IL_0031:  callvirt   instance !0 class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::'get_<>h__TransparentIdentifier12'()
        IL_0036:  callvirt   instance !1 class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::get_ray()
        IL_003b:  ldarg.0
        IL_003c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'CS$<>8__locals51'
        IL_0041:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::scene
        IL_0046:  ldc.i4.0
        IL_0047:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                        int32)
        IL_004c:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
        IL_0051:  newobj     instance void class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                         !1,
                                                                                                                                                                         !2)
        IL_0056:  stloc.0
        IL_0057:  br.s       IL_0059

//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0059:  ldloc.0
        IL_005a:  ret
      } // end of method '<>c__DisplayClass54'::'<RenderSequential>b__4f'

    } // end of class '<>c__DisplayClass54'

    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass57'
           extends [mscorlib]System.Object
    {
      .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass61'
             extends [mscorlib]System.Object
      {
        .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass69'
               extends [mscorlib]System.Object
        {
          .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass6d'
                 extends [mscorlib]System.Object
          {
            .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69' 'CS$<>8__locals6a'
            .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61' 'CS$<>8__locals62'
            .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' 'CS$<>8__locals58'
            .field public class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> '<>h__TransparentIdentifier1e'
            .method public hidebysig specialname rtspecialname 
                    instance void  .ctor() cil managed
            {
              // Code size       7 (0x7)
              .maxstack  8
              IL_0000:  ldarg.0
              IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
              IL_0006:  ret
            } // end of method '<>c__DisplayClass6d'::.ctor

            .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
                    '<RenderSequential>b__3e'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing) cil managed
            {
              // Code size       22 (0x16)
              .maxstack  2
              .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000)
//000089:                                                    select thing.Intersect(testRay)
              IL_0000:  ldarg.1
              IL_0001:  ldarg.0
              IL_0002:  ldfld      class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::'<>h__TransparentIdentifier1e'
              IL_0007:  callvirt   instance !1 class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::get_testRay()
              IL_000c:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray)
              IL_0011:  stloc.0
              IL_0012:  br.s       IL_0014

//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
              IL_0014:  ldloc.0
              IL_0015:  ret
            } // end of method '<>c__DisplayClass6d'::'<RenderSequential>b__3e'

          } // end of class '<>c__DisplayClass6d'

          .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61' 'CS$<>8__locals62'
          .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' 'CS$<>8__locals58'
          .field public class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier18'
          .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> 'CS$<>9__CachedAnonymousMethodDelegate6b'
          .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> 'CS$<>9__CachedAnonymousMethodDelegate6c'
          .method public hidebysig specialname rtspecialname 
                  instance void  .ctor() cil managed
          {
            // Code size       7 (0x7)
            .maxstack  8
            IL_0000:  ldarg.0
            IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
            IL_0006:  ret
          } // end of method '<>c__DisplayClass69'::.ctor

          .method public hidebysig instance class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
                  '<RenderSequential>b__3a'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light light) cil managed
          {
            // Code size       43 (0x2b)
            .maxstack  3
            .locals init ([0] class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
            IL_0007:  ldarg.0
            IL_0008:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_000d:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_0012:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
            IL_0017:  callvirt   instance !1 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_001c:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_0021:  newobj     instance void class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                            !1)
            IL_0026:  stloc.0
            IL_0027:  br.s       IL_0029

//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0029:  ldloc.0
            IL_002a:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__3a'

          .method public hidebysig instance class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> 
                  '<RenderSequential>b__3c'(class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier1d') cil managed
          {
            // Code size       57 (0x39)
            .maxstack  3
            .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray '<>g__initLocal28',
                     [1] class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> CS$1$0000)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
            IL_0000:  ldarg.1
            IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor()
            IL_0006:  stloc.0
            IL_0007:  ldloc.0
            IL_0008:  ldarg.0
            IL_0009:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_000e:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_0013:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
            IL_0018:  callvirt   instance !1 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_001d:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
            IL_0022:  ldloc.0
            IL_0023:  ldarg.1
            IL_0024:  callvirt   instance !1 class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_livec()
            IL_0029:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
            IL_002e:  ldloc.0
            IL_002f:  newobj     instance void class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                               !1)
            IL_0034:  stloc.1
            IL_0035:  br.s       IL_0037

//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0037:  ldloc.1
            IL_0038:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__3c'

          .method public hidebysig instance class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> 
                  '<RenderSequential>b__3d'(class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> '<>h__TransparentIdentifier1e') cil managed
          {
            // Code size       170 (0xaa)
            .maxstack  5
            .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d' 'CS$<>8__locals6e',
                     [1] class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> CS$1$0000)
            IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::.ctor()
            IL_0005:  stloc.0
            IL_0006:  ldloc.0
            IL_0007:  ldarg.0
            IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::'CS$<>8__locals6a'
            IL_000d:  ldloc.0
            IL_000e:  ldarg.0
            IL_000f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>8__locals62'
            IL_0014:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::'CS$<>8__locals62'
            IL_0019:  ldloc.0
            IL_001a:  ldarg.0
            IL_001b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>8__locals58'
            IL_0020:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::'CS$<>8__locals58'
            IL_0025:  ldloc.0
            IL_0026:  ldarg.1
            IL_0027:  stfld      class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::'<>h__TransparentIdentifier1e'
//000087:                               let testIsects = from inter in
            IL_002c:  ldloc.0
            IL_002d:  ldfld      class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::'<>h__TransparentIdentifier1e'
            IL_0032:  ldarg.0
            IL_0033:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>8__locals62'
            IL_0038:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
            IL_003d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
            IL_0042:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
            IL_0047:  ldloc.0
            IL_0048:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'/'<>c__DisplayClass6d'::'<RenderSequential>b__3e'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject)
            IL_004e:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::.ctor(object,
                                                                                                                                                                                                                                                 native int)
            IL_0053:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                        class [mscorlib]System.Func`2<!!0,!!1>)
            IL_0058:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>9__CachedAnonymousMethodDelegate6b'
            IL_005d:  brtrue.s   IL_0072

            IL_005f:  ldnull
            IL_0060:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__3f'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
            IL_0066:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool>::.ctor(object,
                                                                                                                                                                     native int)
            IL_006b:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>9__CachedAnonymousMethodDelegate6b'
            IL_0070:  br.s       IL_0072

            IL_0072:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>9__CachedAnonymousMethodDelegate6b'
            IL_0077:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::Where<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                      class [mscorlib]System.Func`2<!!0,bool>)
            IL_007c:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>9__CachedAnonymousMethodDelegate6c'
            IL_0081:  brtrue.s   IL_0096

            IL_0083:  ldnull
            IL_0084:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__40'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
            IL_008a:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>::.ctor(object,
                                                                                                                                                                        native int)
            IL_008f:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>9__CachedAnonymousMethodDelegate6c'
            IL_0094:  br.s       IL_0096

            IL_0096:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>9__CachedAnonymousMethodDelegate6c'
            IL_009b:  call       class [System.Core]System.Linq.IOrderedEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::OrderBy<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
            IL_00a0:  newobj     instance void class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              !1)
            IL_00a5:  stloc.1
            IL_00a6:  br.s       IL_00a8

//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_00a8:  ldloc.1
            IL_00a9:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__3d'

          .method public hidebysig instance class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> 
                  '<RenderSequential>b__45'(class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> '<>h__TransparentIdentifier22') cil managed
          {
            // Code size       63 (0x3f)
            .maxstack  3
            .locals init ([0] class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> CS$1$0000)
//000097:                               let illum = Vector.Dot(livec, normal)
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  callvirt   instance !0 class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier21'()
            IL_0007:  callvirt   instance !0 class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier20'()
            IL_000c:  callvirt   instance !0 class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier1f'()
            IL_0011:  callvirt   instance !0 class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier1e'()
            IL_0016:  callvirt   instance !0 class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier1d'()
            IL_001b:  callvirt   instance !1 class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_livec()
            IL_0020:  ldarg.0
            IL_0021:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_0026:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_002b:  callvirt   instance !1 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_normal()
            IL_0030:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_0035:  newobj     instance void class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          !1)
            IL_003a:  stloc.0
            IL_003b:  br.s       IL_003d

//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_003d:  ldloc.0
            IL_003e:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__45'

          .method public hidebysig instance class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> 
                  '<RenderSequential>b__47'(class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> '<>h__TransparentIdentifier24') cil managed
          {
            // Code size       73 (0x49)
            .maxstack  3
            .locals init ([0] class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> CS$1$0000)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  callvirt   instance !0 class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier23'()
            IL_0007:  callvirt   instance !0 class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::'get_<>h__TransparentIdentifier22'()
            IL_000c:  callvirt   instance !0 class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier21'()
            IL_0011:  callvirt   instance !0 class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier20'()
            IL_0016:  callvirt   instance !0 class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier1f'()
            IL_001b:  callvirt   instance !0 class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier1e'()
            IL_0020:  callvirt   instance !0 class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier1d'()
            IL_0025:  callvirt   instance !1 class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_livec()
            IL_002a:  ldarg.0
            IL_002b:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_0030:  callvirt   instance !1 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectDir()
            IL_0035:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_003a:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_003f:  newobj     instance void class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             !1)
            IL_0044:  stloc.0
            IL_0045:  br.s       IL_0047

//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0047:  ldloc.0
            IL_0048:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__47'

          .method public hidebysig instance class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
                  '<RenderSequential>b__48'(class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> '<>h__TransparentIdentifier25') cil managed
          {
            // Code size       175 (0xaf)
            .maxstack  4
            .locals init ([0] class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000100:                               let scolor = specular > 0
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  callvirt   instance !1 class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::get_specular()
            IL_0007:  ldc.r8     0.0
            IL_0010:  bgt.s      IL_0034

            IL_0012:  ldc.r8     0.0
            IL_001b:  ldc.r8     0.0
            IL_0024:  ldc.r8     0.0
            IL_002d:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                                       float64,
                                                                                                                                                                                       float64)
            IL_0032:  br.s       IL_00a5

            IL_0034:  ldarg.1
            IL_0035:  callvirt   instance !1 class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::get_specular()
            IL_003a:  ldarg.0
            IL_003b:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_0040:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_0045:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
            IL_004a:  callvirt   instance !0 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier15'()
            IL_004f:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
            IL_0054:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
            IL_0059:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
            IL_005e:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Roughness
            IL_0063:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                                    float64)
            IL_0068:  ldarg.1
            IL_0069:  callvirt   instance !0 class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::'get_<>h__TransparentIdentifier24'()
            IL_006e:  callvirt   instance !0 class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier23'()
            IL_0073:  callvirt   instance !0 class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::'get_<>h__TransparentIdentifier22'()
            IL_0078:  callvirt   instance !0 class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier21'()
            IL_007d:  callvirt   instance !0 class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier20'()
            IL_0082:  callvirt   instance !0 class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier1f'()
            IL_0087:  callvirt   instance !0 class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier1e'()
            IL_008c:  callvirt   instance !0 class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier1d'()
            IL_0091:  callvirt   instance !0 class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier1c'()
            IL_0096:  callvirt   instance !0 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_light()
            IL_009b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
            IL_00a0:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_00a5:  newobj     instance void class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        !1)
            IL_00aa:  stloc.0
            IL_00ab:  br.s       IL_00ad

//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_00ad:  ldloc.0
            IL_00ae:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__48'

          .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
                  '<RenderSequential>b__49'(class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> '<>h__TransparentIdentifier26') cil managed
          {
            // Code size       176 (0xb0)
            .maxstack  3
            .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
            IL_0000:  ldarg.0
            IL_0001:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_0006:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_000b:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
            IL_0010:  callvirt   instance !0 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier15'()
            IL_0015:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
            IL_001a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
            IL_001f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
            IL_0024:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Diffuse
            IL_0029:  ldarg.0
            IL_002a:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_002f:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_0034:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
            IL_0039:  callvirt   instance !1 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_003e:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
            IL_0043:  ldarg.1
            IL_0044:  callvirt   instance !0 class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier25'()
            IL_0049:  callvirt   instance !0 class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::'get_<>h__TransparentIdentifier24'()
            IL_004e:  callvirt   instance !1 class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_lcolor()
            IL_0053:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_0058:  ldarg.0
            IL_0059:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_005e:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_0063:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
            IL_0068:  callvirt   instance !0 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier15'()
            IL_006d:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
            IL_0072:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
            IL_0077:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
            IL_007c:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Specular
            IL_0081:  ldarg.0
            IL_0082:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
            IL_0087:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
            IL_008c:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
            IL_0091:  callvirt   instance !1 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_0096:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
            IL_009b:  ldarg.1
            IL_009c:  callvirt   instance !1 class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_scolor()
            IL_00a1:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_00a6:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_00ab:  stloc.0
            IL_00ac:  br.s       IL_00ae

//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_00ae:  ldloc.0
            IL_00af:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__49'

          .method private hidebysig static 
                  bool  '<RenderSequential>b__3f'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect inter) cil managed
          {
            // Code size       12 (0xc)
            .maxstack  2
            .locals init ([0] bool CS$1$0000)
//000090:                                                where inter != null
            IL_0000:  ldarg.0
            IL_0001:  ldnull
            IL_0002:  ceq
            IL_0004:  ldc.i4.0
            IL_0005:  ceq
            IL_0007:  stloc.0
            IL_0008:  br.s       IL_000a

//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_000a:  ldloc.0
            IL_000b:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__3f'

          .method private hidebysig static 
                  float64  '<RenderSequential>b__40'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect inter) cil managed
          {
            // Code size       11 (0xb)
            .maxstack  1
            .locals init ([0] float64 CS$1$0000)
//000091:                                                orderby inter.Dist
            IL_0000:  ldarg.0
            IL_0001:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
            IL_0006:  stloc.0
            IL_0007:  br.s       IL_0009

//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0009:  ldloc.0
            IL_000a:  ret
          } // end of method '<>c__DisplayClass69'::'<RenderSequential>b__40'

        } // end of class '<>c__DisplayClass69'

        .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' 'CS$<>8__locals58'
        .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs traceRayArgs
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegate63'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> 'CS$<>9__CachedAnonymousMethodDelegate64'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> 'CS$<>9__CachedAnonymousMethodDelegate65'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> 'CS$<>9__CachedAnonymousMethodDelegate66'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> 'CS$<>9__CachedAnonymousMethodDelegate67'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 'CS$<>9__CachedAnonymousMethodDelegate68'
        .method public hidebysig specialname rtspecialname 
                instance void  .ctor() cil managed
        {
          // Code size       7 (0x7)
          .maxstack  8
          IL_0000:  ldarg.0
          IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
          IL_0006:  ret
        } // end of method '<>c__DisplayClass61'::.ctor

        .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
                '<RenderSequential>b__32'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing) cil managed
        {
          // Code size       22 (0x16)
          .maxstack  2
          .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000)
//000075:                               select thing.Intersect(traceRayArgs.Ray)
          IL_0000:  ldarg.1
          IL_0001:  ldarg.0
          IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
          IL_0007:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Ray
          IL_000c:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray)
          IL_0011:  stloc.0
          IL_0012:  br.s       IL_0014

//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0014:  ldloc.0
          IL_0015:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__32'

        .method public hidebysig instance class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 
                '<RenderSequential>b__39'(class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier18') cil managed
        {
          // Code size       399 (0x18f)
          .maxstack  5
          .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69' 'CS$<>8__locals6a',
                   [1] class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$1$0000)
          IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::.ctor()
          IL_0005:  stloc.0
          IL_0006:  ldloc.0
          IL_0007:  ldarg.0
          IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>8__locals62'
          IL_000d:  ldloc.0
          IL_000e:  ldarg.0
          IL_000f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>8__locals58'
          IL_0014:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'CS$<>8__locals58'
          IL_0019:  ldloc.0
          IL_001a:  ldarg.1
          IL_001b:  stfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
//000082:                           let naturalColors =
          IL_0020:  ldloc.0
          IL_0021:  ldfld      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<>h__TransparentIdentifier18'
          IL_0026:  ldarg.0
          IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
          IL_002c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
          IL_0031:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Lights
          IL_0036:  ldloc.0
          IL_0037:  ldftn      instance class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__3a'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light)
          IL_003d:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                    native int)
          IL_0042:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0047:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate63'
          IL_004c:  brtrue.s   IL_0061

          IL_004e:  ldnull
          IL_004f:  ldftn      class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__3b'(class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
          IL_0055:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          native int)
          IL_005a:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate63'
          IL_005f:  br.s       IL_0061

          IL_0061:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate63'
          IL_0066:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 class [mscorlib]System.Func`2<!!0,!!1>)
          IL_006b:  ldloc.0
          IL_006c:  ldftn      instance class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__3c'(class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
          IL_0072:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             native int)
          IL_0077:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    class [mscorlib]System.Func`2<!!0,!!1>)
          IL_007c:  ldloc.0
          IL_007d:  ldftn      instance class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__3d'(class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>)
          IL_0083:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    native int)
          IL_0088:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
          IL_008d:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate64'
          IL_0092:  brtrue.s   IL_00a7

          IL_0094:  ldnull
          IL_0095:  ldftn      class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__41'(class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>)
          IL_009b:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             native int)
          IL_00a0:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate64'
          IL_00a5:  br.s       IL_00a7

          IL_00a7:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate64'
          IL_00ac:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    class [mscorlib]System.Func`2<!!0,!!1>)
          IL_00b1:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate65'
          IL_00b6:  brtrue.s   IL_00cb

          IL_00b8:  ldnull
          IL_00b9:  ldftn      class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__42'(class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>)
          IL_00bf:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              native int)
          IL_00c4:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate65'
          IL_00c9:  br.s       IL_00cb

          IL_00cb:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate65'
          IL_00d0:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     class [mscorlib]System.Func`2<!!0,!!1>)
          IL_00d5:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate66'
          IL_00da:  brtrue.s   IL_00ef

          IL_00dc:  ldnull
          IL_00dd:  ldftn      class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__43'(class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>)
          IL_00e3:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         native int)
          IL_00e8:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate66'
          IL_00ed:  br.s       IL_00ef

          IL_00ef:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate66'
          IL_00f4:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
          IL_00f9:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate67'
          IL_00fe:  brtrue.s   IL_0113

          IL_0100:  ldnull
          IL_0101:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__44'(class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>)
          IL_0107:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     native int)
          IL_010c:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate67'
          IL_0111:  br.s       IL_0113

          IL_0113:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate67'
          IL_0118:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::Where<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      class [mscorlib]System.Func`2<!!0,bool>)
          IL_011d:  ldloc.0
          IL_011e:  ldftn      instance class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__45'(class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>)
          IL_0124:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    native int)
          IL_0129:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
          IL_012e:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate68'
          IL_0133:  brtrue.s   IL_0148

          IL_0135:  ldnull
          IL_0136:  ldftn      class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__46'(class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>)
          IL_013c:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      native int)
          IL_0141:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate68'
          IL_0146:  br.s       IL_0148

          IL_0148:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>9__CachedAnonymousMethodDelegate68'
          IL_014d:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0152:  ldloc.0
          IL_0153:  ldftn      instance class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__47'(class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
          IL_0159:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         native int)
          IL_015e:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0163:  ldloc.0
          IL_0164:  ldftn      instance class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__48'(class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>)
          IL_016a:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            native int)
          IL_016f:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0174:  ldloc.0
          IL_0175:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'/'<>c__DisplayClass69'::'<RenderSequential>b__49'(class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
          IL_017b:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                native int)
          IL_0180:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType12`2'<class '<>f__AnonymousType11`2'<class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0185:  newobj     instance void class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                !1)
          IL_018a:  stloc.1
          IL_018b:  br.s       IL_018d

//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_018d:  ldloc.1
          IL_018e:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__39'

        .method public hidebysig instance class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
                '<RenderSequential>b__4b'(class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier1a') cil managed
        {
          // Code size       210 (0xd2)
          .maxstack  7
          .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray '<>g__initLocal29',
                   [1] class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
          IL_0000:  ldarg.1
          IL_0001:  ldarg.0
          IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
          IL_0007:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Depth
          IL_000c:  ldc.i4.5
          IL_000d:  bge        IL_00a8

          IL_0012:  ldarg.1
          IL_0013:  callvirt   instance !0 class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier19'()
          IL_0018:  callvirt   instance !0 class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier18'()
          IL_001d:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
          IL_0022:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
          IL_0027:  callvirt   instance !0 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier15'()
          IL_002c:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
          IL_0031:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
          IL_0036:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
          IL_003b:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Reflect
          IL_0040:  ldarg.1
          IL_0041:  callvirt   instance !1 class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectPos()
          IL_0046:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::Invoke(!0)
          IL_004b:  ldarg.0
          IL_004c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>8__locals58'
          IL_0051:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::f
          IL_0056:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor()
          IL_005b:  stloc.0
          IL_005c:  ldloc.0
          IL_005d:  ldarg.1
          IL_005e:  callvirt   instance !1 class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectPos()
          IL_0063:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
          IL_0068:  ldloc.0
          IL_0069:  ldarg.1
          IL_006a:  callvirt   instance !0 class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier19'()
          IL_006f:  callvirt   instance !0 class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier18'()
          IL_0074:  callvirt   instance !1 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectDir()
          IL_0079:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
          IL_007e:  ldloc.0
          IL_007f:  ldarg.0
          IL_0080:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
          IL_0085:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
          IL_008a:  ldarg.0
          IL_008b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
          IL_0090:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Depth
          IL_0095:  ldc.i4.1
          IL_0096:  add
          IL_0097:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                          int32)
          IL_009c:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
          IL_00a1:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
          IL_00a6:  br.s       IL_00c8

          IL_00a8:  ldc.r8     0.5
          IL_00b1:  ldc.r8     0.5
          IL_00ba:  ldc.r8     0.5
          IL_00c3:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                                     float64,
                                                                                                                                                                                     float64)
          IL_00c8:  newobj     instance void class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       !1)
          IL_00cd:  stloc.1
          IL_00ce:  br.s       IL_00d0

//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_00d0:  ldloc.1
          IL_00d1:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__4b'

        .method private hidebysig static 
                class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
                '<RenderSequential>b__3b'(class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier1c') cil managed
        {
          // Code size       22 (0x16)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000085:                               let livec = Vector.Norm(ldis)
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_ldis()
          IL_0007:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
          IL_000c:  newobj     instance void class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                     !1)
          IL_0011:  stloc.0
          IL_0012:  br.s       IL_0014

//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0014:  ldloc.0
          IL_0015:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__3b'

        .method private hidebysig static 
                class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> 
                '<RenderSequential>b__41'(class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> '<>h__TransparentIdentifier1f') cil managed
        {
          // Code size       22 (0x16)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> CS$1$0000)
//000093:                               let testIsect = testIsects.FirstOrDefault()
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::get_testIsects()
          IL_0007:  call       !!0 [System.Core]System.Linq.Enumerable::FirstOrDefault<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
          IL_000c:  newobj     instance void class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      !1)
          IL_0011:  stloc.0
          IL_0012:  br.s       IL_0014

//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0014:  ldloc.0
          IL_0015:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__41'

        .method private hidebysig static 
                class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> 
                '<RenderSequential>b__42'(class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> '<>h__TransparentIdentifier20') cil managed
        {
          // Code size       41 (0x29)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> CS$1$0000)
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::get_testIsect()
          IL_0007:  brfalse.s  IL_0016

          IL_0009:  ldarg.0
          IL_000a:  callvirt   instance !1 class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::get_testIsect()
          IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
          IL_0014:  br.s       IL_001f

          IL_0016:  ldc.r8     0.0
          IL_001f:  newobj     instance void class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             !1)
          IL_0024:  stloc.0
          IL_0025:  br.s       IL_0027

//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0027:  ldloc.0
          IL_0028:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__42'

        .method private hidebysig static 
                class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> 
                '<RenderSequential>b__43'(class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> '<>h__TransparentIdentifier21') cil managed
        {
          // Code size       78 (0x4e)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> CS$1$0000)
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::get_neatIsect()
          IL_0007:  ldarg.0
          IL_0008:  callvirt   instance !0 class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier20'()
          IL_000d:  callvirt   instance !0 class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier1f'()
          IL_0012:  callvirt   instance !0 class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier1e'()
          IL_0017:  callvirt   instance !0 class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier1d'()
          IL_001c:  callvirt   instance !0 class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier1c'()
          IL_0021:  callvirt   instance !1 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_ldis()
          IL_0026:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Mag(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
          IL_002b:  bgt.s      IL_0043

          IL_002d:  ldarg.0
          IL_002e:  callvirt   instance !1 class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::get_neatIsect()
          IL_0033:  ldc.r8     0.0
          IL_003c:  ceq
          IL_003e:  ldc.i4.0
          IL_003f:  ceq
          IL_0041:  br.s       IL_0044

          IL_0043:  ldc.i4.0
          IL_0044:  newobj     instance void class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 !1)
          IL_0049:  stloc.0
          IL_004a:  br.s       IL_004c

//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_004c:  ldloc.0
          IL_004d:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__43'

        .method private hidebysig static 
                bool  '<RenderSequential>b__44'(class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> '<>h__TransparentIdentifier22') cil managed
        {
          // Code size       14 (0xe)
          .maxstack  2
          .locals init ([0] bool CS$1$0000)
//000096:                               where !isInShadow
          IL_0000:  ldarg.0
          IL_0001:  callvirt   instance !1 class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::get_isInShadow()
          IL_0006:  ldc.i4.0
          IL_0007:  ceq
          IL_0009:  stloc.0
          IL_000a:  br.s       IL_000c

//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_000c:  ldloc.0
          IL_000d:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__44'

        .method private hidebysig static 
                class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
                '<RenderSequential>b__46'(class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> '<>h__TransparentIdentifier23') cil managed
        {
          // Code size       119 (0x77)
          .maxstack  4
          .locals init ([0] class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::get_illum()
          IL_0007:  ldc.r8     0.0
          IL_0010:  bgt.s      IL_0034

          IL_0012:  ldc.r8     0.0
          IL_001b:  ldc.r8     0.0
          IL_0024:  ldc.r8     0.0
          IL_002d:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                                     float64,
                                                                                                                                                                                     float64)
          IL_0032:  br.s       IL_006d

          IL_0034:  ldarg.0
          IL_0035:  callvirt   instance !1 class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::get_illum()
          IL_003a:  ldarg.0
          IL_003b:  callvirt   instance !0 class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::'get_<>h__TransparentIdentifier22'()
          IL_0040:  callvirt   instance !0 class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier21'()
          IL_0045:  callvirt   instance !0 class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier20'()
          IL_004a:  callvirt   instance !0 class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier1f'()
          IL_004f:  callvirt   instance !0 class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier1e'()
          IL_0054:  callvirt   instance !0 class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier1d'()
          IL_0059:  callvirt   instance !0 class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier1c'()
          IL_005e:  callvirt   instance !0 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_light()
          IL_0063:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
          IL_0068:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
          IL_006d:  newobj     instance void class '<>f__AnonymousType10`2'<class '<>f__AnonymousTypef`2'<class '<>f__AnonymousTypee`2'<class '<>f__AnonymousTyped`2'<class '<>f__AnonymousTypec`2'<class '<>f__AnonymousTypeb`2'<class '<>f__AnonymousTypea`2'<class '<>f__AnonymousType9`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   !1)
          IL_0072:  stloc.0
          IL_0073:  br.s       IL_0075

//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0075:  ldloc.0
          IL_0076:  ret
        } // end of method '<>c__DisplayClass61'::'<RenderSequential>b__46'

      } // end of class '<>c__DisplayClass61'

      .field public class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> f
      .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> 'CS$<>9__CachedAnonymousMethodDelegate59'
      .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> 'CS$<>9__CachedAnonymousMethodDelegate5a'
      .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegate5b'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegate5c'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegate5d'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegate5e'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegate5f'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegate60'
      .field private static class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegate6f'
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClass57'::.ctor

      .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
              '<RenderSequential>b__31'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs traceRayArgs) cil managed
      {
        // Code size       395 (0x18b)
        .maxstack  4
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61' 'CS$<>8__locals62',
                 [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
        IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::.ctor()
        IL_0005:  stloc.0
        IL_0006:  ldloc.0
        IL_0007:  ldarg.0
        IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'CS$<>8__locals58'
        IL_000d:  ldloc.0
        IL_000e:  ldarg.1
        IL_000f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
//000073:                          (from isect in
        IL_0014:  ldloc.0
        IL_0015:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::traceRayArgs
        IL_001a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
        IL_001f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
        IL_0024:  ldloc.0
        IL_0025:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__32'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject)
        IL_002b:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::.ctor(object,
                                                                                                                                                                                                                                             native int)
        IL_0030:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                    class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0035:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate59'
        IL_003a:  brtrue.s   IL_004f

        IL_003c:  ldnull
        IL_003d:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__33'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
        IL_0043:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool>::.ctor(object,
                                                                                                                                                                 native int)
        IL_0048:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate59'
        IL_004d:  br.s       IL_004f

        IL_004f:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate59'
        IL_0054:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::Where<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                  class [mscorlib]System.Func`2<!!0,bool>)
        IL_0059:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5a'
        IL_005e:  brtrue.s   IL_0073

        IL_0060:  ldnull
        IL_0061:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__34'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
        IL_0067:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>::.ctor(object,
                                                                                                                                                                    native int)
        IL_006c:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5a'
        IL_0071:  br.s       IL_0073

        IL_0073:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5a'
        IL_0078:  call       class [System.Core]System.Linq.IOrderedEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::OrderBy<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                       class [mscorlib]System.Func`2<!!0,!!1>)
        IL_007d:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5b'
        IL_0082:  brtrue.s   IL_0097

        IL_0084:  ldnull
        IL_0085:  ldftn      class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__35'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
        IL_008b:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                  native int)
        IL_0090:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5b'
        IL_0095:  br.s       IL_0097

        IL_0097:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5b'
        IL_009c:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
        IL_00a1:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5c'
        IL_00a6:  brtrue.s   IL_00bb

        IL_00a8:  ldnull
        IL_00a9:  ldftn      class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__36'(class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_00af:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        native int)
        IL_00b4:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5c'
        IL_00b9:  br.s       IL_00bb

        IL_00bb:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5c'
        IL_00c0:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               class [mscorlib]System.Func`2<!!0,!!1>)
        IL_00c5:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5d'
        IL_00ca:  brtrue.s   IL_00df

        IL_00cc:  ldnull
        IL_00cd:  ldftn      class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__37'(class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_00d3:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              native int)
        IL_00d8:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5d'
        IL_00dd:  br.s       IL_00df

        IL_00df:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5d'
        IL_00e4:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     class [mscorlib]System.Func`2<!!0,!!1>)
        IL_00e9:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5e'
        IL_00ee:  brtrue.s   IL_0103

        IL_00f0:  ldnull
        IL_00f1:  ldftn      class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__38'(class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_00f7:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    native int)
        IL_00fc:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5e'
        IL_0101:  br.s       IL_0103

        IL_0103:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5e'
        IL_0108:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
        IL_010d:  ldloc.0
        IL_010e:  ldftn      instance class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__39'(class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_0114:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    native int)
        IL_0119:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
        IL_011e:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5f'
        IL_0123:  brtrue.s   IL_0138

        IL_0125:  ldnull
        IL_0126:  ldftn      class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__4a'(class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>)
        IL_012c:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     native int)
        IL_0131:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5f'
        IL_0136:  br.s       IL_0138

        IL_0138:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate5f'
        IL_013d:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0142:  ldloc.0
        IL_0143:  ldftn      instance class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'/'<>c__DisplayClass61'::'<RenderSequential>b__4b'(class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_0149:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            native int)
        IL_014e:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0153:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate60'
        IL_0158:  brtrue.s   IL_016d

        IL_015a:  ldnull
        IL_015b:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__4c'(class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
        IL_0161:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               native int)
        IL_0166:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate60'
        IL_016b:  br.s       IL_016d

        IL_016d:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate60'
        IL_0172:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0177:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Background
        IL_017c:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::DefaultIfEmpty<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                           !!0)
        IL_0181:  call       !!0 [System.Core]System.Linq.Enumerable::First<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
        IL_0186:  stloc.1
        IL_0187:  br.s       IL_0189

//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0189:  ldloc.1
        IL_018a:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__31'

      .method private hidebysig static bool 
              '<RenderSequential>b__33'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect) cil managed
      {
        // Code size       12 (0xc)
        .maxstack  2
        .locals init ([0] bool CS$1$0000)
//000076:                           where isect != null
        IL_0000:  ldarg.0
        IL_0001:  ldnull
        IL_0002:  ceq
        IL_0004:  ldc.i4.0
        IL_0005:  ceq
        IL_0007:  stloc.0
        IL_0008:  br.s       IL_000a

//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_000a:  ldloc.0
        IL_000b:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__33'

      .method private hidebysig static float64 
              '<RenderSequential>b__34'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect) cil managed
      {
        // Code size       11 (0xb)
        .maxstack  1
        .locals init ([0] float64 CS$1$0000)
//000077:                           orderby isect.Dist
        IL_0000:  ldarg.0
        IL_0001:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
        IL_0006:  stloc.0
        IL_0007:  br.s       IL_0009

//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0009:  ldloc.0
        IL_000a:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__34'

      .method private hidebysig static class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderSequential>b__35'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect) cil managed
      {
        // Code size       22 (0x16)
        .maxstack  3
        .locals init ([0] class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000078:                           let d = isect.Ray.Dir
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
        IL_0007:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
        IL_000c:  newobj     instance void class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                        !1)
        IL_0011:  stloc.0
        IL_0012:  br.s       IL_0014

//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0014:  ldloc.0
        IL_0015:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__35'

      .method private hidebysig static class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderSequential>b__36'(class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier15') cil managed
      {
        // Code size       64 (0x40)
        .maxstack  3
        .locals init ([0] class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_0007:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
        IL_000c:  ldarg.0
        IL_000d:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_0012:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
        IL_0017:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
        IL_001c:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0021:  ldarg.0
        IL_0022:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
        IL_002c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
        IL_0031:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0036:  newobj     instance void class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                   !1)
        IL_003b:  stloc.0
        IL_003c:  br.s       IL_003e

//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_003e:  ldloc.0
        IL_003f:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__36'

      .method private hidebysig static class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderSequential>b__37'(class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier16') cil managed
      {
        // Code size       38 (0x26)
        .maxstack  3
        .locals init ([0] class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000080:                           let normal = isect.Thing.Normal(pos)
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier15'()
        IL_0007:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_000c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
        IL_0011:  ldarg.0
        IL_0012:  callvirt   instance !1 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
        IL_0017:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Normal(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_001c:  newobj     instance void class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              !1)
        IL_0021:  stloc.0
        IL_0022:  br.s       IL_0024

//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0024:  ldloc.0
        IL_0025:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__37'

      .method private hidebysig static class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderSequential>b__38'(class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier17') cil managed
      {
        // Code size       80 (0x50)
        .maxstack  5
        .locals init ([0] class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
        IL_0007:  callvirt   instance !0 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier15'()
        IL_000c:  callvirt   instance !1 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_d()
        IL_0011:  ldc.r8     2.
        IL_001a:  ldarg.0
        IL_001b:  callvirt   instance !1 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_normal()
        IL_0020:  ldarg.0
        IL_0021:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
        IL_0026:  callvirt   instance !0 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier15'()
        IL_002b:  callvirt   instance !1 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_d()
        IL_0030:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0035:  mul
        IL_0036:  ldarg.0
        IL_0037:  callvirt   instance !1 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_normal()
        IL_003c:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0041:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0046:  newobj     instance void class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         !1)
        IL_004b:  stloc.0
        IL_004c:  br.s       IL_004e

//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_004e:  ldloc.0
        IL_004f:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__38'

      .method private hidebysig static class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderSequential>b__4a'(class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> '<>h__TransparentIdentifier19') cil managed
      {
        // Code size       62 (0x3e)
        .maxstack  4
        .locals init ([0] class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier18'()
        IL_0007:  callvirt   instance !0 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier17'()
        IL_000c:  callvirt   instance !0 class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier16'()
        IL_0011:  callvirt   instance !1 class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
        IL_0016:  ldc.r8     1.e-003
        IL_001f:  ldarg.0
        IL_0020:  callvirt   instance !0 class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier18'()
        IL_0025:  callvirt   instance !1 class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectDir()
        IL_002a:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_002f:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0034:  newobj     instance void class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          !1)
        IL_0039:  stloc.0
        IL_003a:  br.s       IL_003c

//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_003c:  ldloc.0
        IL_003d:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__4a'

      .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
              '<RenderSequential>b__4c'(class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> '<>h__TransparentIdentifier1b') cil managed
      {
        // Code size       63 (0x3f)
        .maxstack  5
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000117:                           select naturalColors.Aggregate(reflectColor,
        IL_0000:  ldarg.0
        IL_0001:  callvirt   instance !0 class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier1a'()
        IL_0006:  callvirt   instance !0 class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier19'()
        IL_000b:  callvirt   instance !1 class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::get_naturalColors()
        IL_0010:  ldarg.0
        IL_0011:  callvirt   instance !1 class '<>f__AnonymousType15`2'<class '<>f__AnonymousType14`2'<class '<>f__AnonymousType13`2'<class '<>f__AnonymousType7`2'<class '<>f__AnonymousType6`2'<class '<>f__AnonymousType5`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_reflectColor()
        IL_0016:  ldsfld     class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate6f'
        IL_001b:  brtrue.s   IL_0030

        IL_001d:  ldnull
        IL_001e:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__4d'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
        IL_0024:  newobj     instance void class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                                                                                  native int)
        IL_0029:  stsfld     class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate6f'
        IL_002e:  br.s       IL_0030

        IL_0030:  ldsfld     class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'CS$<>9__CachedAnonymousMethodDelegate6f'
        IL_0035:  call       !!1 [System.Core]System.Linq.Enumerable::Aggregate<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                       !!1,
                                                                                                                                                                                                                                       class [mscorlib]System.Func`3<!!1,!!0,!!1>)
        IL_003a:  stloc.0
        IL_003b:  br.s       IL_003d

//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_003d:  ldloc.0
        IL_003e:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__4c'

      .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
              '<RenderSequential>b__4d'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color color,
                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color natColor) cil managed
      {
        // Code size       12 (0xc)
        .maxstack  2
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
        IL_0000:  ldarg.0
        IL_0001:  ldarg.1
        IL_0002:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
        IL_0007:  stloc.0
        IL_0008:  br.s       IL_000a

//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_000a:  ldloc.0
        IL_000b:  ret
      } // end of method '<>c__DisplayClass57'::'<RenderSequential>b__4d'

    } // end of class '<>c__DisplayClass57'

    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer '<>4__this'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene
    .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> 'CS$<>9__CachedAnonymousMethodDelegate52'
    .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> 'CS$<>9__CachedAnonymousMethodDelegate53'
    .field private static class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 'CS$<>9__CachedAnonymousMethodDelegate56'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass50'::.ctor

    .method public hidebysig instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 
            '<RenderSequential>b__2b'(class '<>f__AnonymousType0`2'<int32,float64> '<>h__TransparentIdentifierf') cil managed
    {
      // Code size       182 (0xb6)
      .maxstack  4
      .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54' 'CS$<>8__locals55',
               [1] class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$1$0000)
      IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::.ctor()
      IL_0005:  stloc.0
      IL_0006:  ldloc.0
      IL_0007:  ldarg.0
      IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'CS$<>8__locals51'
      IL_000d:  ldloc.0
      IL_000e:  ldarg.1
      IL_000f:  stfld      class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'<>h__TransparentIdentifierf'
//000064:                 select from x in Enumerable.Range(0, screenWidth)
      IL_0014:  ldc.i4.0
      IL_0015:  ldarg.0
      IL_0016:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<>4__this'
      IL_001b:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_0020:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                      int32)
      IL_0025:  ldarg.0
      IL_0026:  ldftn      instance class '<>f__AnonymousType1`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<RenderSequential>b__2c'(int32)
      IL_002c:  newobj     instance void class [mscorlib]System.Func`2<int32,class '<>f__AnonymousType1`2'<int32,float64>>::.ctor(object,
                                                                                                                                  native int)
      IL_0031:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,class '<>f__AnonymousType1`2'<int32,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
      IL_0036:  ldloc.0
      IL_0037:  ldftn      instance class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'<RenderSequential>b__2d'(class '<>f__AnonymousType1`2'<int32,float64>)
      IL_003d:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1`2'<int32,float64>,class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                    native int)
      IL_0042:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1`2'<int32,float64>,class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
      IL_0047:  ldloc.0
      IL_0048:  ldftn      instance class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'<RenderSequential>b__2e'(class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
      IL_004e:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       native int)
      IL_0053:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              class [mscorlib]System.Func`2<!!0,!!1>)
      IL_0058:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate52'
      IL_005d:  brtrue.s   IL_0072

      IL_005f:  ldnull
      IL_0060:  ldftn      class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<RenderSequential>b__2f'(class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>)
      IL_0066:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          native int)
      IL_006b:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate52'
      IL_0070:  br.s       IL_0072

      IL_0072:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate52'
      IL_0077:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 class [mscorlib]System.Func`2<!!0,!!1>)
      IL_007c:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate53'
      IL_0081:  brtrue.s   IL_0096

      IL_0083:  ldnull
      IL_0084:  ldftn      class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<RenderSequential>b__4e'(class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>)
      IL_008a:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           native int)
      IL_008f:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate53'
      IL_0094:  br.s       IL_0096

      IL_0096:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate53'
      IL_009b:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  class [mscorlib]System.Func`2<!!0,!!1>)
      IL_00a0:  ldloc.0
      IL_00a1:  ldftn      instance class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass54'::'<RenderSequential>b__4f'(class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>)
      IL_00a7:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       native int)
      IL_00ac:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              class [mscorlib]System.Func`2<!!0,!!1>)
      IL_00b1:  stloc.1
      IL_00b2:  br.s       IL_00b4

//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_00b4:  ldloc.1
      IL_00b5:  ret
    } // end of method '<>c__DisplayClass50'::'<RenderSequential>b__2b'

    .method private hidebysig instance class '<>f__AnonymousType1`2'<int32,float64> 
            '<RenderSequential>b__2c'(int32 x) cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  4
      .locals init ([0] class '<>f__AnonymousType1`2'<int32,float64> CS$1$0000)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
      IL_0000:  ldarg.1
      IL_0001:  ldarg.1
      IL_0002:  conv.r8
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<>4__this'
      IL_0009:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_000e:  conv.r8
      IL_000f:  ldc.r8     2.
      IL_0018:  div
      IL_0019:  sub
      IL_001a:  ldc.r8     2.
      IL_0023:  ldarg.0
      IL_0024:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<>4__this'
      IL_0029:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_002e:  conv.r8
      IL_002f:  mul
      IL_0030:  div
      IL_0031:  newobj     instance void class '<>f__AnonymousType1`2'<int32,float64>::.ctor(!0,
                                                                                             !1)
      IL_0036:  stloc.0
      IL_0037:  br.s       IL_0039

//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0039:  ldloc.0
      IL_003a:  ret
    } // end of method '<>c__DisplayClass50'::'<RenderSequential>b__2c'

    .method private hidebysig static class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> 
            '<RenderSequential>b__2f'(class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> '<>h__TransparentIdentifier12') cil managed
    {
      // Code size       42 (0x2a)
      .maxstack  4
      .locals init ([0] class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> CS$1$0000)
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
      IL_0000:  ldarg.0
      IL_0001:  ldsfld     class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate56'
      IL_0006:  brtrue.s   IL_001b

      IL_0008:  ldnull
      IL_0009:  ldftn      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<RenderSequential>b__30'(class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
      IL_000f:  newobj     instance void class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           native int)
      IL_0014:  stsfld     class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate56'
      IL_0019:  br.s       IL_001b

      IL_001b:  ldsfld     class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'CS$<>9__CachedAnonymousMethodDelegate56'
      IL_0020:  newobj     instance void class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           !1)
      IL_0025:  stloc.0
      IL_0026:  br.s       IL_0028

//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0028:  ldloc.0
      IL_0029:  ret
    } // end of method '<>c__DisplayClass50'::'<RenderSequential>b__2f'

    .method private hidebysig static class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 
            '<RenderSequential>b__4e'(class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> '<>h__TransparentIdentifier13') cil managed
    {
      // Code size       22 (0x16)
      .maxstack  3
      .locals init ([0] class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$1$0000)
//000120:                        let traceRay = Y(computeTraceRay)
      IL_0000:  ldarg.0
      IL_0001:  ldarg.0
      IL_0002:  callvirt   instance !1 class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::get_computeTraceRay()
      IL_0007:  call       class [mscorlib]System.Func`2<!!0,!!1> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::Y<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!!0,!!1>,class [mscorlib]System.Func`2<!!0,!!1>>)
      IL_000c:  newobj     instance void class '<>f__AnonymousType17`2'<class '<>f__AnonymousType16`2'<class '<>f__AnonymousType3`2'<class '<>f__AnonymousType2`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 !1)
      IL_0011:  stloc.0
      IL_0012:  br.s       IL_0014

//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0014:  ldloc.0
      IL_0015:  ret
    } // end of method '<>c__DisplayClass50'::'<RenderSequential>b__4e'

    .method private hidebysig static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
            '<RenderSequential>b__30'(class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> f) cil managed
    {
      // Code size       30 (0x1e)
      .maxstack  3
      .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57' 'CS$<>8__locals58',
               [1] class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
      IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::.ctor()
      IL_0005:  stloc.0
      IL_0006:  ldloc.0
      IL_0007:  ldarg.0
      IL_0008:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::f
//000072:                         (f => traceRayArgs =>
      IL_000d:  ldloc.0
      IL_000e:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'/'<>c__DisplayClass57'::'<RenderSequential>b__31'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs)
      IL_0014:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                      native int)
      IL_0019:  stloc.1
      IL_001a:  br.s       IL_001c

//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_001c:  ldloc.1
      IL_001d:  ret
    } // end of method '<>c__DisplayClass50'::'<RenderSequential>b__30'

  } // end of class '<>c__DisplayClass50'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassc9'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClasscd'
           extends [mscorlib]System.Object
    {
      .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' 'CS$<>8__localsca'
      .field public class '<>f__AnonymousType0`2'<int32,float64> '<>h__TransparentIdentifier70'
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClasscd'::.ctor

      .method public hidebysig instance class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderParallel>b__a5'(class '<>f__AnonymousType1`2'<int32,float64> '<>h__TransparentIdentifier71') cil managed
      {
        // Code size       116 (0x74)
        .maxstack  5
        .locals init ([0] class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000149:                        let point =
        IL_0000:  ldarg.1
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'CS$<>8__localsca'
        IL_0007:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::scene
        IL_000c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_0011:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Forward
        IL_0016:  ldarg.1
        IL_0017:  callvirt   instance !1 class '<>f__AnonymousType1`2'<int32,float64>::get_recenterX()
        IL_001c:  ldarg.0
        IL_001d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'CS$<>8__localsca'
        IL_0022:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::scene
        IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_002c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Right
        IL_0031:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0036:  ldarg.0
        IL_0037:  ldfld      class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'<>h__TransparentIdentifier70'
        IL_003c:  callvirt   instance !1 class '<>f__AnonymousType0`2'<int32,float64>::get_recenterY()
        IL_0041:  ldarg.0
        IL_0042:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'CS$<>8__localsca'
        IL_0047:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::scene
        IL_004c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_0051:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Up
        IL_0056:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_005b:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0060:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0065:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_006a:  newobj     instance void class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                           !1)
        IL_006f:  stloc.0
        IL_0070:  br.s       IL_0072

//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0072:  ldloc.0
        IL_0073:  ret
      } // end of method '<>c__DisplayClasscd'::'<RenderParallel>b__a5'

      .method public hidebysig instance class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> 
              '<RenderParallel>b__a6'(class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier72') cil managed
      {
        // Code size       57 (0x39)
        .maxstack  3
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray '<>g__initLocal9f',
                 [1] class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> CS$1$0000)
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
        IL_0000:  ldarg.1
        IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor()
        IL_0006:  stloc.0
        IL_0007:  ldloc.0
        IL_0008:  ldarg.0
        IL_0009:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'CS$<>8__localsca'
        IL_000e:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::scene
        IL_0013:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
        IL_0018:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Pos
        IL_001d:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
        IL_0022:  ldloc.0
        IL_0023:  ldarg.1
        IL_0024:  callvirt   instance !1 class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_point()
        IL_0029:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
        IL_002e:  ldloc.0
        IL_002f:  newobj     instance void class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                    !1)
        IL_0034:  stloc.1
        IL_0035:  br.s       IL_0037

//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0037:  ldloc.1
        IL_0038:  ret
      } // end of method '<>c__DisplayClasscd'::'<RenderParallel>b__a6'

      .method public hidebysig instance class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
              '<RenderParallel>b__c7'(class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> '<>h__TransparentIdentifier75') cil managed
      {
        // Code size       91 (0x5b)
        .maxstack  7
        .locals init ([0] class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
        IL_0000:  ldarg.1
        IL_0001:  callvirt   instance !0 class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier74'()
        IL_0006:  callvirt   instance !0 class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::'get_<>h__TransparentIdentifier73'()
        IL_000b:  callvirt   instance !0 class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier72'()
        IL_0010:  callvirt   instance !0 class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier71'()
        IL_0015:  callvirt   instance !0 class '<>f__AnonymousType1`2'<int32,float64>::get_x()
        IL_001a:  ldarg.0
        IL_001b:  ldfld      class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'<>h__TransparentIdentifier70'
        IL_0020:  callvirt   instance !0 class '<>f__AnonymousType0`2'<int32,float64>::get_y()
        IL_0025:  ldarg.1
        IL_0026:  callvirt   instance !1 class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::get_traceRay()
        IL_002b:  ldarg.1
        IL_002c:  callvirt   instance !0 class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier74'()
        IL_0031:  callvirt   instance !0 class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::'get_<>h__TransparentIdentifier73'()
        IL_0036:  callvirt   instance !1 class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::get_ray()
        IL_003b:  ldarg.0
        IL_003c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'CS$<>8__localsca'
        IL_0041:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::scene
        IL_0046:  ldc.i4.0
        IL_0047:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                        int32)
        IL_004c:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
        IL_0051:  newobj     instance void class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                         !1,
                                                                                                                                                                         !2)
        IL_0056:  stloc.0
        IL_0057:  br.s       IL_0059

//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0059:  ldloc.0
        IL_005a:  ret
      } // end of method '<>c__DisplayClasscd'::'<RenderParallel>b__c7'

    } // end of class '<>c__DisplayClasscd'

    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassd0'
           extends [mscorlib]System.Object
    {
      .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassda'
             extends [mscorlib]System.Object
      {
        .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClasse2'
               extends [mscorlib]System.Object
        {
          .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClasse6'
                 extends [mscorlib]System.Object
          {
            .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2' 'CS$<>8__localse3'
            .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda' 'CS$<>8__localsdb'
            .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' 'CS$<>8__localsd1'
            .field public class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> '<>h__TransparentIdentifier7f'
            .method public hidebysig specialname rtspecialname 
                    instance void  .ctor() cil managed
            {
              // Code size       7 (0x7)
              .maxstack  8
              IL_0000:  ldarg.0
              IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
              IL_0006:  ret
            } // end of method '<>c__DisplayClasse6'::.ctor

            .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
                    '<RenderParallel>b__b6'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing) cil managed
            {
              // Code size       22 (0x16)
              .maxstack  2
              .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000)
//000172:                                                    select thing.Intersect(testRay)
              IL_0000:  ldarg.1
              IL_0001:  ldarg.0
              IL_0002:  ldfld      class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::'<>h__TransparentIdentifier7f'
              IL_0007:  callvirt   instance !1 class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::get_testRay()
              IL_000c:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray)
              IL_0011:  stloc.0
              IL_0012:  br.s       IL_0014

//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
              IL_0014:  ldloc.0
              IL_0015:  ret
            } // end of method '<>c__DisplayClasse6'::'<RenderParallel>b__b6'

          } // end of class '<>c__DisplayClasse6'

          .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda' 'CS$<>8__localsdb'
          .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' 'CS$<>8__localsd1'
          .field public class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier79'
          .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> 'CS$<>9__CachedAnonymousMethodDelegatee4'
          .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> 'CS$<>9__CachedAnonymousMethodDelegatee5'
          .method public hidebysig specialname rtspecialname 
                  instance void  .ctor() cil managed
          {
            // Code size       7 (0x7)
            .maxstack  8
            IL_0000:  ldarg.0
            IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
            IL_0006:  ret
          } // end of method '<>c__DisplayClasse2'::.ctor

          .method public hidebysig instance class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
                  '<RenderParallel>b__b2'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light light) cil managed
          {
            // Code size       43 (0x2b)
            .maxstack  3
            .locals init ([0] class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
            IL_0007:  ldarg.0
            IL_0008:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_000d:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_0012:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
            IL_0017:  callvirt   instance !1 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_001c:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_0021:  newobj     instance void class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                            !1)
            IL_0026:  stloc.0
            IL_0027:  br.s       IL_0029

//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0029:  ldloc.0
            IL_002a:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__b2'

          .method public hidebysig instance class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> 
                  '<RenderParallel>b__b4'(class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier7e') cil managed
          {
            // Code size       57 (0x39)
            .maxstack  3
            .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray '<>g__initLocala0',
                     [1] class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> CS$1$0000)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
            IL_0000:  ldarg.1
            IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor()
            IL_0006:  stloc.0
            IL_0007:  ldloc.0
            IL_0008:  ldarg.0
            IL_0009:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_000e:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_0013:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
            IL_0018:  callvirt   instance !1 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_001d:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
            IL_0022:  ldloc.0
            IL_0023:  ldarg.1
            IL_0024:  callvirt   instance !1 class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_livec()
            IL_0029:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
            IL_002e:  ldloc.0
            IL_002f:  newobj     instance void class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 !1)
            IL_0034:  stloc.1
            IL_0035:  br.s       IL_0037

//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0037:  ldloc.1
            IL_0038:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__b4'

          .method public hidebysig instance class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> 
                  '<RenderParallel>b__b5'(class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> '<>h__TransparentIdentifier7f') cil managed
          {
            // Code size       170 (0xaa)
            .maxstack  5
            .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6' 'CS$<>8__localse7',
                     [1] class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> CS$1$0000)
            IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::.ctor()
            IL_0005:  stloc.0
            IL_0006:  ldloc.0
            IL_0007:  ldarg.0
            IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::'CS$<>8__localse3'
            IL_000d:  ldloc.0
            IL_000e:  ldarg.0
            IL_000f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>8__localsdb'
            IL_0014:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::'CS$<>8__localsdb'
            IL_0019:  ldloc.0
            IL_001a:  ldarg.0
            IL_001b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>8__localsd1'
            IL_0020:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::'CS$<>8__localsd1'
            IL_0025:  ldloc.0
            IL_0026:  ldarg.1
            IL_0027:  stfld      class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::'<>h__TransparentIdentifier7f'
//000170:                               let testIsects = from inter in
            IL_002c:  ldloc.0
            IL_002d:  ldfld      class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::'<>h__TransparentIdentifier7f'
            IL_0032:  ldarg.0
            IL_0033:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>8__localsdb'
            IL_0038:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
            IL_003d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
            IL_0042:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
            IL_0047:  ldloc.0
            IL_0048:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'/'<>c__DisplayClasse6'::'<RenderParallel>b__b6'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject)
            IL_004e:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::.ctor(object,
                                                                                                                                                                                                                                                 native int)
            IL_0053:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                        class [mscorlib]System.Func`2<!!0,!!1>)
            IL_0058:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>9__CachedAnonymousMethodDelegatee4'
            IL_005d:  brtrue.s   IL_0072

            IL_005f:  ldnull
            IL_0060:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__b7'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
            IL_0066:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool>::.ctor(object,
                                                                                                                                                                     native int)
            IL_006b:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>9__CachedAnonymousMethodDelegatee4'
            IL_0070:  br.s       IL_0072

            IL_0072:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>9__CachedAnonymousMethodDelegatee4'
            IL_0077:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::Where<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                      class [mscorlib]System.Func`2<!!0,bool>)
            IL_007c:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>9__CachedAnonymousMethodDelegatee5'
            IL_0081:  brtrue.s   IL_0096

            IL_0083:  ldnull
            IL_0084:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__b8'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
            IL_008a:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>::.ctor(object,
                                                                                                                                                                        native int)
            IL_008f:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>9__CachedAnonymousMethodDelegatee5'
            IL_0094:  br.s       IL_0096

            IL_0096:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>9__CachedAnonymousMethodDelegatee5'
            IL_009b:  call       class [System.Core]System.Linq.IOrderedEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::OrderBy<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
            IL_00a0:  newobj     instance void class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 !1)
            IL_00a5:  stloc.1
            IL_00a6:  br.s       IL_00a8

//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_00a8:  ldloc.1
            IL_00a9:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__b5'

          .method public hidebysig instance class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> 
                  '<RenderParallel>b__bd'(class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> '<>h__TransparentIdentifier83') cil managed
          {
            // Code size       63 (0x3f)
            .maxstack  3
            .locals init ([0] class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> CS$1$0000)
//000180:                               let illum = Vector.Dot(livec, normal)
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  callvirt   instance !0 class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier82'()
            IL_0007:  callvirt   instance !0 class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier81'()
            IL_000c:  callvirt   instance !0 class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier80'()
            IL_0011:  callvirt   instance !0 class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier7f'()
            IL_0016:  callvirt   instance !0 class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier7e'()
            IL_001b:  callvirt   instance !1 class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_livec()
            IL_0020:  ldarg.0
            IL_0021:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_0026:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_002b:  callvirt   instance !1 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_normal()
            IL_0030:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_0035:  newobj     instance void class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 !1)
            IL_003a:  stloc.0
            IL_003b:  br.s       IL_003d

//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_003d:  ldloc.0
            IL_003e:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__bd'

          .method public hidebysig instance class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> 
                  '<RenderParallel>b__bf'(class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> '<>h__TransparentIdentifier85') cil managed
          {
            // Code size       73 (0x49)
            .maxstack  3
            .locals init ([0] class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> CS$1$0000)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  callvirt   instance !0 class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier84'()
            IL_0007:  callvirt   instance !0 class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::'get_<>h__TransparentIdentifier83'()
            IL_000c:  callvirt   instance !0 class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier82'()
            IL_0011:  callvirt   instance !0 class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier81'()
            IL_0016:  callvirt   instance !0 class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier80'()
            IL_001b:  callvirt   instance !0 class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier7f'()
            IL_0020:  callvirt   instance !0 class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier7e'()
            IL_0025:  callvirt   instance !1 class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_livec()
            IL_002a:  ldarg.0
            IL_002b:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_0030:  callvirt   instance !1 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectDir()
            IL_0035:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_003a:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
            IL_003f:  newobj     instance void class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    !1)
            IL_0044:  stloc.0
            IL_0045:  br.s       IL_0047

//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0047:  ldloc.0
            IL_0048:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__bf'

          .method public hidebysig instance class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
                  '<RenderParallel>b__c0'(class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> '<>h__TransparentIdentifier86') cil managed
          {
            // Code size       175 (0xaf)
            .maxstack  4
            .locals init ([0] class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000183:                               let scolor = specular > 0
            IL_0000:  ldarg.1
            IL_0001:  ldarg.1
            IL_0002:  callvirt   instance !1 class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::get_specular()
            IL_0007:  ldc.r8     0.0
            IL_0010:  bgt.s      IL_0034

            IL_0012:  ldc.r8     0.0
            IL_001b:  ldc.r8     0.0
            IL_0024:  ldc.r8     0.0
            IL_002d:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                                       float64,
                                                                                                                                                                                       float64)
            IL_0032:  br.s       IL_00a5

            IL_0034:  ldarg.1
            IL_0035:  callvirt   instance !1 class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::get_specular()
            IL_003a:  ldarg.0
            IL_003b:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_0040:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_0045:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
            IL_004a:  callvirt   instance !0 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier76'()
            IL_004f:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
            IL_0054:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
            IL_0059:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
            IL_005e:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Roughness
            IL_0063:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                                    float64)
            IL_0068:  ldarg.1
            IL_0069:  callvirt   instance !0 class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::'get_<>h__TransparentIdentifier85'()
            IL_006e:  callvirt   instance !0 class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier84'()
            IL_0073:  callvirt   instance !0 class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::'get_<>h__TransparentIdentifier83'()
            IL_0078:  callvirt   instance !0 class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier82'()
            IL_007d:  callvirt   instance !0 class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier81'()
            IL_0082:  callvirt   instance !0 class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier80'()
            IL_0087:  callvirt   instance !0 class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier7f'()
            IL_008c:  callvirt   instance !0 class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier7e'()
            IL_0091:  callvirt   instance !0 class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier7d'()
            IL_0096:  callvirt   instance !0 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_light()
            IL_009b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
            IL_00a0:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_00a5:  newobj     instance void class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               !1)
            IL_00aa:  stloc.0
            IL_00ab:  br.s       IL_00ad

//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_00ad:  ldloc.0
            IL_00ae:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__c0'

          .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
                  '<RenderParallel>b__c1'(class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> '<>h__TransparentIdentifier87') cil managed
          {
            // Code size       176 (0xb0)
            .maxstack  3
            .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
            IL_0000:  ldarg.0
            IL_0001:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_0006:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_000b:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
            IL_0010:  callvirt   instance !0 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier76'()
            IL_0015:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
            IL_001a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
            IL_001f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
            IL_0024:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Diffuse
            IL_0029:  ldarg.0
            IL_002a:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_002f:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_0034:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
            IL_0039:  callvirt   instance !1 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_003e:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
            IL_0043:  ldarg.1
            IL_0044:  callvirt   instance !0 class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier86'()
            IL_0049:  callvirt   instance !0 class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>::'get_<>h__TransparentIdentifier85'()
            IL_004e:  callvirt   instance !1 class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_lcolor()
            IL_0053:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_0058:  ldarg.0
            IL_0059:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_005e:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_0063:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
            IL_0068:  callvirt   instance !0 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier76'()
            IL_006d:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
            IL_0072:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
            IL_0077:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
            IL_007c:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Specular
            IL_0081:  ldarg.0
            IL_0082:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
            IL_0087:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
            IL_008c:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
            IL_0091:  callvirt   instance !1 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
            IL_0096:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
            IL_009b:  ldarg.1
            IL_009c:  callvirt   instance !1 class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_scolor()
            IL_00a1:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                        class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_00a6:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
            IL_00ab:  stloc.0
            IL_00ac:  br.s       IL_00ae

//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_00ae:  ldloc.0
            IL_00af:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__c1'

          .method private hidebysig static 
                  bool  '<RenderParallel>b__b7'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect inter) cil managed
          {
            // Code size       12 (0xc)
            .maxstack  2
            .locals init ([0] bool CS$1$0000)
//000173:                                                where inter != null
            IL_0000:  ldarg.0
            IL_0001:  ldnull
            IL_0002:  ceq
            IL_0004:  ldc.i4.0
            IL_0005:  ceq
            IL_0007:  stloc.0
            IL_0008:  br.s       IL_000a

//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_000a:  ldloc.0
            IL_000b:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__b7'

          .method private hidebysig static 
                  float64  '<RenderParallel>b__b8'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect inter) cil managed
          {
            // Code size       11 (0xb)
            .maxstack  1
            .locals init ([0] float64 CS$1$0000)
//000174:                                                orderby inter.Dist
            IL_0000:  ldarg.0
            IL_0001:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
            IL_0006:  stloc.0
            IL_0007:  br.s       IL_0009

//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
            IL_0009:  ldloc.0
            IL_000a:  ret
          } // end of method '<>c__DisplayClasse2'::'<RenderParallel>b__b8'

        } // end of class '<>c__DisplayClasse2'

        .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' 'CS$<>8__localsd1'
        .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs traceRayArgs
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegatedc'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> 'CS$<>9__CachedAnonymousMethodDelegatedd'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> 'CS$<>9__CachedAnonymousMethodDelegatede'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> 'CS$<>9__CachedAnonymousMethodDelegatedf'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> 'CS$<>9__CachedAnonymousMethodDelegatee0'
        .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 'CS$<>9__CachedAnonymousMethodDelegatee1'
        .method public hidebysig specialname rtspecialname 
                instance void  .ctor() cil managed
        {
          // Code size       7 (0x7)
          .maxstack  8
          IL_0000:  ldarg.0
          IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
          IL_0006:  ret
        } // end of method '<>c__DisplayClassda'::.ctor

        .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
                '<RenderParallel>b__aa'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing) cil managed
        {
          // Code size       22 (0x16)
          .maxstack  2
          .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000)
//000158:                               select thing.Intersect(traceRayArgs.Ray)
          IL_0000:  ldarg.1
          IL_0001:  ldarg.0
          IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
          IL_0007:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Ray
          IL_000c:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray)
          IL_0011:  stloc.0
          IL_0012:  br.s       IL_0014

//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0014:  ldloc.0
          IL_0015:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__aa'

        .method public hidebysig instance class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 
                '<RenderParallel>b__b1'(class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier79') cil managed
        {
          // Code size       399 (0x18f)
          .maxstack  5
          .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2' 'CS$<>8__localse3',
                   [1] class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$1$0000)
          IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::.ctor()
          IL_0005:  stloc.0
          IL_0006:  ldloc.0
          IL_0007:  ldarg.0
          IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>8__localsdb'
          IL_000d:  ldloc.0
          IL_000e:  ldarg.0
          IL_000f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>8__localsd1'
          IL_0014:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'CS$<>8__localsd1'
          IL_0019:  ldloc.0
          IL_001a:  ldarg.1
          IL_001b:  stfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
//000165:                           let naturalColors =
          IL_0020:  ldloc.0
          IL_0021:  ldfld      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<>h__TransparentIdentifier79'
          IL_0026:  ldarg.0
          IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
          IL_002c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
          IL_0031:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Lights
          IL_0036:  ldloc.0
          IL_0037:  ldftn      instance class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__b2'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light)
          IL_003d:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                    native int)
          IL_0042:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0047:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedc'
          IL_004c:  brtrue.s   IL_0061

          IL_004e:  ldnull
          IL_004f:  ldftn      class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__b3'(class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
          IL_0055:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           native int)
          IL_005a:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedc'
          IL_005f:  br.s       IL_0061

          IL_0061:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedc'
          IL_0066:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  class [mscorlib]System.Func`2<!!0,!!1>)
          IL_006b:  ldloc.0
          IL_006c:  ldftn      instance class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__b4'(class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
          IL_0072:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                native int)
          IL_0077:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       class [mscorlib]System.Func`2<!!0,!!1>)
          IL_007c:  ldloc.0
          IL_007d:  ldftn      instance class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__b5'(class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>)
          IL_0083:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         native int)
          IL_0088:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
          IL_008d:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedd'
          IL_0092:  brtrue.s   IL_00a7

          IL_0094:  ldnull
          IL_0095:  ldftn      class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__b9'(class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>)
          IL_009b:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    native int)
          IL_00a0:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedd'
          IL_00a5:  br.s       IL_00a7

          IL_00a7:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedd'
          IL_00ac:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
          IL_00b1:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatede'
          IL_00b6:  brtrue.s   IL_00cb

          IL_00b8:  ldnull
          IL_00b9:  ldftn      class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__ba'(class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>)
          IL_00bf:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       native int)
          IL_00c4:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatede'
          IL_00c9:  br.s       IL_00cb

          IL_00cb:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatede'
          IL_00d0:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              class [mscorlib]System.Func`2<!!0,!!1>)
          IL_00d5:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedf'
          IL_00da:  brtrue.s   IL_00ef

          IL_00dc:  ldnull
          IL_00dd:  ldftn      class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__bb'(class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>)
          IL_00e3:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    native int)
          IL_00e8:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedf'
          IL_00ed:  br.s       IL_00ef

          IL_00ef:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatedf'
          IL_00f4:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
          IL_00f9:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatee0'
          IL_00fe:  brtrue.s   IL_0113

          IL_0100:  ldnull
          IL_0101:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__bc'(class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>)
          IL_0107:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           native int)
          IL_010c:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatee0'
          IL_0111:  br.s       IL_0113

          IL_0113:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatee0'
          IL_0118:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::Where<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            class [mscorlib]System.Func`2<!!0,bool>)
          IL_011d:  ldloc.0
          IL_011e:  ldftn      instance class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__bd'(class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>)
          IL_0124:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 native int)
          IL_0129:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        class [mscorlib]System.Func`2<!!0,!!1>)
          IL_012e:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatee1'
          IL_0133:  brtrue.s   IL_0148

          IL_0135:  ldnull
          IL_0136:  ldftn      class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__be'(class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>)
          IL_013c:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    native int)
          IL_0141:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatee1'
          IL_0146:  br.s       IL_0148

          IL_0148:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>9__CachedAnonymousMethodDelegatee1'
          IL_014d:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0152:  ldloc.0
          IL_0153:  ldftn      instance class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__bf'(class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
          IL_0159:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       native int)
          IL_015e:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0163:  ldloc.0
          IL_0164:  ldftn      instance class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__c0'(class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>)
          IL_016a:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          native int)
          IL_016f:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0174:  ldloc.0
          IL_0175:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'/'<>c__DisplayClasse2'::'<RenderParallel>b__c1'(class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
          IL_017b:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       native int)
          IL_0180:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType27`2'<class '<>f__AnonymousType26`2'<class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              class [mscorlib]System.Func`2<!!0,!!1>)
          IL_0185:  newobj     instance void class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   !1)
          IL_018a:  stloc.1
          IL_018b:  br.s       IL_018d

//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_018d:  ldloc.1
          IL_018e:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__b1'

        .method public hidebysig instance class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
                '<RenderParallel>b__c3'(class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier7b') cil managed
        {
          // Code size       210 (0xd2)
          .maxstack  7
          .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray '<>g__initLocala1',
                   [1] class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
          IL_0000:  ldarg.1
          IL_0001:  ldarg.0
          IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
          IL_0007:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Depth
          IL_000c:  ldc.i4.5
          IL_000d:  bge        IL_00a8

          IL_0012:  ldarg.1
          IL_0013:  callvirt   instance !0 class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier7a'()
          IL_0018:  callvirt   instance !0 class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier79'()
          IL_001d:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
          IL_0022:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
          IL_0027:  callvirt   instance !0 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier76'()
          IL_002c:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
          IL_0031:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
          IL_0036:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
          IL_003b:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Reflect
          IL_0040:  ldarg.1
          IL_0041:  callvirt   instance !1 class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectPos()
          IL_0046:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::Invoke(!0)
          IL_004b:  ldarg.0
          IL_004c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>8__localsd1'
          IL_0051:  ldfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::f
          IL_0056:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor()
          IL_005b:  stloc.0
          IL_005c:  ldloc.0
          IL_005d:  ldarg.1
          IL_005e:  callvirt   instance !1 class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectPos()
          IL_0063:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
          IL_0068:  ldloc.0
          IL_0069:  ldarg.1
          IL_006a:  callvirt   instance !0 class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier7a'()
          IL_006f:  callvirt   instance !0 class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier79'()
          IL_0074:  callvirt   instance !1 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectDir()
          IL_0079:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
          IL_007e:  ldloc.0
          IL_007f:  ldarg.0
          IL_0080:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
          IL_0085:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
          IL_008a:  ldarg.0
          IL_008b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
          IL_0090:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Depth
          IL_0095:  ldc.i4.1
          IL_0096:  add
          IL_0097:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                          int32)
          IL_009c:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
          IL_00a1:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
          IL_00a6:  br.s       IL_00c8

          IL_00a8:  ldc.r8     0.5
          IL_00b1:  ldc.r8     0.5
          IL_00ba:  ldc.r8     0.5
          IL_00c3:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                                     float64,
                                                                                                                                                                                     float64)
          IL_00c8:  newobj     instance void class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          !1)
          IL_00cd:  stloc.1
          IL_00ce:  br.s       IL_00d0

//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_00d0:  ldloc.1
          IL_00d1:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__c3'

        .method private hidebysig static 
                class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
                '<RenderParallel>b__b3'(class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier7d') cil managed
        {
          // Code size       22 (0x16)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000168:                               let livec = Vector.Norm(ldis)
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_ldis()
          IL_0007:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
          IL_000c:  newobj     instance void class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                      !1)
          IL_0011:  stloc.0
          IL_0012:  br.s       IL_0014

//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0014:  ldloc.0
          IL_0015:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__b3'

        .method private hidebysig static 
                class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> 
                '<RenderParallel>b__b9'(class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>> '<>h__TransparentIdentifier80') cil managed
        {
          // Code size       22 (0x16)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> CS$1$0000)
//000176:                               let testIsect = testIsects.FirstOrDefault()
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::get_testIsects()
          IL_0007:  call       !!0 [System.Core]System.Linq.Enumerable::FirstOrDefault<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
          IL_000c:  newobj     instance void class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          !1)
          IL_0011:  stloc.0
          IL_0012:  br.s       IL_0014

//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0014:  ldloc.0
          IL_0015:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__b9'

        .method private hidebysig static 
                class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> 
                '<RenderParallel>b__ba'(class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> '<>h__TransparentIdentifier81') cil managed
        {
          // Code size       41 (0x29)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> CS$1$0000)
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::get_testIsect()
          IL_0007:  brfalse.s  IL_0016

          IL_0009:  ldarg.0
          IL_000a:  callvirt   instance !1 class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::get_testIsect()
          IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
          IL_0014:  br.s       IL_001f

          IL_0016:  ldc.r8     0.0
          IL_001f:  newobj     instance void class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  !1)
          IL_0024:  stloc.0
          IL_0025:  br.s       IL_0027

//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0027:  ldloc.0
          IL_0028:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__ba'

        .method private hidebysig static 
                class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> 
                '<RenderParallel>b__bb'(class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64> '<>h__TransparentIdentifier82') cil managed
        {
          // Code size       78 (0x4e)
          .maxstack  3
          .locals init ([0] class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> CS$1$0000)
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::get_neatIsect()
          IL_0007:  ldarg.0
          IL_0008:  callvirt   instance !0 class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier81'()
          IL_000d:  callvirt   instance !0 class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier80'()
          IL_0012:  callvirt   instance !0 class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier7f'()
          IL_0017:  callvirt   instance !0 class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier7e'()
          IL_001c:  callvirt   instance !0 class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier7d'()
          IL_0021:  callvirt   instance !1 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_ldis()
          IL_0026:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Mag(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
          IL_002b:  bgt.s      IL_0043

          IL_002d:  ldarg.0
          IL_002e:  callvirt   instance !1 class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::get_neatIsect()
          IL_0033:  ldc.r8     0.0
          IL_003c:  ceq
          IL_003e:  ldc.i4.0
          IL_003f:  ceq
          IL_0041:  br.s       IL_0044

          IL_0043:  ldc.i4.0
          IL_0044:  newobj     instance void class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       !1)
          IL_0049:  stloc.0
          IL_004a:  br.s       IL_004c

//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_004c:  ldloc.0
          IL_004d:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__bb'

        .method private hidebysig static 
                bool  '<RenderParallel>b__bc'(class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool> '<>h__TransparentIdentifier83') cil managed
        {
          // Code size       14 (0xe)
          .maxstack  2
          .locals init ([0] bool CS$1$0000)
//000179:                               where !isInShadow
          IL_0000:  ldarg.0
          IL_0001:  callvirt   instance !1 class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::get_isInShadow()
          IL_0006:  ldc.i4.0
          IL_0007:  ceq
          IL_0009:  stloc.0
          IL_000a:  br.s       IL_000c

//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_000c:  ldloc.0
          IL_000d:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__bc'

        .method private hidebysig static 
                class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
                '<RenderParallel>b__be'(class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64> '<>h__TransparentIdentifier84') cil managed
        {
          // Code size       119 (0x77)
          .maxstack  4
          .locals init ([0] class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
          IL_0000:  ldarg.0
          IL_0001:  ldarg.0
          IL_0002:  callvirt   instance !1 class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::get_illum()
          IL_0007:  ldc.r8     0.0
          IL_0010:  bgt.s      IL_0034

          IL_0012:  ldc.r8     0.0
          IL_001b:  ldc.r8     0.0
          IL_0024:  ldc.r8     0.0
          IL_002d:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                                     float64,
                                                                                                                                                                                     float64)
          IL_0032:  br.s       IL_006d

          IL_0034:  ldarg.0
          IL_0035:  callvirt   instance !1 class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::get_illum()
          IL_003a:  ldarg.0
          IL_003b:  callvirt   instance !0 class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>::'get_<>h__TransparentIdentifier83'()
          IL_0040:  callvirt   instance !0 class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>::'get_<>h__TransparentIdentifier82'()
          IL_0045:  callvirt   instance !0 class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>::'get_<>h__TransparentIdentifier81'()
          IL_004a:  callvirt   instance !0 class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::'get_<>h__TransparentIdentifier80'()
          IL_004f:  callvirt   instance !0 class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>::'get_<>h__TransparentIdentifier7f'()
          IL_0054:  callvirt   instance !0 class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>::'get_<>h__TransparentIdentifier7e'()
          IL_0059:  callvirt   instance !0 class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier7d'()
          IL_005e:  callvirt   instance !0 class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_light()
          IL_0063:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
          IL_0068:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
          IL_006d:  newobj     instance void class '<>f__AnonymousType25`2'<class '<>f__AnonymousType24`2'<class '<>f__AnonymousType23`2'<class '<>f__AnonymousType22`2'<class '<>f__AnonymousType21`2'<class '<>f__AnonymousType20`2'<class '<>f__AnonymousType1f`2'<class '<>f__AnonymousType1e`2'<class '<>f__AnonymousType8`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [System.Core]System.Linq.IOrderedEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,float64>,bool>,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          !1)
          IL_0072:  stloc.0
          IL_0073:  br.s       IL_0075

//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
          IL_0075:  ldloc.0
          IL_0076:  ret
        } // end of method '<>c__DisplayClassda'::'<RenderParallel>b__be'

      } // end of class '<>c__DisplayClassda'

      .field public class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> f
      .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> 'CS$<>9__CachedAnonymousMethodDelegated2'
      .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> 'CS$<>9__CachedAnonymousMethodDelegated3'
      .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegated4'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegated5'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegated6'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegated7'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> 'CS$<>9__CachedAnonymousMethodDelegated8'
      .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegated9'
      .field private static class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegatee8'
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClassd0'::.ctor

      .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
              '<RenderParallel>b__a9'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs traceRayArgs) cil managed
      {
        // Code size       395 (0x18b)
        .maxstack  4
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda' 'CS$<>8__localsdb',
                 [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
        IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::.ctor()
        IL_0005:  stloc.0
        IL_0006:  ldloc.0
        IL_0007:  ldarg.0
        IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'CS$<>8__localsd1'
        IL_000d:  ldloc.0
        IL_000e:  ldarg.1
        IL_000f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
//000156:                          (from isect in
        IL_0014:  ldloc.0
        IL_0015:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::traceRayArgs
        IL_001a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs::Scene
        IL_001f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
        IL_0024:  ldloc.0
        IL_0025:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__aa'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject)
        IL_002b:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::.ctor(object,
                                                                                                                                                                                                                                             native int)
        IL_0030:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                    class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0035:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated2'
        IL_003a:  brtrue.s   IL_004f

        IL_003c:  ldnull
        IL_003d:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__ab'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
        IL_0043:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool>::.ctor(object,
                                                                                                                                                                 native int)
        IL_0048:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated2'
        IL_004d:  br.s       IL_004f

        IL_004f:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,bool> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated2'
        IL_0054:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::Where<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                  class [mscorlib]System.Func`2<!!0,bool>)
        IL_0059:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated3'
        IL_005e:  brtrue.s   IL_0073

        IL_0060:  ldnull
        IL_0061:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__ac'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
        IL_0067:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>::.ctor(object,
                                                                                                                                                                    native int)
        IL_006c:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated3'
        IL_0071:  br.s       IL_0073

        IL_0073:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated3'
        IL_0078:  call       class [System.Core]System.Linq.IOrderedEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::OrderBy<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                       class [mscorlib]System.Func`2<!!0,!!1>)
        IL_007d:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated4'
        IL_0082:  brtrue.s   IL_0097

        IL_0084:  ldnull
        IL_0085:  ldftn      class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__ad'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
        IL_008b:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                  native int)
        IL_0090:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated4'
        IL_0095:  br.s       IL_0097

        IL_0097:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated4'
        IL_009c:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
        IL_00a1:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated5'
        IL_00a6:  brtrue.s   IL_00bb

        IL_00a8:  ldnull
        IL_00a9:  ldftn      class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__ae'(class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_00af:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         native int)
        IL_00b4:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated5'
        IL_00b9:  br.s       IL_00bb

        IL_00bb:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated5'
        IL_00c0:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
        IL_00c5:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated6'
        IL_00ca:  brtrue.s   IL_00df

        IL_00cc:  ldnull
        IL_00cd:  ldftn      class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__af'(class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_00d3:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 native int)
        IL_00d8:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated6'
        IL_00dd:  br.s       IL_00df

        IL_00df:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated6'
        IL_00e4:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        class [mscorlib]System.Func`2<!!0,!!1>)
        IL_00e9:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated7'
        IL_00ee:  brtrue.s   IL_0103

        IL_00f0:  ldnull
        IL_00f1:  ldftn      class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__b0'(class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_00f7:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         native int)
        IL_00fc:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated7'
        IL_0101:  br.s       IL_0103

        IL_0103:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated7'
        IL_0108:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
        IL_010d:  ldloc.0
        IL_010e:  ldftn      instance class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__b1'(class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_0114:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          native int)
        IL_0119:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 class [mscorlib]System.Func`2<!!0,!!1>)
        IL_011e:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated8'
        IL_0123:  brtrue.s   IL_0138

        IL_0125:  ldnull
        IL_0126:  ldftn      class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__c2'(class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>)
        IL_012c:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           native int)
        IL_0131:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated8'
        IL_0136:  br.s       IL_0138

        IL_0138:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated8'
        IL_013d:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0142:  ldloc.0
        IL_0143:  ldftn      instance class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'/'<>c__DisplayClassda'::'<RenderParallel>b__c3'(class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
        IL_0149:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  native int)
        IL_014e:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0153:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated9'
        IL_0158:  brtrue.s   IL_016d

        IL_015a:  ldnull
        IL_015b:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__c4'(class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
        IL_0161:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  native int)
        IL_0166:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated9'
        IL_016b:  br.s       IL_016d

        IL_016d:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegated9'
        IL_0172:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
        IL_0177:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Background
        IL_017c:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::DefaultIfEmpty<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                           !!0)
        IL_0181:  call       !!0 [System.Core]System.Linq.Enumerable::First<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
        IL_0186:  stloc.1
        IL_0187:  br.s       IL_0189

//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0189:  ldloc.1
        IL_018a:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__a9'

      .method private hidebysig static bool 
              '<RenderParallel>b__ab'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect) cil managed
      {
        // Code size       12 (0xc)
        .maxstack  2
        .locals init ([0] bool CS$1$0000)
//000159:                           where isect != null
        IL_0000:  ldarg.0
        IL_0001:  ldnull
        IL_0002:  ceq
        IL_0004:  ldc.i4.0
        IL_0005:  ceq
        IL_0007:  stloc.0
        IL_0008:  br.s       IL_000a

//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_000a:  ldloc.0
        IL_000b:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__ab'

      .method private hidebysig static float64 
              '<RenderParallel>b__ac'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect) cil managed
      {
        // Code size       11 (0xb)
        .maxstack  1
        .locals init ([0] float64 CS$1$0000)
//000160:                           orderby isect.Dist
        IL_0000:  ldarg.0
        IL_0001:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
        IL_0006:  stloc.0
        IL_0007:  br.s       IL_0009

//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0009:  ldloc.0
        IL_000a:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__ac'

      .method private hidebysig static class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderParallel>b__ad'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect) cil managed
      {
        // Code size       22 (0x16)
        .maxstack  3
        .locals init ([0] class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000161:                           let d = isect.Ray.Dir
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
        IL_0007:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
        IL_000c:  newobj     instance void class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                        !1)
        IL_0011:  stloc.0
        IL_0012:  br.s       IL_0014

//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0014:  ldloc.0
        IL_0015:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__ad'

      .method private hidebysig static class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderParallel>b__ae'(class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier76') cil managed
      {
        // Code size       64 (0x40)
        .maxstack  3
        .locals init ([0] class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_0007:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
        IL_000c:  ldarg.0
        IL_000d:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_0012:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
        IL_0017:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
        IL_001c:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0021:  ldarg.0
        IL_0022:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
        IL_002c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
        IL_0031:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0036:  newobj     instance void class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                    !1)
        IL_003b:  stloc.0
        IL_003c:  br.s       IL_003e

//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_003e:  ldloc.0
        IL_003f:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__ae'

      .method private hidebysig static class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderParallel>b__af'(class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier77') cil managed
      {
        // Code size       38 (0x26)
        .maxstack  3
        .locals init ([0] class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000163:                           let normal = isect.Thing.Normal(pos)
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier76'()
        IL_0007:  callvirt   instance !0 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_isect()
        IL_000c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
        IL_0011:  ldarg.0
        IL_0012:  callvirt   instance !1 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
        IL_0017:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Normal(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_001c:  newobj     instance void class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                !1)
        IL_0021:  stloc.0
        IL_0022:  br.s       IL_0024

//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0024:  ldloc.0
        IL_0025:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__af'

      .method private hidebysig static class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderParallel>b__b0'(class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> '<>h__TransparentIdentifier78') cil managed
      {
        // Code size       80 (0x50)
        .maxstack  5
        .locals init ([0] class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
        IL_0007:  callvirt   instance !0 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier76'()
        IL_000c:  callvirt   instance !1 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_d()
        IL_0011:  ldc.r8     2.
        IL_001a:  ldarg.0
        IL_001b:  callvirt   instance !1 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_normal()
        IL_0020:  ldarg.0
        IL_0021:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
        IL_0026:  callvirt   instance !0 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier76'()
        IL_002b:  callvirt   instance !1 class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_d()
        IL_0030:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0035:  mul
        IL_0036:  ldarg.0
        IL_0037:  callvirt   instance !1 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_normal()
        IL_003c:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0041:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0046:  newobj     instance void class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            !1)
        IL_004b:  stloc.0
        IL_004c:  br.s       IL_004e

//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_004e:  ldloc.0
        IL_004f:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__b0'

      .method private hidebysig static class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> 
              '<RenderParallel>b__c2'(class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> '<>h__TransparentIdentifier7a') cil managed
      {
        // Code size       62 (0x3e)
        .maxstack  4
        .locals init ([0] class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> CS$1$0000)
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
        IL_0000:  ldarg.0
        IL_0001:  ldarg.0
        IL_0002:  callvirt   instance !0 class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier79'()
        IL_0007:  callvirt   instance !0 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier78'()
        IL_000c:  callvirt   instance !0 class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier77'()
        IL_0011:  callvirt   instance !1 class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_pos()
        IL_0016:  ldc.r8     1.e-003
        IL_001f:  ldarg.0
        IL_0020:  callvirt   instance !0 class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::'get_<>h__TransparentIdentifier79'()
        IL_0025:  callvirt   instance !1 class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::get_reflectDir()
        IL_002a:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_002f:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
        IL_0034:  newobj     instance void class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             !1)
        IL_0039:  stloc.0
        IL_003a:  br.s       IL_003c

//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_003c:  ldloc.0
        IL_003d:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__c2'

      .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
              '<RenderParallel>b__c4'(class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> '<>h__TransparentIdentifier7c') cil managed
      {
        // Code size       63 (0x3f)
        .maxstack  5
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000200:                           select naturalColors.Aggregate(reflectColor,
        IL_0000:  ldarg.0
        IL_0001:  callvirt   instance !0 class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::'get_<>h__TransparentIdentifier7b'()
        IL_0006:  callvirt   instance !0 class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>::'get_<>h__TransparentIdentifier7a'()
        IL_000b:  callvirt   instance !1 class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::get_naturalColors()
        IL_0010:  ldarg.0
        IL_0011:  callvirt   instance !1 class '<>f__AnonymousType2a`2'<class '<>f__AnonymousType29`2'<class '<>f__AnonymousType28`2'<class '<>f__AnonymousType1d`2'<class '<>f__AnonymousType1c`2'<class '<>f__AnonymousType1b`2'<class '<>f__AnonymousType4`2'<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_reflectColor()
        IL_0016:  ldsfld     class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegatee8'
        IL_001b:  brtrue.s   IL_0030

        IL_001d:  ldnull
        IL_001e:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__c5'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
        IL_0024:  newobj     instance void class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                                                                                  native int)
        IL_0029:  stsfld     class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegatee8'
        IL_002e:  br.s       IL_0030

        IL_0030:  ldsfld     class [mscorlib]System.Func`3<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'CS$<>9__CachedAnonymousMethodDelegatee8'
        IL_0035:  call       !!1 [System.Core]System.Linq.Enumerable::Aggregate<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                       !!1,
                                                                                                                                                                                                                                       class [mscorlib]System.Func`3<!!1,!!0,!!1>)
        IL_003a:  stloc.0
        IL_003b:  br.s       IL_003d

//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_003d:  ldloc.0
        IL_003e:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__c4'

      .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
              '<RenderParallel>b__c5'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color color,
                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color natColor) cil managed
      {
        // Code size       12 (0xc)
        .maxstack  2
        .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
        IL_0000:  ldarg.0
        IL_0001:  ldarg.1
        IL_0002:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
        IL_0007:  stloc.0
        IL_0008:  br.s       IL_000a

//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_000a:  ldloc.0
        IL_000b:  ret
      } // end of method '<>c__DisplayClassd0'::'<RenderParallel>b__c5'

    } // end of class '<>c__DisplayClassd0'

    .field public int32[] rgb
    .field public int32 rowsProcessed
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer '<>4__this'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene
    .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> 'CS$<>9__CachedAnonymousMethodDelegatecb'
    .field private static class [mscorlib]System.Func`2<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> 'CS$<>9__CachedAnonymousMethodDelegatecc'
    .field private static class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 'CS$<>9__CachedAnonymousMethodDelegatecf'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassc9'::.ctor

    .method public hidebysig instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 
            '<RenderParallel>b__a3'(class '<>f__AnonymousType0`2'<int32,float64> '<>h__TransparentIdentifier70') cil managed
    {
      // Code size       182 (0xb6)
      .maxstack  4
      .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd' 'CS$<>8__localsce',
               [1] class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$1$0000)
      IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::.ctor()
      IL_0005:  stloc.0
      IL_0006:  ldloc.0
      IL_0007:  ldarg.0
      IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'CS$<>8__localsca'
      IL_000d:  ldloc.0
      IL_000e:  ldarg.1
      IL_000f:  stfld      class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'<>h__TransparentIdentifier70'
//000147:                 select from x in Enumerable.Range(0, screenWidth)
      IL_0014:  ldc.i4.0
      IL_0015:  ldarg.0
      IL_0016:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
      IL_001b:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_0020:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                      int32)
      IL_0025:  ldarg.0
      IL_0026:  ldftn      instance class '<>f__AnonymousType1`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<RenderParallel>b__a4'(int32)
      IL_002c:  newobj     instance void class [mscorlib]System.Func`2<int32,class '<>f__AnonymousType1`2'<int32,float64>>::.ctor(object,
                                                                                                                                  native int)
      IL_0031:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,class '<>f__AnonymousType1`2'<int32,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
      IL_0036:  ldloc.0
      IL_0037:  ldftn      instance class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'<RenderParallel>b__a5'(class '<>f__AnonymousType1`2'<int32,float64>)
      IL_003d:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1`2'<int32,float64>,class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>::.ctor(object,
                                                                                                                                                                                                                                                                                     native int)
      IL_0042:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1`2'<int32,float64>,class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                            class [mscorlib]System.Func`2<!!0,!!1>)
      IL_0047:  ldloc.0
      IL_0048:  ldftn      instance class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'<RenderParallel>b__a6'(class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>)
      IL_004e:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          native int)
      IL_0053:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 class [mscorlib]System.Func`2<!!0,!!1>)
      IL_0058:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecb'
      IL_005d:  brtrue.s   IL_0072

      IL_005f:  ldnull
      IL_0060:  ldftn      class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<RenderParallel>b__a7'(class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>)
      IL_0066:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              native int)
      IL_006b:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecb'
      IL_0070:  br.s       IL_0072

      IL_0072:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecb'
      IL_0077:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     class [mscorlib]System.Func`2<!!0,!!1>)
      IL_007c:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecc'
      IL_0081:  brtrue.s   IL_0096

      IL_0083:  ldnull
      IL_0084:  ldftn      class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<RenderParallel>b__c6'(class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>)
      IL_008a:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               native int)
      IL_008f:  stsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecc'
      IL_0094:  br.s       IL_0096

      IL_0096:  ldsfld     class [mscorlib]System.Func`2<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecc'
      IL_009b:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      class [mscorlib]System.Func`2<!!0,!!1>)
      IL_00a0:  ldloc.0
      IL_00a1:  ldftn      instance class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClasscd'::'<RenderParallel>b__c7'(class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>)
      IL_00a7:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         native int)
      IL_00ac:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>,class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
      IL_00b1:  stloc.1
      IL_00b2:  br.s       IL_00b4

//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_00b4:  ldloc.1
      IL_00b5:  ret
    } // end of method '<>c__DisplayClassc9'::'<RenderParallel>b__a3'

    .method public hidebysig instance void 
            '<RenderParallel>b__c8'(class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> row) cil managed
    {
      // Code size       164 (0xa4)
      .maxstack  4
      .locals init ([0] class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> pixel,
               [1] int32 processed,
               [2] class [mscorlib]System.Collections.Generic.IEnumerator`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$5$0000,
               [3] bool CS$4$0001)
//000209:             {
      IL_0000:  nop
//000210:                 foreach (var pixel in row)
      IL_0001:  nop
      IL_0002:  ldarg.1
      IL_0003:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::GetEnumerator()
      IL_0008:  stloc.2
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      .try
      {
        IL_0009:  br.s       IL_003f

//000210:                 foreach (var pixel in row)
        IL_000b:  ldloc.2
        IL_000c:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::get_Current()
        IL_0011:  stloc.0
//000211:                 {
        IL_0012:  nop
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
        IL_0013:  ldarg.0
        IL_0014:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::rgb
        IL_0019:  ldloc.0
        IL_001a:  callvirt   instance !0 class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_X()
        IL_001f:  ldloc.0
        IL_0020:  callvirt   instance !1 class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_Y()
        IL_0025:  ldarg.0
        IL_0026:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
        IL_002b:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
        IL_0030:  mul
        IL_0031:  add
        IL_0032:  ldloc.0
        IL_0033:  callvirt   instance !2 class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_Color()
        IL_0038:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32()
        IL_003d:  stelem.i4
//000213:                 }
        IL_003e:  nop
//000210:                 foreach (var pixel in row)
        IL_003f:  ldloc.2
        IL_0040:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
        IL_0045:  stloc.3
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_0046:  ldloc.3
        IL_0047:  brtrue.s   IL_000b

        IL_0049:  leave.s    IL_005b

      }  // end .try
      finally
      {
        IL_004b:  ldloc.2
        IL_004c:  ldnull
        IL_004d:  ceq
        IL_004f:  stloc.3
        IL_0050:  ldloc.3
        IL_0051:  brtrue.s   IL_005a

        IL_0053:  ldloc.2
        IL_0054:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_0059:  nop
        IL_005a:  endfinally
      }  // end handler
      IL_005b:  nop
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
      IL_005c:  ldarg.0
      IL_005d:  ldflda     int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::rowsProcessed
      IL_0062:  call       int32 [mscorlib]System.Threading.Interlocked::Increment(int32&)
      IL_0067:  stloc.1
//000215:                 if (processed % rowsPerUpdate == 0 ||
      IL_0068:  ldloc.1
      IL_0069:  ldarg.0
      IL_006a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
      IL_006f:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::rowsPerUpdate
      IL_0074:  rem
      IL_0075:  brfalse.s  IL_0087

      IL_0077:  ldloc.1
      IL_0078:  ldarg.0
      IL_0079:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
      IL_007e:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
      IL_0083:  clt
      IL_0085:  br.s       IL_0088

      IL_0087:  ldc.i4.0
      IL_0088:  stloc.3
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0089:  ldloc.3
      IL_008a:  brtrue.s   IL_00a3

//000216:                     processed >= screenHeight) updateImageHandler(rgb);
      IL_008c:  ldarg.0
      IL_008d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
      IL_0092:  ldfld      class [mscorlib]System.Action`1<int32[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::updateImageHandler
      IL_0097:  ldarg.0
      IL_0098:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::rgb
      IL_009d:  callvirt   instance void class [mscorlib]System.Action`1<int32[]>::Invoke(!0)
      IL_00a2:  nop
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_00a3:  ret
    } // end of method '<>c__DisplayClassc9'::'<RenderParallel>b__c8'

    .method private hidebysig instance class '<>f__AnonymousType1`2'<int32,float64> 
            '<RenderParallel>b__a4'(int32 x) cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  4
      .locals init ([0] class '<>f__AnonymousType1`2'<int32,float64> CS$1$0000)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
      IL_0000:  ldarg.1
      IL_0001:  ldarg.1
      IL_0002:  conv.r8
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
      IL_0009:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_000e:  conv.r8
      IL_000f:  ldc.r8     2.
      IL_0018:  div
      IL_0019:  sub
      IL_001a:  ldc.r8     2.
      IL_0023:  ldarg.0
      IL_0024:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
      IL_0029:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_002e:  conv.r8
      IL_002f:  mul
      IL_0030:  div
      IL_0031:  newobj     instance void class '<>f__AnonymousType1`2'<int32,float64>::.ctor(!0,
                                                                                             !1)
      IL_0036:  stloc.0
      IL_0037:  br.s       IL_0039

//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0039:  ldloc.0
      IL_003a:  ret
    } // end of method '<>c__DisplayClassc9'::'<RenderParallel>b__a4'

    .method private hidebysig static class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> 
            '<RenderParallel>b__a7'(class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray> '<>h__TransparentIdentifier73') cil managed
    {
      // Code size       42 (0x2a)
      .maxstack  4
      .locals init ([0] class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> CS$1$0000)
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
      IL_0000:  ldarg.0
      IL_0001:  ldsfld     class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecf'
      IL_0006:  brtrue.s   IL_001b

      IL_0008:  ldnull
      IL_0009:  ldftn      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<RenderParallel>b__a8'(class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>)
      IL_000f:  newobj     instance void class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(object,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           native int)
      IL_0014:  stsfld     class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecf'
      IL_0019:  br.s       IL_001b

      IL_001b:  ldsfld     class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'CS$<>9__CachedAnonymousMethodDelegatecf'
      IL_0020:  newobj     instance void class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             !1)
      IL_0025:  stloc.0
      IL_0026:  br.s       IL_0028

//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0028:  ldloc.0
      IL_0029:  ret
    } // end of method '<>c__DisplayClassc9'::'<RenderParallel>b__a7'

    .method private hidebysig static class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> 
            '<RenderParallel>b__c6'(class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> '<>h__TransparentIdentifier74') cil managed
    {
      // Code size       22 (0x16)
      .maxstack  3
      .locals init ([0] class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$1$0000)
//000203:                        let traceRay = Y(computeTraceRay)
      IL_0000:  ldarg.0
      IL_0001:  ldarg.0
      IL_0002:  callvirt   instance !1 class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::get_computeTraceRay()
      IL_0007:  call       class [mscorlib]System.Func`2<!!0,!!1> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::Y<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>(class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!!0,!!1>,class [mscorlib]System.Func`2<!!0,!!1>>)
      IL_000c:  newobj     instance void class '<>f__AnonymousType2c`2'<class '<>f__AnonymousType2b`2'<class '<>f__AnonymousType1a`2'<class '<>f__AnonymousType19`2'<class '<>f__AnonymousType1`2'<int32,float64>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector>,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray>,class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>,class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::.ctor(!0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   !1)
      IL_0011:  stloc.0
      IL_0012:  br.s       IL_0014

//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0014:  ldloc.0
      IL_0015:  ret
    } // end of method '<>c__DisplayClassc9'::'<RenderParallel>b__c6'

    .method private hidebysig static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 
            '<RenderParallel>b__a8'(class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> f) cil managed
    {
      // Code size       30 (0x1e)
      .maxstack  3
      .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0' 'CS$<>8__localsd1',
               [1] class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> CS$1$0000)
      IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::.ctor()
      IL_0005:  stloc.0
      IL_0006:  ldloc.0
      IL_0007:  ldarg.0
      IL_0008:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::f
//000155:                         (f => traceRayArgs =>
      IL_000d:  ldloc.0
      IL_000e:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'/'<>c__DisplayClassd0'::'<RenderParallel>b__a9'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs)
      IL_0014:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/TraceRayArgs,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                                      native int)
      IL_0019:  stloc.1
      IL_001a:  br.s       IL_001c

//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_001c:  ldloc.1
      IL_001d:  ret
    } // end of method '<>c__DisplayClassc9'::'<RenderParallel>b__a8'

  } // end of class '<>c__DisplayClassc9'

  .field private static literal int32 MaxDepth = int32(0x00000005)
  .field private int32 rowsPerUpdate
  .field private int32 screenWidth
  .field private int32 screenHeight
  .field private class [mscorlib]System.Action`1<int32[]> updateImageHandler
  .field assembly initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene DefaultScene
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(int32 screenWidth,
                               int32 screenHeight,
                               class [mscorlib]System.Action`1<int32[]> updateImageHandler) cil managed
  {
    // Code size       750 (0x2ee)
    .maxstack  8
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene '<>g__initLocal0',
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane '<>g__initLocal1',
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere '<>g__initLocal2',
             [3] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere '<>g__initLocal3',
             [4] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light '<>g__initLocal4',
             [5] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light '<>g__initLocal5',
             [6] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light '<>g__initLocal6',
             [7] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light '<>g__initLocal7',
             [8] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] CS$0$0000,
             [9] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] CS$0$0001)
//000220:         internal readonly Scene DefaultScene =
    IL_0000:  ldarg.0
    IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::.ctor()
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  ldc.i4.3
    IL_0009:  newarr     Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
    IL_000e:  stloc.s    CS$0$0000
    IL_0010:  ldloc.s    CS$0$0000
    IL_0012:  ldc.i4.0
    IL_0013:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::.ctor()
    IL_0018:  stloc.1
    IL_0019:  ldloc.1
    IL_001a:  ldc.r8     0.0
    IL_0023:  ldc.r8     1.
    IL_002c:  ldc.r8     0.0
    IL_0035:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_003a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_003f:  ldloc.1
    IL_0040:  ldc.r8     0.0
    IL_0049:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Offset
    IL_004e:  ldloc.1
    IL_004f:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::CheckerBoard
    IL_0054:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_0059:  ldloc.1
    IL_005a:  stelem.ref
    IL_005b:  ldloc.s    CS$0$0000
    IL_005d:  ldc.i4.1
    IL_005e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::.ctor()
    IL_0063:  stloc.2
    IL_0064:  ldloc.2
    IL_0065:  ldc.r8     0.0
    IL_006e:  ldc.r8     1.
    IL_0077:  ldc.r8     0.0
    IL_0080:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_0085:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_008a:  ldloc.2
    IL_008b:  ldc.r8     1.
    IL_0094:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Radius
    IL_0099:  ldloc.2
    IL_009a:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::Shiny
    IL_009f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_00a4:  ldloc.2
    IL_00a5:  stelem.ref
    IL_00a6:  ldloc.s    CS$0$0000
    IL_00a8:  ldc.i4.2
    IL_00a9:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::.ctor()
    IL_00ae:  stloc.3
    IL_00af:  ldloc.3
    IL_00b0:  ldc.r8     -1.
    IL_00b9:  ldc.r8     0.5
    IL_00c2:  ldc.r8     1.5
    IL_00cb:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_00d0:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_00d5:  ldloc.3
    IL_00d6:  ldc.r8     0.5
    IL_00df:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Radius
    IL_00e4:  ldloc.3
    IL_00e5:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::Shiny
    IL_00ea:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_00ef:  ldloc.3
    IL_00f0:  stelem.ref
    IL_00f1:  ldloc.s    CS$0$0000
    IL_00f3:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
    IL_00f8:  ldloc.0
    IL_00f9:  ldc.i4.4
    IL_00fa:  newarr     Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light
    IL_00ff:  stloc.s    CS$0$0001
    IL_0101:  ldloc.s    CS$0$0001
    IL_0103:  ldc.i4.0
    IL_0104:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::.ctor()
    IL_0109:  stloc.s    '<>g__initLocal4'
    IL_010b:  ldloc.s    '<>g__initLocal4'
    IL_010d:  ldc.r8     -2.
    IL_0116:  ldc.r8     2.5
    IL_011f:  ldc.r8     0.0
    IL_0128:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_012d:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
    IL_0132:  ldloc.s    '<>g__initLocal4'
    IL_0134:  ldc.r8     0.48999999999999999
    IL_013d:  ldc.r8     7.0000000000000007e-002
    IL_0146:  ldc.r8     7.0000000000000007e-002
    IL_014f:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_0154:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
    IL_0159:  ldloc.s    '<>g__initLocal4'
    IL_015b:  stelem.ref
    IL_015c:  ldloc.s    CS$0$0001
    IL_015e:  ldc.i4.1
    IL_015f:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::.ctor()
    IL_0164:  stloc.s    '<>g__initLocal5'
    IL_0166:  ldloc.s    '<>g__initLocal5'
    IL_0168:  ldc.r8     1.5
    IL_0171:  ldc.r8     2.5
    IL_017a:  ldc.r8     1.5
    IL_0183:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_0188:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
    IL_018d:  ldloc.s    '<>g__initLocal5'
    IL_018f:  ldc.r8     7.0000000000000007e-002
    IL_0198:  ldc.r8     7.0000000000000007e-002
    IL_01a1:  ldc.r8     0.48999999999999999
    IL_01aa:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_01af:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
    IL_01b4:  ldloc.s    '<>g__initLocal5'
    IL_01b6:  stelem.ref
    IL_01b7:  ldloc.s    CS$0$0001
    IL_01b9:  ldc.i4.2
    IL_01ba:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::.ctor()
    IL_01bf:  stloc.s    '<>g__initLocal6'
    IL_01c1:  ldloc.s    '<>g__initLocal6'
    IL_01c3:  ldc.r8     1.5
    IL_01cc:  ldc.r8     2.5
    IL_01d5:  ldc.r8     -1.5
    IL_01de:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_01e3:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
    IL_01e8:  ldloc.s    '<>g__initLocal6'
    IL_01ea:  ldc.r8     7.0000000000000007e-002
    IL_01f3:  ldc.r8     0.48999999999999999
    IL_01fc:  ldc.r8     7.0999999999999994e-002
    IL_0205:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_020a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
    IL_020f:  ldloc.s    '<>g__initLocal6'
    IL_0211:  stelem.ref
    IL_0212:  ldloc.s    CS$0$0001
    IL_0214:  ldc.i4.3
    IL_0215:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::.ctor()
    IL_021a:  stloc.s    '<>g__initLocal7'
    IL_021c:  ldloc.s    '<>g__initLocal7'
    IL_021e:  ldc.r8     0.0
    IL_0227:  ldc.r8     3.5
    IL_0230:  ldc.r8     0.0
    IL_0239:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_023e:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
    IL_0243:  ldloc.s    '<>g__initLocal7'
    IL_0245:  ldc.r8     0.20999999999999999
    IL_024e:  ldc.r8     0.20999999999999999
    IL_0257:  ldc.r8     0.34999999999999998
    IL_0260:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_0265:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
    IL_026a:  ldloc.s    '<>g__initLocal7'
    IL_026c:  stelem.ref
    IL_026d:  ldloc.s    CS$0$0001
    IL_026f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Lights
    IL_0274:  ldloc.0
    IL_0275:  ldc.r8     3.
    IL_027e:  ldc.r8     2.
    IL_0287:  ldc.r8     4.
    IL_0290:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_0295:  ldc.r8     -1.
    IL_029e:  ldc.r8     0.5
    IL_02a7:  ldc.r8     0.0
    IL_02b0:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Make(float64,
                                                                                                                                                                                 float64,
                                                                                                                                                                                 float64)
    IL_02b5:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Create(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_02ba:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
    IL_02bf:  ldloc.0
    IL_02c0:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::DefaultScene
//000028:         public RayTracer(int screenWidth, int screenHeight, Action<int[]> updateImageHandler)
    IL_02c5:  ldarg.0
    IL_02c6:  call       instance void [mscorlib]System.Object::.ctor()
    IL_02cb:  nop
//000029:         {
    IL_02cc:  nop
//000030:             this.screenWidth = screenWidth;
    IL_02cd:  ldarg.0
    IL_02ce:  ldarg.1
    IL_02cf:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
//000031:             this.screenHeight = screenHeight;
    IL_02d4:  ldarg.0
    IL_02d5:  ldarg.2
    IL_02d6:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
//000032:             this.updateImageHandler = updateImageHandler;
    IL_02db:  ldarg.0
    IL_02dc:  ldarg.3
    IL_02dd:  stfld      class [mscorlib]System.Action`1<int32[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::updateImageHandler
//000033:             this.rowsPerUpdate = screenHeight / 30;
    IL_02e2:  ldarg.0
    IL_02e3:  ldarg.2
    IL_02e4:  ldc.i4.s   30
    IL_02e6:  div
    IL_02e7:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::rowsPerUpdate
//000034:         }
    IL_02ec:  nop
    IL_02ed:  ret
  } // end of method RayTracer::.ctor

  .method public hidebysig static class [mscorlib]System.Func`2<!!T,!!U> 
          Y<T,U>(class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!!T,!!U>,class [mscorlib]System.Func`2<!!T,!!U>> f) cil managed
  {
    // Code size       55 (0x37)
    .maxstack  4
    .locals init ([0] class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!!T,!!U>>,class [mscorlib]System.Func`2<!!T,!!U>> g,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!!T,!!U> 'CS$<>8__localsc',
             [2] class [mscorlib]System.Func`2<!!T,!!U> CS$1$0000)
//000035: 
//000036:         private class Wrap<T>
//000037:         {
//000038:             public readonly Func<Wrap<T>, T> It;
//000039:             public Wrap(Func<Wrap<T>, T> it) { It = it; }
//000040:         }
//000041: 
//000042:         public static Func<T, U> Y<T, U>(Func<Func<T, U>, Func<T, U>> f)
//000043:         {
//000044:             Func<Wrap<Func<T, U>>, Func<T, U>> g = wx => f(wx.It(wx));
//000045:             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
//000046:         }
//000047: 
//000048:         class TraceRayArgs
//000049:         {
//000050:             public readonly Ray Ray;
//000051:             public readonly Scene Scene;
//000052:             public readonly int Depth;
//000053: 
//000054:             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
//000055:         }
//000056: 
//000057:         internal void RenderSequential(Scene scene, CancellationToken cancellationToken)
//000058:         {
//000059:             int[] rgb = new int[screenWidth * screenHeight];
//000060: 
//000061:             var pixelsQuery =
//000062:                 from y in Enumerable.Range(0, screenHeight)
//000063:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000064:                 select from x in Enumerable.Range(0, screenWidth)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0000:  newobj     instance void class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!!T,!!U>::.ctor()
    IL_0005:  stloc.1
    IL_0006:  ldloc.1
    IL_0007:  ldarg.0
    IL_0008:  stfld      class [mscorlib]System.Func`2<class [mscorlib]System.Func`2<!0,!1>,class [mscorlib]System.Func`2<!0,!1>> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!!T,!!U>::f
//000043:         {
    IL_000d:  nop
//000044:             Func<Wrap<Func<T, U>>, Func<T, U>> g = wx => f(wx.It(wx));
    IL_000e:  ldloc.1
    IL_000f:  ldftn      instance class [mscorlib]System.Func`2<!0,!1> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!!T,!!U>::'<Y>b__8'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!0,!1>>)
    IL_0015:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!!T,!!U>>,class [mscorlib]System.Func`2<!!T,!!U>>::.ctor(object,
                                                                                                                                                                                                                                                  native int)
    IL_001a:  stloc.0
//000045:             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
    IL_001b:  ldloc.0
    IL_001c:  ldloc.1
    IL_001d:  ldftn      instance class [mscorlib]System.Func`2<!0,!1> class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassb`2'<!!T,!!U>::'<Y>b__9'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!0,!1>>)
    IL_0023:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!!T,!!U>>,class [mscorlib]System.Func`2<!!T,!!U>>::.ctor(object,
                                                                                                                                                                                                                                                  native int)
    IL_0028:  newobj     instance void class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!!T,!!U>>::.ctor(class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<!0>,!0>)
    IL_002d:  callvirt   instance !1 class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/Wrap`1<class [mscorlib]System.Func`2<!!T,!!U>>,class [mscorlib]System.Func`2<!!T,!!U>>::Invoke(!0)
    IL_0032:  stloc.2
    IL_0033:  br.s       IL_0035

//000046:         }
    IL_0035:  ldloc.2
    IL_0036:  ret
  } // end of method RayTracer::Y

  .method assembly hidebysig instance void 
          RenderSequential(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                           valuetype [mscorlib]System.Threading.CancellationToken cancellationToken) cil managed
  {
    // Code size       305 (0x131)
    .maxstack  4
    .locals init ([0] int32[] rgb,
             [1] class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> pixelsQuery,
             [2] int32 rowsProcessed,
             [3] class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> row,
             [4] class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> pixel,
             [5] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50' 'CS$<>8__locals51',
             [6] class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> CS$5$0000,
             [7] class [mscorlib]System.Collections.Generic.IEnumerator`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> CS$5$0001,
             [8] bool CS$4$0002)
//000047: 
//000048:         class TraceRayArgs
//000049:         {
//000050:             public readonly Ray Ray;
//000051:             public readonly Scene Scene;
//000052:             public readonly int Depth;
//000053: 
//000054:             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
//000055:         }
//000056: 
//000057:         internal void RenderSequential(Scene scene, CancellationToken cancellationToken)
//000058:         {
//000059:             int[] rgb = new int[screenWidth * screenHeight];
//000060: 
//000061:             var pixelsQuery =
//000062:                 from y in Enumerable.Range(0, screenHeight)
//000063:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000064:                 select from x in Enumerable.Range(0, screenWidth)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::.ctor()
    IL_0005:  stloc.s    'CS$<>8__locals51'
    IL_0007:  ldloc.s    'CS$<>8__locals51'
    IL_0009:  ldarg.1
    IL_000a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::scene
    IL_000f:  ldloc.s    'CS$<>8__locals51'
    IL_0011:  ldarg.0
    IL_0012:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<>4__this'
//000058:         {
    IL_0017:  nop
//000059:             int[] rgb = new int[screenWidth * screenHeight];
    IL_0018:  ldarg.0
    IL_0019:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
    IL_001e:  ldarg.0
    IL_001f:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0024:  mul
    IL_0025:  newarr     [mscorlib]System.Int32
    IL_002a:  stloc.0
//000060: 
//000061:             var pixelsQuery =
    IL_002b:  ldc.i4.0
    IL_002c:  ldarg.0
    IL_002d:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0032:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                    int32)
    IL_0037:  ldarg.0
    IL_0038:  ldftn      instance class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::'<RenderSequential>b__2a'(int32)
    IL_003e:  newobj     instance void class [mscorlib]System.Func`2<int32,class '<>f__AnonymousType0`2'<int32,float64>>::.ctor(object,
                                                                                                                                native int)
    IL_0043:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,class '<>f__AnonymousType0`2'<int32,float64>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                       class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0048:  ldloc.s    'CS$<>8__locals51'
    IL_004a:  ldftn      instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass50'::'<RenderSequential>b__2b'(class '<>f__AnonymousType0`2'<int32,float64>)
    IL_0050:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType0`2'<int32,float64>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                           native int)
    IL_0055:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class '<>f__AnonymousType0`2'<int32,float64>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                  class [mscorlib]System.Func`2<!!0,!!1>)
    IL_005a:  stloc.1
//000062:                 from y in Enumerable.Range(0, screenHeight)
//000063:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000064:                 select from x in Enumerable.Range(0, screenWidth)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
    IL_005b:  ldc.i4.0
    IL_005c:  stloc.2
//000124: 
//000125:             foreach (var row in pixelsQuery)
    IL_005d:  nop
    IL_005e:  ldloc.1
    IL_005f:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::GetEnumerator()
    IL_0064:  stloc.s    CS$5$0000
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    .try
    {
      IL_0066:  br         IL_0108

//000125:             foreach (var row in pixelsQuery)
      IL_006b:  ldloc.s    CS$5$0000
      IL_006d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::get_Current()
      IL_0072:  stloc.3
//000126:             {
      IL_0073:  nop
//000127:                 cancellationToken.ThrowIfCancellationRequested();
      IL_0074:  ldarga.s   cancellationToken
      IL_0076:  call       instance void [mscorlib]System.Threading.CancellationToken::ThrowIfCancellationRequested()
      IL_007b:  nop
//000128:                 foreach (var pixel in row)
      IL_007c:  nop
      IL_007d:  ldloc.3
      IL_007e:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::GetEnumerator()
      IL_0083:  stloc.s    CS$5$0001
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      .try
      {
        IL_0085:  br.s       IL_00b6

//000128:                 foreach (var pixel in row)
        IL_0087:  ldloc.s    CS$5$0001
        IL_0089:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>::get_Current()
        IL_008e:  stloc.s    pixel
//000129:                 {
        IL_0090:  nop
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
        IL_0091:  ldloc.0
        IL_0092:  ldloc.s    pixel
        IL_0094:  callvirt   instance !0 class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_X()
        IL_0099:  ldloc.s    pixel
        IL_009b:  callvirt   instance !1 class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_Y()
        IL_00a0:  ldarg.0
        IL_00a1:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
        IL_00a6:  mul
        IL_00a7:  add
        IL_00a8:  ldloc.s    pixel
        IL_00aa:  callvirt   instance !2 class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::get_Color()
        IL_00af:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32()
        IL_00b4:  stelem.i4
//000131:                 }
        IL_00b5:  nop
//000128:                 foreach (var pixel in row)
        IL_00b6:  ldloc.s    CS$5$0001
        IL_00b8:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
        IL_00bd:  stloc.s    CS$4$0002
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
        IL_00bf:  ldloc.s    CS$4$0002
        IL_00c1:  brtrue.s   IL_0087

        IL_00c3:  leave.s    IL_00d9

      }  // end .try
      finally
      {
        IL_00c5:  ldloc.s    CS$5$0001
        IL_00c7:  ldnull
        IL_00c8:  ceq
        IL_00ca:  stloc.s    CS$4$0002
        IL_00cc:  ldloc.s    CS$4$0002
        IL_00ce:  brtrue.s   IL_00d8

        IL_00d0:  ldloc.s    CS$5$0001
        IL_00d2:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_00d7:  nop
        IL_00d8:  endfinally
      }  // end handler
      IL_00d9:  nop
//000132:                 rowsProcessed++;
      IL_00da:  ldloc.2
      IL_00db:  ldc.i4.1
      IL_00dc:  add
      IL_00dd:  stloc.2
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
      IL_00de:  ldloc.2
      IL_00df:  ldarg.0
      IL_00e0:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::rowsPerUpdate
      IL_00e5:  rem
      IL_00e6:  brfalse.s  IL_00f3

      IL_00e8:  ldloc.2
      IL_00e9:  ldarg.0
      IL_00ea:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
      IL_00ef:  clt
      IL_00f1:  br.s       IL_00f4

      IL_00f3:  ldc.i4.0
      IL_00f4:  stloc.s    CS$4$0002
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_00f6:  ldloc.s    CS$4$0002
      IL_00f8:  brtrue.s   IL_0107

//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
      IL_00fa:  ldarg.0
      IL_00fb:  ldfld      class [mscorlib]System.Action`1<int32[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::updateImageHandler
      IL_0100:  ldloc.0
      IL_0101:  callvirt   instance void class [mscorlib]System.Action`1<int32[]>::Invoke(!0)
      IL_0106:  nop
//000135:             }
      IL_0107:  nop
//000125:             foreach (var row in pixelsQuery)
      IL_0108:  ldloc.s    CS$5$0000
      IL_010a:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_010f:  stloc.s    CS$4$0002
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
      IL_0111:  ldloc.s    CS$4$0002
      IL_0113:  brtrue     IL_006b

      IL_0118:  leave.s    IL_012e

    }  // end .try
    finally
    {
      IL_011a:  ldloc.s    CS$5$0000
      IL_011c:  ldnull
      IL_011d:  ceq
      IL_011f:  stloc.s    CS$4$0002
      IL_0121:  ldloc.s    CS$4$0002
      IL_0123:  brtrue.s   IL_012d

      IL_0125:  ldloc.s    CS$5$0000
      IL_0127:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_012c:  nop
      IL_012d:  endfinally
    }  // end handler
    IL_012e:  nop
//000136:         }
    IL_012f:  nop
    IL_0130:  ret
  } // end of method RayTracer::RenderSequential

  .method assembly hidebysig instance void 
          RenderParallel(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                         valuetype [mscorlib]System.Threading.CancellationToken cancellationToken) cil managed
  {
    // Code size       131 (0x83)
    .maxstack  4
    .locals init ([0] class [System.Core]System.Linq.ParallelQuery`1<class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>> pixelsQuery,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9' 'CS$<>8__localsca')
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::.ctor()
    IL_0005:  stloc.1
    IL_0006:  ldloc.1
    IL_0007:  ldarg.1
    IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::scene
    IL_000d:  ldloc.1
    IL_000e:  ldarg.0
    IL_000f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<>4__this'
//000139:         {
    IL_0014:  nop
//000140:             int[] rgb = new int[screenWidth * screenHeight];
    IL_0015:  ldloc.1
    IL_0016:  ldarg.0
    IL_0017:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
    IL_001c:  ldarg.0
    IL_001d:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0022:  mul
    IL_0023:  newarr     [mscorlib]System.Int32
    IL_0028:  stfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::rgb
//000141: 
//000142:             var pixelsQuery =
    IL_002d:  ldc.i4.0
    IL_002e:  ldarg.0
    IL_002f:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0034:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                    int32)
    IL_0039:  call       class [System.Core]System.Linq.ParallelQuery`1<!!0> [System.Core]System.Linq.ParallelEnumerable::AsParallel<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_003e:  ldarg.2
    IL_003f:  call       class [System.Core]System.Linq.ParallelQuery`1<!!0> [System.Core]System.Linq.ParallelEnumerable::WithCancellation<int32>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                                                                                  valuetype [mscorlib]System.Threading.CancellationToken)
    IL_0044:  ldarg.0
    IL_0045:  ldftn      instance class '<>f__AnonymousType0`2'<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::'<RenderParallel>b__a2'(int32)
    IL_004b:  newobj     instance void class [mscorlib]System.Func`2<int32,class '<>f__AnonymousType0`2'<int32,float64>>::.ctor(object,
                                                                                                                                native int)
    IL_0050:  call       class [System.Core]System.Linq.ParallelQuery`1<!!1> [System.Core]System.Linq.ParallelEnumerable::Select<int32,class '<>f__AnonymousType0`2'<int32,float64>>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                                                                                                                     class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0055:  ldloc.1
    IL_0056:  ldftn      instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<RenderParallel>b__a3'(class '<>f__AnonymousType0`2'<int32,float64>)
    IL_005c:  newobj     instance void class [mscorlib]System.Func`2<class '<>f__AnonymousType0`2'<int32,float64>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(object,
                                                                                                                                                                                                                                                                                                           native int)
    IL_0061:  call       class [System.Core]System.Linq.ParallelQuery`1<!!1> [System.Core]System.Linq.ParallelEnumerable::Select<class '<>f__AnonymousType0`2'<int32,float64>,class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0066:  stloc.0
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
    IL_0067:  ldloc.1
    IL_0068:  ldc.i4.0
    IL_0069:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::rowsProcessed
//000207: 
//000208:             pixelsQuery.ForAll(row =>
    IL_006e:  ldloc.0
    IL_006f:  ldloc.1
    IL_0070:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClassc9'::'<RenderParallel>b__c8'(class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>)
    IL_0076:  newobj     instance void class [mscorlib]System.Action`1<class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>::.ctor(object,
                                                                                                                                                                                                                                                                native int)
    IL_007b:  call       void [System.Core]System.Linq.ParallelEnumerable::ForAll<class [mscorlib]System.Collections.Generic.IEnumerable`1<class '<>f__AnonymousType18`3'<int32,int32,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>>>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                                                                                                                                                                                                    class [mscorlib]System.Action`1<!!0>)
    IL_0080:  nop
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
    IL_0081:  nop
    IL_0082:  ret
  } // end of method RayTracer::RenderParallel

  .method private hidebysig instance class '<>f__AnonymousType0`2'<int32,float64> 
          '<RenderSequential>b__2a'(int32 y) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] class '<>f__AnonymousType0`2'<int32,float64> CS$1$0000)
//000063:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
    IL_0000:  ldarg.1
    IL_0001:  ldarg.1
    IL_0002:  conv.r8
    IL_0003:  ldarg.0
    IL_0004:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0009:  conv.r8
    IL_000a:  ldc.r8     2.
    IL_0013:  div
    IL_0014:  sub
    IL_0015:  neg
    IL_0016:  ldc.r8     2.
    IL_001f:  ldarg.0
    IL_0020:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0025:  conv.r8
    IL_0026:  mul
    IL_0027:  div
    IL_0028:  newobj     instance void class '<>f__AnonymousType0`2'<int32,float64>::.ctor(!0,
                                                                                           !1)
    IL_002d:  stloc.0
    IL_002e:  br.s       IL_0030

//000064:                 select from x in Enumerable.Range(0, screenWidth)
//000065:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000066:                        let point =
//000067:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000068:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000069:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000070:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000071:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000072:                         (f => traceRayArgs =>
//000073:                          (from isect in
//000074:                               from thing in traceRayArgs.Scene.Things
//000075:                               select thing.Intersect(traceRayArgs.Ray)
//000076:                           where isect != null
//000077:                           orderby isect.Dist
//000078:                           let d = isect.Ray.Dir
//000079:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000080:                           let normal = isect.Thing.Normal(pos)
//000081:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000082:                           let naturalColors =
//000083:                               from light in traceRayArgs.Scene.Lights
//000084:                               let ldis = Vector.Minus(light.Pos, pos)
//000085:                               let livec = Vector.Norm(ldis)
//000086:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000087:                               let testIsects = from inter in
//000088:                                                    from thing in traceRayArgs.Scene.Things
//000089:                                                    select thing.Intersect(testRay)
//000090:                                                where inter != null
//000091:                                                orderby inter.Dist
//000092:                                                select inter
//000093:                               let testIsect = testIsects.FirstOrDefault()
//000094:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000095:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000096:                               where !isInShadow
//000097:                               let illum = Vector.Dot(livec, normal)
//000098:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000099:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000100:                               let scolor = specular > 0
//000101:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000102:                                                            light.Color)
//000103:                                              : Color.Make(0, 0, 0)
//000104:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000105:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000106:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000107:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000108:                                               ? Color.Make(.5, .5, .5)
//000109:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000110:                                                             f(new TraceRayArgs(new Ray()
//000111:                                                             {
//000112:                                                                 Start = reflectPos,
//000113:                                                                 Dir = reflectDir
//000114:                                                             },
//000115:                                                                                traceRayArgs.Scene,
//000116:                                                                                traceRayArgs.Depth + 1)))
//000117:                           select naturalColors.Aggregate(reflectColor,
//000118:                                                          (color, natColor) => Color.Plus(color, natColor))
//000119:                          ).DefaultIfEmpty(Color.Background).First())
//000120:                        let traceRay = Y(computeTraceRay)
//000121:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000122: 
//000123:             int rowsProcessed = 0;
//000124: 
//000125:             foreach (var row in pixelsQuery)
//000126:             {
//000127:                 cancellationToken.ThrowIfCancellationRequested();
//000128:                 foreach (var pixel in row)
//000129:                 {
//000130:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000131:                 }
//000132:                 rowsProcessed++;
//000133:                 if (rowsProcessed % rowsPerUpdate == 0 ||
//000134:                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
//000135:             }
//000136:         }
//000137: 
//000138:         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
//000139:         {
//000140:             int[] rgb = new int[screenWidth * screenHeight];
//000141: 
//000142:             var pixelsQuery =
//000143:                 from y in 
//000144:                     Enumerable.Range(0, screenHeight).AsParallel()
//000145:                     .WithCancellation(cancellationToken)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method RayTracer::'<RenderSequential>b__2a'

  .method private hidebysig instance class '<>f__AnonymousType0`2'<int32,float64> 
          '<RenderParallel>b__a2'(int32 y) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] class '<>f__AnonymousType0`2'<int32,float64> CS$1$0000)
//000146:                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
    IL_0000:  ldarg.1
    IL_0001:  ldarg.1
    IL_0002:  conv.r8
    IL_0003:  ldarg.0
    IL_0004:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0009:  conv.r8
    IL_000a:  ldc.r8     2.
    IL_0013:  div
    IL_0014:  sub
    IL_0015:  neg
    IL_0016:  ldc.r8     2.
    IL_001f:  ldarg.0
    IL_0020:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0025:  conv.r8
    IL_0026:  mul
    IL_0027:  div
    IL_0028:  newobj     instance void class '<>f__AnonymousType0`2'<int32,float64>::.ctor(!0,
                                                                                           !1)
    IL_002d:  stloc.0
    IL_002e:  br.s       IL_0030

//000147:                 select from x in Enumerable.Range(0, screenWidth)
//000148:                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
//000149:                        let point =
//000150:                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
//000151:                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
//000152:                                                                Vector.Times(recenterY, scene.Camera.Up))))
//000153:                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
//000154:                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
//000155:                         (f => traceRayArgs =>
//000156:                          (from isect in
//000157:                               from thing in traceRayArgs.Scene.Things
//000158:                               select thing.Intersect(traceRayArgs.Ray)
//000159:                           where isect != null
//000160:                           orderby isect.Dist
//000161:                           let d = isect.Ray.Dir
//000162:                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
//000163:                           let normal = isect.Thing.Normal(pos)
//000164:                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
//000165:                           let naturalColors =
//000166:                               from light in traceRayArgs.Scene.Lights
//000167:                               let ldis = Vector.Minus(light.Pos, pos)
//000168:                               let livec = Vector.Norm(ldis)
//000169:                               let testRay = new Ray() { Start = pos, Dir = livec }
//000170:                               let testIsects = from inter in
//000171:                                                    from thing in traceRayArgs.Scene.Things
//000172:                                                    select thing.Intersect(testRay)
//000173:                                                where inter != null
//000174:                                                orderby inter.Dist
//000175:                                                select inter
//000176:                               let testIsect = testIsects.FirstOrDefault()
//000177:                               let neatIsect = testIsect == null ? 0 : testIsect.Dist
//000178:                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
//000179:                               where !isInShadow
//000180:                               let illum = Vector.Dot(livec, normal)
//000181:                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) : Color.Make(0, 0, 0)
//000182:                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
//000183:                               let scolor = specular > 0
//000184:                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
//000185:                                                            light.Color)
//000186:                                              : Color.Make(0, 0, 0)
//000187:                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
//000188:                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
//000189:                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
//000190:                           let reflectColor = traceRayArgs.Depth >= MaxDepth
//000191:                                               ? Color.Make(.5, .5, .5)
//000192:                                               : Color.Times(isect.Thing.Surface.Reflect(reflectPos),
//000193:                                                             f(new TraceRayArgs(new Ray()
//000194:                                                             {
//000195:                                                                 Start = reflectPos,
//000196:                                                                 Dir = reflectDir
//000197:                                                             },
//000198:                                                                                traceRayArgs.Scene,
//000199:                                                                                traceRayArgs.Depth + 1)))
//000200:                           select naturalColors.Aggregate(reflectColor,
//000201:                                                          (color, natColor) => Color.Plus(color, natColor))
//000202:                          ).DefaultIfEmpty(Color.Background).First())
//000203:                        let traceRay = Y(computeTraceRay)
//000204:                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
//000205: 
//000206:             int rowsProcessed = 0;
//000207: 
//000208:             pixelsQuery.ForAll(row =>
//000209:             {
//000210:                 foreach (var pixel in row)
//000211:                 {
//000212:                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
//000213:                 }
//000214:                 int processed = Interlocked.Increment(ref rowsProcessed);
//000215:                 if (processed % rowsPerUpdate == 0 ||
//000216:                     processed >= screenHeight) updateImageHandler(rgb);
//000217:             });
//000218:         }
//000219: 
//000220:         internal readonly Scene DefaultScene =
//000221:             new Scene()
//000222:             {
//000223:                 Things = new SceneObject[] { 
//000224:                                 new Plane() {
//000225:                                     Norm = Vector.Make(0,1,0),
//000226:                                     Offset = 0,
//000227:                                     Surface = Surfaces.CheckerBoard
//000228:                                 },
//000229:                                 new Sphere() {
//000230:                                     Center = Vector.Make(0,1,0),
//000231:                                     Radius = 1,
//000232:                                     Surface = Surfaces.Shiny
//000233:                                 },
//000234:                                 new Sphere() {
//000235:                                     Center = Vector.Make(-1,.5,1.5),
//000236:                                     Radius = .5,
//000237:                                     Surface = Surfaces.Shiny
//000238:                                 }},
//000239:                 Lights = new Light[] { 
//000240:                                 new Light() {
//000241:                                     Pos = Vector.Make(-2,2.5,0),
//000242:                                     Color = Color.Make(.49,.07,.07)
//000243:                                 },
//000244:                                 new Light() {
//000245:                                     Pos = Vector.Make(1.5,2.5,1.5),
//000246:                                     Color = Color.Make(.07,.07,.49)
//000247:                                 },
//000248:                                 new Light() {
//000249:                                     Pos = Vector.Make(1.5,2.5,-1.5),
//000250:                                     Color = Color.Make(.07,.49,.071)
//000251:                                 },
//000252:                                 new Light() {
//000253:                                     Pos = Vector.Make(0,3.5,0),
//000254:                                     Color = Color.Make(.21,.21,.35)
//000255:                                 }},
//000256:                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
//000257:             };
//000258:     }
//000259: 
//000260:     static class Surfaces
//000261:     {
//000262:         // Only works with X-Z plane.
//000263:         public static readonly Surface CheckerBoard =
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method RayTracer::'<RenderParallel>b__a2'

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer

.class private abstract auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces
       extends [mscorlib]System.Object
{
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface CheckerBoard
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Shiny
  .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegate8'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegate9'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> 'CS$<>9__CachedAnonymousMethodDelegatea'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegateb'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegatec'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> 'CS$<>9__CachedAnonymousMethodDelegated'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       277 (0x115)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface '<>g__initLocal0',
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface '<>g__initLocal1')
//000263:         public static readonly Surface CheckerBoard =
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate8'
    IL_000c:  brtrue.s   IL_0021

    IL_000e:  ldnull
    IL_000f:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__2'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0015:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                    native int)
    IL_001a:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate8'
    IL_001f:  br.s       IL_0021

    IL_0021:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate8'
    IL_0026:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Diffuse
    IL_002b:  ldloc.0
    IL_002c:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate9'
    IL_0031:  brtrue.s   IL_0046

    IL_0033:  ldnull
    IL_0034:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__3'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_003a:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                    native int)
    IL_003f:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate9'
    IL_0044:  br.s       IL_0046

    IL_0046:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate9'
    IL_004b:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Specular
    IL_0050:  ldloc.0
    IL_0051:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatea'
    IL_0056:  brtrue.s   IL_006b

    IL_0058:  ldnull
    IL_0059:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__4'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_005f:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::.ctor(object,
                                                                                                                                                                 native int)
    IL_0064:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatea'
    IL_0069:  br.s       IL_006b

    IL_006b:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatea'
    IL_0070:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Reflect
    IL_0075:  ldloc.0
    IL_0076:  ldc.r8     150.
    IL_007f:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Roughness
    IL_0084:  ldloc.0
    IL_0085:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::CheckerBoard
//000264:             new Surface()
//000265:             {
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
    IL_008a:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::.ctor()
    IL_008f:  stloc.1
    IL_0090:  ldloc.1
    IL_0091:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegateb'
    IL_0096:  brtrue.s   IL_00ab

    IL_0098:  ldnull
    IL_0099:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__5'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_009f:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                    native int)
    IL_00a4:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegateb'
    IL_00a9:  br.s       IL_00ab

    IL_00ab:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegateb'
    IL_00b0:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Diffuse
    IL_00b5:  ldloc.1
    IL_00b6:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatec'
    IL_00bb:  brtrue.s   IL_00d0

    IL_00bd:  ldnull
    IL_00be:  ldftn      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__6'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00c4:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                    native int)
    IL_00c9:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatec'
    IL_00ce:  br.s       IL_00d0

    IL_00d0:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatec'
    IL_00d5:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Specular
    IL_00da:  ldloc.1
    IL_00db:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegated'
    IL_00e0:  brtrue.s   IL_00f5

    IL_00e2:  ldnull
    IL_00e3:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__7'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00e9:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::.ctor(object,
                                                                                                                                                                 native int)
    IL_00ee:  stsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegated'
    IL_00f3:  br.s       IL_00f5

    IL_00f5:  ldsfld     class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegated'
    IL_00fa:  stfld      class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Reflect
    IL_00ff:  ldloc.1
    IL_0100:  ldc.r8     50.
    IL_0109:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Roughness
    IL_010e:  ldloc.1
    IL_010f:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::Shiny
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0114:  ret
  } // end of method Surfaces::.cctor

  .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__2'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       115 (0x73)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000266:                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0006:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_000b:  ldarg.0
    IL_000c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0011:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_0016:  add
    IL_0017:  ldc.r8     2.
    IL_0020:  rem
    IL_0021:  ldc.r8     0.0
    IL_002a:  bne.un.s   IL_004e

    IL_002c:  ldc.r8     0.0
    IL_0035:  ldc.r8     0.0
    IL_003e:  ldc.r8     0.0
    IL_0047:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_004c:  br.s       IL_006e

    IL_004e:  ldc.r8     1.
    IL_0057:  ldc.r8     1.
    IL_0060:  ldc.r8     1.
    IL_0069:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_006e:  stloc.0
    IL_006f:  br.s       IL_0071

//000267:                                     ? Color.Make(1, 1, 1)
//000268:                                     : Color.Make(0, 0, 0),
//000269:                 Specular = pos => Color.Make(1, 1, 1),
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0071:  ldloc.0
    IL_0072:  ret
  } // end of method Surfaces::'<.cctor>b__2'

  .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__3'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       37 (0x25)
    .maxstack  3
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000269:                 Specular = pos => Color.Make(1, 1, 1),
    IL_0000:  ldc.r8     1.
    IL_0009:  ldc.r8     1.
    IL_0012:  ldc.r8     1.
    IL_001b:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_0020:  stloc.0
    IL_0021:  br.s       IL_0023

//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0023:  ldloc.0
    IL_0024:  ret
  } // end of method Surfaces::'<.cctor>b__3'

  .method private hidebysig static float64 
          '<.cctor>b__4'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       69 (0x45)
    .maxstack  2
    .locals init ([0] float64 CS$1$0000)
//000270:                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0006:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_000b:  ldarg.0
    IL_000c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0011:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_0016:  add
    IL_0017:  ldc.r8     2.
    IL_0020:  rem
    IL_0021:  ldc.r8     0.0
    IL_002a:  bne.un.s   IL_0037

    IL_002c:  ldc.r8     0.69999999999999996
    IL_0035:  br.s       IL_0040

    IL_0037:  ldc.r8     0.10000000000000001
    IL_0040:  stloc.0
    IL_0041:  br.s       IL_0043

//000271:                                     ? .1
//000272:                                     : .7,
//000273:                 Roughness = 150
//000274:             };
//000275: 
//000276: 
//000277:         public static readonly Surface Shiny =
//000278:             new Surface()
//000279:             {
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0043:  ldloc.0
    IL_0044:  ret
  } // end of method Surfaces::'<.cctor>b__4'

  .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__5'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       37 (0x25)
    .maxstack  3
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000280:                 Diffuse = pos => Color.Make(1, 1, 1),
    IL_0000:  ldc.r8     1.
    IL_0009:  ldc.r8     1.
    IL_0012:  ldc.r8     1.
    IL_001b:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_0020:  stloc.0
    IL_0021:  br.s       IL_0023

//000281:                 Specular = pos => Color.Make(.5, .5, .5),
//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0023:  ldloc.0
    IL_0024:  ret
  } // end of method Surfaces::'<.cctor>b__5'

  .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__6'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       37 (0x25)
    .maxstack  3
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000281:                 Specular = pos => Color.Make(.5, .5, .5),
    IL_0000:  ldc.r8     0.5
    IL_0009:  ldc.r8     0.5
    IL_0012:  ldc.r8     0.5
    IL_001b:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_0020:  stloc.0
    IL_0021:  br.s       IL_0023

//000282:                 Reflect = pos => .6,
//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0023:  ldloc.0
    IL_0024:  ret
  } // end of method Surfaces::'<.cctor>b__6'

  .method private hidebysig static float64 
          '<.cctor>b__7'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       14 (0xe)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000)
//000282:                 Reflect = pos => .6,
    IL_0000:  ldc.r8     0.59999999999999998
    IL_0009:  stloc.0
    IL_000a:  br.s       IL_000c

//000283:                 Roughness = 50
//000284:             };
//000285:     }
//000286: 
//000287:     class Vector
//000288:     {
//000289:         public readonly double X;
//000290:         public readonly double Y;
//000291:         public readonly double Z;
//000292: 
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000299:         }
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000303:         }
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000307:         }
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000311:         }
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000313:         public static Vector Norm(Vector v)
//000314:         {
//000315:             double mag = Mag(v);
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000317:             return Times(div, v);
//000318:         }
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000328:         }
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
//000344:         }
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000348:         }
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000353:         }
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000357:         }
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_000c:  ldloc.0
    IL_000d:  ret
  } // end of method Surfaces::'<.cctor>b__7'

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector
       extends [mscorlib]System.Object
{
  .field public initonly float64 X
  .field public initonly float64 Y
  .field public initonly float64 Z
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(float64 x,
                               float64 y,
                               float64 z) cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  8
//000293:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000f:  ldarg.0
    IL_0010:  ldarg.2
    IL_0011:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0016:  ldarg.0
    IL_0017:  ldarg.3
    IL_0018:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_001d:  nop
    IL_001e:  ret
  } // end of method Vector::.ctor

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Make(float64 x,
               float64 y,
               float64 z) cil managed
  {
    // Code size       14 (0xe)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000294: 
//000295:         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.2
    IL_0004:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0009:  stloc.0
    IL_000a:  br.s       IL_000c

    IL_000c:  ldloc.0
    IL_000d:  ret
  } // end of method Vector::Make

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Times(float64 n,
                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v) cil managed
  {
    // Code size       35 (0x23)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000296:         public static Vector Times(double n, Vector v)
//000297:         {
    IL_0000:  nop
//000298:             return new Vector(v.X * n, v.Y * n, v.Z * n);
    IL_0001:  ldarg.1
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0007:  ldarg.0
    IL_0008:  mul
    IL_0009:  ldarg.1
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_000f:  ldarg.0
    IL_0010:  mul
    IL_0011:  ldarg.1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0017:  ldarg.0
    IL_0018:  mul
    IL_0019:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_001e:  stloc.0
    IL_001f:  br.s       IL_0021

//000299:         }
    IL_0021:  ldloc.0
    IL_0022:  ret
  } // end of method Vector::Times

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000300:         public static Vector Minus(Vector v1, Vector v2)
//000301:         {
    IL_0000:  nop
//000302:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000d:  sub
    IL_000e:  ldarg.0
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0014:  ldarg.1
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001a:  sub
    IL_001b:  ldarg.0
    IL_001c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0021:  ldarg.1
    IL_0022:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0027:  sub
    IL_0028:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_002d:  stloc.0
    IL_002e:  br.s       IL_0030

//000303:         }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method Vector::Minus

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
               class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000304:         public static Vector Plus(Vector v1, Vector v2)
//000305:         {
    IL_0000:  nop
//000306:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000d:  add
    IL_000e:  ldarg.0
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0014:  ldarg.1
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001a:  add
    IL_001b:  ldarg.0
    IL_001c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0021:  ldarg.1
    IL_0022:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0027:  add
    IL_0028:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_002d:  stloc.0
    IL_002e:  br.s       IL_0030

//000307:         }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method Vector::Plus

  .method public hidebysig static float64 
          Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
              class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       47 (0x2f)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000308:         public static double Dot(Vector v1, Vector v2)
//000309:         {
    IL_0000:  nop
//000310:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000d:  mul
    IL_000e:  ldarg.0
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0014:  ldarg.1
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001a:  mul
    IL_001b:  add
    IL_001c:  ldarg.0
    IL_001d:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0022:  ldarg.1
    IL_0023:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0028:  mul
    IL_0029:  add
    IL_002a:  stloc.0
    IL_002b:  br.s       IL_002d

//000311:         }
    IL_002d:  ldloc.0
    IL_002e:  ret
  } // end of method Vector::Dot

  .method public hidebysig static float64 
          Mag(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v) cil managed
  {
    // Code size       18 (0x12)
    .maxstack  2
    .locals init ([0] float64 CS$1$0000)
//000312:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0008:  call       float64 [mscorlib]System.Math::Sqrt(float64)
    IL_000d:  stloc.0
    IL_000e:  br.s       IL_0010

    IL_0010:  ldloc.0
    IL_0011:  ret
  } // end of method Vector::Mag

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v) cil managed
  {
    // Code size       55 (0x37)
    .maxstack  2
    .locals init ([0] float64 mag,
             [1] float64 'div',
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000313:         public static Vector Norm(Vector v)
//000314:         {
    IL_0000:  nop
//000315:             double mag = Mag(v);
    IL_0001:  ldarg.0
    IL_0002:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Mag(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0007:  stloc.0
//000316:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
    IL_0008:  ldloc.0
    IL_0009:  ldc.r8     0.0
    IL_0012:  beq.s      IL_0021

    IL_0014:  ldc.r8     1.
    IL_001d:  ldloc.0
    IL_001e:  div
    IL_001f:  br.s       IL_002a

    IL_0021:  ldc.r8     (00 00 00 00 00 00 F0 7F)
    IL_002a:  stloc.1
//000317:             return Times(div, v);
    IL_002b:  ldloc.1
    IL_002c:  ldarg.0
    IL_002d:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0032:  stloc.2
    IL_0033:  br.s       IL_0035

//000318:         }
    IL_0035:  ldloc.2
    IL_0036:  ret
  } // end of method Vector::Norm

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Cross(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       92 (0x5c)
    .maxstack  5
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000319:         public static Vector Cross(Vector v1, Vector v2)
//000320:         {
    IL_0000:  nop
//000321:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_000d:  mul
    IL_000e:  ldarg.0
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0014:  ldarg.1
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001a:  mul
    IL_001b:  sub
    IL_001c:  ldarg.0
    IL_001d:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0022:  ldarg.1
    IL_0023:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0028:  mul
    IL_0029:  ldarg.0
    IL_002a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_002f:  ldarg.1
    IL_0030:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0035:  mul
    IL_0036:  sub
    IL_0037:  ldarg.0
    IL_0038:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_003d:  ldarg.1
    IL_003e:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0043:  mul
    IL_0044:  ldarg.0
    IL_0045:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_004a:  ldarg.1
    IL_004b:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0050:  mul
    IL_0051:  sub
    IL_0052:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0057:  stloc.0
    IL_0058:  br.s       IL_005a

//000322:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000323:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000324:         }
    IL_005a:  ldloc.0
    IL_005b:  ret
  } // end of method Vector::Cross

  .method public hidebysig static bool  Equals(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
                                               class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       51 (0x33)
    .maxstack  2
    .locals init ([0] bool CS$1$0000)
//000325:         public static bool Equals(Vector v1, Vector v2)
//000326:         {
    IL_0000:  nop
//000327:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000d:  bne.un.s   IL_002d

    IL_000f:  ldarg.0
    IL_0010:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0015:  ldarg.1
    IL_0016:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001b:  bne.un.s   IL_002d

    IL_001d:  ldarg.0
    IL_001e:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0023:  ldarg.1
    IL_0024:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0029:  ceq
    IL_002b:  br.s       IL_002e

    IL_002d:  ldc.i4.0
    IL_002e:  stloc.0
    IL_002f:  br.s       IL_0031

//000328:         }
    IL_0031:  ldloc.0
    IL_0032:  ret
  } // end of method Vector::Equals

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector

.class public auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color
       extends [mscorlib]System.Object
{
  .field public float64 R
  .field public float64 G
  .field public float64 B
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Background
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color DefaultColor
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(float64 r,
                               float64 g,
                               float64 b) cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  8
//000329:     }
//000330: 
//000331:     public class Color
//000332:     {
//000333:         public double R;
//000334:         public double G;
//000335:         public double B;
//000336: 
//000337:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000f:  ldarg.0
    IL_0010:  ldarg.2
    IL_0011:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0016:  ldarg.0
    IL_0017:  ldarg.3
    IL_0018:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_001d:  nop
    IL_001e:  ret
  } // end of method Color::.ctor

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Make(float64 r,
               float64 g,
               float64 b) cil managed
  {
    // Code size       14 (0xe)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000338: 
//000339:         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.2
    IL_0004:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0009:  stloc.0
    IL_000a:  br.s       IL_000c

    IL_000c:  ldloc.0
    IL_000d:  ret
  } // end of method Color::Make

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Times(float64 n,
                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v) cil managed
  {
    // Code size       35 (0x23)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000340: 
//000341:         public static Color Times(double n, Color v)
//000342:         {
    IL_0000:  nop
//000343:             return new Color(n * v.R, n * v.G, n * v.B);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0008:  mul
    IL_0009:  ldarg.0
    IL_000a:  ldarg.1
    IL_000b:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0010:  mul
    IL_0011:  ldarg.0
    IL_0012:  ldarg.1
    IL_0013:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0018:  mul
    IL_0019:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_001e:  stloc.0
    IL_001f:  br.s       IL_0021

//000344:         }
    IL_0021:  ldloc.0
    IL_0022:  ret
  } // end of method Color::Times

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Times(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v1,
                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v2) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000345:         public static Color Times(Color v1, Color v2)
//000346:         {
    IL_0000:  nop
//000347:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000d:  mul
    IL_000e:  ldarg.0
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0014:  ldarg.1
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_001a:  mul
    IL_001b:  ldarg.0
    IL_001c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0021:  ldarg.1
    IL_0022:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0027:  mul
    IL_0028:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_002d:  stloc.0
    IL_002e:  br.s       IL_0030

//000348:         }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method Color::Times

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Plus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v1,
               class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v2) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000349: 
//000350:         public static Color Plus(Color v1, Color v2)
//000351:         {
    IL_0000:  nop
//000352:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000d:  add
    IL_000e:  ldarg.0
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0014:  ldarg.1
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_001a:  add
    IL_001b:  ldarg.0
    IL_001c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0021:  ldarg.1
    IL_0022:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0027:  add
    IL_0028:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_002d:  stloc.0
    IL_002e:  br.s       IL_0030

//000353:         }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method Color::Plus

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v1,
                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v2) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000354:         public static Color Minus(Color v1, Color v2)
//000355:         {
    IL_0000:  nop
//000356:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0007:  ldarg.1
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000d:  sub
    IL_000e:  ldarg.0
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0014:  ldarg.1
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_001a:  sub
    IL_001b:  ldarg.0
    IL_001c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0021:  ldarg.1
    IL_0022:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0027:  sub
    IL_0028:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_002d:  stloc.0
    IL_002e:  br.s       IL_0030

//000357:         }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method Color::Minus

  .method private hidebysig instance float64 
          Legalize(float64 d) cil managed
  {
    // Code size       30 (0x1e)
    .maxstack  2
    .locals init ([0] float64 CS$1$0000)
//000358: 
//000359:         public static readonly Color Background = Make(0, 0, 0);
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
    IL_0000:  nop
//000364:             return d > 1 ? 1 : d;
    IL_0001:  ldarg.1
    IL_0002:  ldc.r8     1.
    IL_000b:  bgt.s      IL_0010

    IL_000d:  ldarg.1
    IL_000e:  br.s       IL_0019

    IL_0010:  ldc.r8     1.
    IL_0019:  stloc.0
    IL_001a:  br.s       IL_001c

//000365:         }
    IL_001c:  ldloc.0
    IL_001d:  ret
  } // end of method Color::Legalize

  .method public hidebysig instance valuetype [System.Drawing]System.Drawing.Color 
          ToDrawingColor() cil managed
  {
    // Code size       80 (0x50)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Color CS$1$0000)
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
    IL_0000:  nop
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0008:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Legalize(float64)
    IL_000d:  ldc.r8     255.
    IL_0016:  mul
    IL_0017:  conv.i4
    IL_0018:  ldarg.0
    IL_0019:  ldarg.0
    IL_001a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_001f:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Legalize(float64)
    IL_0024:  ldc.r8     255.
    IL_002d:  mul
    IL_002e:  conv.i4
    IL_002f:  ldarg.0
    IL_0030:  ldarg.0
    IL_0031:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0036:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Legalize(float64)
    IL_003b:  ldc.r8     255.
    IL_0044:  mul
    IL_0045:  conv.i4
    IL_0046:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_004b:  stloc.0
    IL_004c:  br.s       IL_004e

//000370:         }
    IL_004e:  ldloc.0
    IL_004f:  ret
  } // end of method Color::ToDrawingColor

  .method public hidebysig instance int32 
          ToInt32() cil managed
  {
    // Code size       88 (0x58)
    .maxstack  3
    .locals init ([0] int32 CS$1$0000)
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
    IL_0000:  nop
//000374:             return
    IL_0001:  ldc.i4     0xff000000
    IL_0006:  ldarg.0
    IL_0007:  ldarg.0
    IL_0008:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000d:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Legalize(float64)
    IL_0012:  ldc.r8     255.
    IL_001b:  mul
    IL_001c:  conv.i4
    IL_001d:  ldc.i4.s   16
    IL_001f:  shl
    IL_0020:  or
    IL_0021:  ldarg.0
    IL_0022:  ldarg.0
    IL_0023:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0028:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Legalize(float64)
    IL_002d:  ldc.r8     255.
    IL_0036:  mul
    IL_0037:  conv.i4
    IL_0038:  ldc.i4.8
    IL_0039:  shl
    IL_003a:  or
    IL_003b:  ldarg.0
    IL_003c:  ldarg.0
    IL_003d:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0042:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Legalize(float64)
    IL_0047:  ldc.r8     255.
    IL_0050:  mul
    IL_0051:  conv.i4
    IL_0052:  or
    IL_0053:  stloc.0
    IL_0054:  br.s       IL_0056

//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
    IL_0056:  ldloc.0
    IL_0057:  ret
  } // end of method Color::ToInt32

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       75 (0x4b)
    .maxstack  3
//000359:         public static readonly Color Background = Make(0, 0, 0);
    IL_0000:  ldc.r8     0.0
    IL_0009:  ldc.r8     0.0
    IL_0012:  ldc.r8     0.0
    IL_001b:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_0020:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Background
//000360:         public static readonly Color DefaultColor = Make(0, 0, 0);
    IL_0025:  ldc.r8     0.0
    IL_002e:  ldc.r8     0.0
    IL_0037:  ldc.r8     0.0
    IL_0040:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Make(float64,
                                                                                                                                                                               float64,
                                                                                                                                                                               float64)
    IL_0045:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::DefaultColor
//000361: 
//000362:         private double Legalize(double d)
//000363:         {
//000364:             return d > 1 ? 1 : d;
//000365:         }
//000366: 
//000367:         public System.Drawing.Color ToDrawingColor()
//000368:         {
//000369:             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
//000370:         }
//000371: 
//000372:         public Int32 ToInt32()
//000373:         {
//000374:             return
//000375:                 (255 << 24) |
//000376:                 ((int)(Legalize(R) * 255)) << 16 |
//000377:                 ((int)(Legalize(G) * 255)) << 8 |
//000378:                 ((int)(Legalize(B) * 255));
//000379:         }
//000380:     }
//000381: 
//000382:     class Ray
//000383:     {
//000384:         public Vector Start;
//000385:         public Vector Dir;
//000386:     }
//000387: 
//000388:     class ISect
//000389:     {
//000390:         public SceneObject Thing;
//000391:         public Ray Ray;
//000392:         public double Dist;
//000393:     }
//000394: 
//000395:     class Surface
//000396:     {
//000397:         public Func<Vector, Color> Diffuse;
//000398:         public Func<Vector, Color> Specular;
//000399:         public Func<Vector, double> Reflect;
//000400:         public double Roughness;
//000401:     }
//000402: 
//000403:     class Camera
//000404:     {
//000405:         public Vector Pos;
//000406:         public Vector Forward;
//000407:         public Vector Up;
//000408:         public Vector Right;
//000409: 
//000410:         public static Camera Create(Vector pos, Vector lookAt)
//000411:         {
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
//000413:             Vector down = new Vector(0, -1, 0);
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
//000418:         }
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
//000442:             double v = Vector.Dot(eo, ray.Dir);
//000443:             double dist;
//000444:             if (v < 0)
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_004a:  ret
  } // end of method Color::.cctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray
       extends [mscorlib]System.Object
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Start
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Dir
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method Ray::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect
       extends [mscorlib]System.Object
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Thing
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Ray
  .field public float64 Dist
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method ISect::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface
       extends [mscorlib]System.Object
{
  .field public class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Diffuse
  .field public class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Specular
  .field public class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Reflect
  .field public float64 Roughness
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method Surface::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera
       extends [mscorlib]System.Object
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Pos
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Forward
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Up
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Right
  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera 
          Create(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos,
                 class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector lookAt) cil managed
  {
    // Code size       149 (0x95)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector forward,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector down,
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector right,
             [3] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector up,
             [4] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera '<>g__initLocal0',
             [5] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera CS$1$0000)
//000411:         {
    IL_0000:  nop
//000412:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0008:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_000d:  stloc.0
//000413:             Vector down = new Vector(0, -1, 0);
    IL_000e:  ldc.r8     0.0
    IL_0017:  ldc.r8     -1.
    IL_0020:  ldc.r8     0.0
    IL_0029:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_002e:  stloc.1
//000414:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
    IL_002f:  ldc.r8     1.5
    IL_0038:  ldloc.0
    IL_0039:  ldloc.1
    IL_003a:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Cross(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_003f:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0044:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0049:  stloc.2
//000415:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
    IL_004a:  ldc.r8     1.5
    IL_0053:  ldloc.0
    IL_0054:  ldloc.2
    IL_0055:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Cross(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_005a:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_005f:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0064:  stloc.3
//000416: 
//000417:             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
    IL_0065:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::.ctor()
    IL_006a:  stloc.s    '<>g__initLocal0'
    IL_006c:  ldloc.s    '<>g__initLocal0'
    IL_006e:  ldarg.0
    IL_006f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Pos
    IL_0074:  ldloc.s    '<>g__initLocal0'
    IL_0076:  ldloc.0
    IL_0077:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Forward
    IL_007c:  ldloc.s    '<>g__initLocal0'
    IL_007e:  ldloc.3
    IL_007f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Up
    IL_0084:  ldloc.s    '<>g__initLocal0'
    IL_0086:  ldloc.2
    IL_0087:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Right
    IL_008c:  ldloc.s    '<>g__initLocal0'
    IL_008e:  stloc.s    CS$1$0000
    IL_0090:  br.s       IL_0092

//000418:         }
    IL_0092:  ldloc.s    CS$1$0000
    IL_0094:  ret
  } // end of method Camera::Create

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method Camera::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light
       extends [mscorlib]System.Object
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Pos
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Color
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method Light::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light

.class private abstract auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
       extends [mscorlib]System.Object
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Surface
  .method public hidebysig newslot abstract virtual 
          instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
          Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray) cil managed
  {
  } // end of method SceneObject::Intersect

  .method public hidebysig newslot abstract virtual 
          instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Normal(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
  } // end of method SceneObject::Normal

  .method family hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method SceneObject::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere
       extends Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Center
  .field public float64 Radius
  .method public hidebysig virtual instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
          Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray) cil managed
  {
    // Code size       212 (0xd4)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector eo,
             [1] float64 v,
             [2] float64 dist,
             [3] float64 disc,
             [4] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect '<>g__initLocal0',
             [5] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000,
             [6] bool CS$4$0001)
//000419:     }
//000420: 
//000421:     class Light
//000422:     {
//000423:         public Vector Pos;
//000424:         public Color Color;
//000425:     }
//000426: 
//000427:     abstract class SceneObject
//000428:     {
//000429:         public Surface Surface;
//000430:         public abstract ISect Intersect(Ray ray);
//000431:         public abstract Vector Normal(Vector pos);
//000432:     }
//000433: 
//000434:     class Sphere : SceneObject
//000435:     {
//000436:         public Vector Center;
//000437:         public double Radius;
//000438: 
//000439:         public override ISect Intersect(Ray ray)
//000440:         {
    IL_0000:  nop
//000441:             Vector eo = Vector.Minus(Center, ray.Start);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_0007:  ldarg.1
    IL_0008:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
    IL_000d:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0012:  stloc.0
//000442:             double v = Vector.Dot(eo, ray.Dir);
    IL_0013:  ldloc.0
    IL_0014:  ldarg.1
    IL_0015:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
    IL_001a:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_001f:  stloc.1
//000443:             double dist;
//000444:             if (v < 0)
    IL_0020:  ldloc.1
    IL_0021:  ldc.r8     0.0
    IL_002a:  clt
    IL_002c:  ldc.i4.0
    IL_002d:  ceq
    IL_002f:  stloc.s    CS$4$0001
//000445:             {
//000446:                 dist = 0;
//000447:             }
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0031:  ldloc.s    CS$4$0001
    IL_0033:  brtrue.s   IL_0043

//000445:             {
    IL_0035:  nop
//000446:                 dist = 0;
    IL_0036:  ldc.r8     0.0
    IL_003f:  stloc.2
//000447:             }
    IL_0040:  nop
//000448:             else
//000449:             {
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000452:             }
//000453:             if (dist == 0) return null;
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0041:  br.s       IL_0092

//000449:             {
    IL_0043:  nop
//000450:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
    IL_0044:  ldarg.0
    IL_0045:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Radius
    IL_004a:  ldc.r8     2.
    IL_0053:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                            float64)
    IL_0058:  ldloc.0
    IL_0059:  ldloc.0
    IL_005a:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_005f:  ldloc.1
    IL_0060:  ldc.r8     2.
    IL_0069:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                            float64)
    IL_006e:  sub
    IL_006f:  sub
    IL_0070:  stloc.3
//000451:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
    IL_0071:  ldloc.3
    IL_0072:  ldc.r8     0.0
    IL_007b:  blt.s      IL_0087

    IL_007d:  ldloc.1
    IL_007e:  ldloc.3
    IL_007f:  call       float64 [mscorlib]System.Math::Sqrt(float64)
    IL_0084:  sub
    IL_0085:  br.s       IL_0090

    IL_0087:  ldc.r8     0.0
    IL_0090:  stloc.2
//000452:             }
    IL_0091:  nop
//000453:             if (dist == 0) return null;
    IL_0092:  ldloc.2
    IL_0093:  ldc.r8     0.0
    IL_009c:  ceq
    IL_009e:  ldc.i4.0
    IL_009f:  ceq
    IL_00a1:  stloc.s    CS$4$0001
//000454:             return new ISect()
//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
//000465:         }
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
//000476:             if (denom > 0) return null;
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_00a3:  ldloc.s    CS$4$0001
    IL_00a5:  brtrue.s   IL_00ac

//000453:             if (dist == 0) return null;
    IL_00a7:  ldnull
    IL_00a8:  stloc.s    CS$1$0000
    IL_00aa:  br.s       IL_00d1

//000454:             return new ISect()
    IL_00ac:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::.ctor()
    IL_00b1:  stloc.s    '<>g__initLocal0'
    IL_00b3:  ldloc.s    '<>g__initLocal0'
    IL_00b5:  ldarg.0
    IL_00b6:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
    IL_00bb:  ldloc.s    '<>g__initLocal0'
    IL_00bd:  ldarg.1
    IL_00be:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
    IL_00c3:  ldloc.s    '<>g__initLocal0'
    IL_00c5:  ldloc.2
    IL_00c6:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
    IL_00cb:  ldloc.s    '<>g__initLocal0'
    IL_00cd:  stloc.s    CS$1$0000
    IL_00cf:  br.s       IL_00d1

//000455:                    {
//000456:                        Thing = this,
//000457:                        Ray = ray,
//000458:                        Dist = dist
//000459:                    };
//000460:         }
    IL_00d1:  ldloc.s    CS$1$0000
    IL_00d3:  ret
  } // end of method Sphere::Intersect

  .method public hidebysig virtual instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Normal(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    // Code size       23 (0x17)
    .maxstack  2
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000461: 
//000462:         public override Vector Normal(Vector pos)
//000463:         {
    IL_0000:  nop
//000464:             return Vector.Norm(Vector.Minus(pos, Center));
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_0008:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_000d:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0012:  stloc.0
    IL_0013:  br.s       IL_0015

//000465:         }
    IL_0015:  ldloc.0
    IL_0016:  ret
  } // end of method Sphere::Normal

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::.ctor()
    IL_0006:  ret
  } // end of method Sphere::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane
       extends Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Norm
  .field public float64 Offset
  .method public hidebysig virtual instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
          Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray) cil managed
  {
    // Code size       101 (0x65)
    .maxstack  3
    .locals init ([0] float64 denom,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect '<>g__initLocal0',
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000,
             [3] bool CS$4$0001)
//000466:     }
//000467: 
//000468:     class Plane : SceneObject
//000469:     {
//000470:         public Vector Norm;
//000471:         public double Offset;
//000472: 
//000473:         public override ISect Intersect(Ray ray)
//000474:         {
    IL_0000:  nop
//000475:             double denom = Vector.Dot(Norm, ray.Dir);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_0007:  ldarg.1
    IL_0008:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
    IL_000d:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0012:  stloc.0
//000476:             if (denom > 0) return null;
    IL_0013:  ldloc.0
    IL_0014:  ldc.r8     0.0
    IL_001d:  cgt
    IL_001f:  ldc.i4.0
    IL_0020:  ceq
    IL_0022:  stloc.3
//000477:             return new ISect()
//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
//000487:             return Norm;
//000488:         }
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
//000501:         }
//000502:     }
//000503: }
    IL_0023:  ldloc.3
    IL_0024:  brtrue.s   IL_002a

//000476:             if (denom > 0) return null;
    IL_0026:  ldnull
    IL_0027:  stloc.2
    IL_0028:  br.s       IL_0063

//000477:             return new ISect()
    IL_002a:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::.ctor()
    IL_002f:  stloc.1
    IL_0030:  ldloc.1
    IL_0031:  ldarg.0
    IL_0032:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
    IL_0037:  ldloc.1
    IL_0038:  ldarg.1
    IL_0039:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
    IL_003e:  ldloc.1
    IL_003f:  ldarg.0
    IL_0040:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_0045:  ldarg.1
    IL_0046:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
    IL_004b:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0050:  ldarg.0
    IL_0051:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Offset
    IL_0056:  add
    IL_0057:  ldloc.0
    IL_0058:  neg
    IL_0059:  div
    IL_005a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
    IL_005f:  ldloc.1
    IL_0060:  stloc.2
    IL_0061:  br.s       IL_0063

//000478:                    {
//000479:                        Thing = this,
//000480:                        Ray = ray,
//000481:                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
//000482:                    };
//000483:         }
    IL_0063:  ldloc.2
    IL_0064:  ret
  } // end of method Plane::Intersect

  .method public hidebysig virtual instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Normal(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000484: 
//000485:         public override Vector Normal(Vector pos)
//000486:         {
    IL_0000:  nop
//000487:             return Norm;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000488:         }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method Plane::Normal

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::.ctor()
    IL_0006:  ret
  } // end of method Plane::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene
       extends [mscorlib]System.Object
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass1'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray r
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass1'::.ctor

    .method public hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
            '<Intersect>b__0'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing) cil managed
    {
      // Code size       17 (0x11)
      .maxstack  2
      .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000)
//000489:     }
//000490: 
//000491:     class Scene
//000492:     {
//000493:         public SceneObject[] Things;
//000494:         public Light[] Lights;
//000495:         public Camera Camera;
//000496: 
//000497:         public IEnumerable<ISect> Intersect(Ray r)
//000498:         {
//000499:             return from thing in Things
//000500:                    select thing.Intersect(r);
      IL_0000:  ldarg.1
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<>c__DisplayClass1'::r
      IL_0007:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray)
      IL_000c:  stloc.0
      IL_000d:  br.s       IL_000f

//000501:         }
//000502:     }
//000503: }
      IL_000f:  ldloc.0
      IL_0010:  ret
    } // end of method '<>c__DisplayClass1'::'<Intersect>b__0'

  } // end of class '<>c__DisplayClass1'

  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Things
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] Lights
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Camera
  .method public hidebysig instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> 
          Intersect(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray r) cil managed
  {
    // Code size       42 (0x2a)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<>c__DisplayClass1' 'CS$<>8__locals2',
             [1] class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> CS$1$0000)
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<>c__DisplayClass1'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<>c__DisplayClass1'::r
//000498:         {
    IL_000d:  nop
//000499:             return from thing in Things
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
    IL_0014:  ldloc.0
    IL_0015:  ldftn      instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<>c__DisplayClass1'::'<Intersect>b__0'(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject)
    IL_001b:  newobj     instance void class [mscorlib]System.Func`2<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::.ctor(object,
                                                                                                                                                                                                                                         native int)
    IL_0020:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0025:  stloc.1
    IL_0026:  br.s       IL_0028

//000500:                    select thing.Intersect(r);
//000501:         }
    IL_0028:  ldloc.1
    IL_0029:  ret
  } // end of method Scene::Intersect

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method Scene::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs' 
//000031:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000032:         internal Resources() {
    IL_0007:  nop
//000033:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000034:         
//000035:         /// <summary>
//000036:         ///   Returns the cached ResourceManager instance used by this class.
//000037:         /// </summary>
//000038:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000039:         internal static global::System.Resources.ResourceManager ResourceManager {
//000040:             get {
    IL_0000:  nop
//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  call       bool [mscorlib]System.Object::ReferenceEquals(object,
                                                                       object)
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.2
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resourc" +
//000043:                             "es", typeof(Resources).Assembly);
//000044:                     resourceMan = temp;
//000045:                 }
//000046:                 return resourceMan;
//000047:             }
//000048:         }
//000049:         
//000050:         /// <summary>
//000051:         ///   Overrides the current thread's CurrentUICulture property for all
//000052:         ///   resource lookups using this strongly typed resource class.
//000053:         /// </summary>
//000054:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000055:         internal static global::System.Globalization.CultureInfo Culture {
//000056:             get {
//000057:                 return resourceCulture;
//000058:             }
//000059:             set {
//000060:                 resourceCulture = value;
//000061:             }
//000062:         }
//000063:     }
//000064: }
    IL_0010:  ldloc.2
    IL_0011:  brtrue.s   IL_0035

//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0013:  nop
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resourc" +
    IL_0014:  ldstr      "Microsoft.ParallelComputingPlatform.ParallelExtens"
    + "ions.Samples.Properties.Resources"
    IL_0019:  ldtoken    Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources
    IL_001e:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0023:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0028:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002d:  stloc.0
//000043:                             "es", typeof(Resources).Assembly);
//000044:                     resourceMan = temp;
    IL_002e:  ldloc.0
    IL_002f:  stsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
//000045:                 }
    IL_0034:  nop
//000046:                 return resourceMan;
    IL_0035:  ldsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
    IL_003a:  stloc.1
    IL_003b:  br.s       IL_003d

//000047:             }
    IL_003d:  ldloc.1
    IL_003e:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000048:         }
//000049:         
//000050:         /// <summary>
//000051:         ///   Overrides the current thread's CurrentUICulture property for all
//000052:         ///   resource lookups using this strongly typed resource class.
//000053:         /// </summary>
//000054:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000055:         internal static global::System.Globalization.CultureInfo Culture {
//000056:             get {
    IL_0000:  nop
//000057:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000058:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000059:             set {
    IL_0000:  nop
//000060:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
//000061:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_Culture()
    .set void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
  } // end of property Resources::Culture
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType0`2'<'<y>j__TPar','<recenterY>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 25 5C 7B 20 79 20 3D 20 7B 79 7D 2C 20 72   // ..%\{ y = {y}, r
                                                                                                 65 63 65 6E 74 65 72 59 20 3D 20 7B 72 65 63 65   // ecenterY = {rece
                                                                                                 6E 74 65 72 59 7D 20 7D 01 00 54 0E 04 54 79 70   // nterY} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<y>j__TPar' '<y>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<recenterY>j__TPar' '<recenterY>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<y>j__TPar' y,
                               !'<recenterY>j__TPar' recenterY) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<y>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<recenterY>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType0`2'::.ctor

  .method public hidebysig specialname instance !'<y>j__TPar' 
          get_y() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<y>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<y>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType0`2'::get_y

  .method public hidebysig specialname instance !'<recenterY>j__TPar' 
          get_recenterY() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<recenterY>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<recenterY>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType0`2'::get_recenterY

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ y = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<y>i__Field'
    IL_0019:  box        !'<y>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", recenterY = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<recenterY>i__Field'
    IL_0037:  box        !'<recenterY>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType0`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<y>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<y>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<y>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<y>j__TPar'>::Equals(!0,
                                                                                                                            !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterY>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<recenterY>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<recenterY>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterY>j__TPar'>::Equals(!0,
                                                                                                                                    !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType0`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xe390b4e
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<y>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<y>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<y>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterY>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType0`2'<!'<y>j__TPar',!'<recenterY>j__TPar'>::'<recenterY>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterY>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType0`2'::GetHashCode

  .property instance !'<y>j__TPar' y()
  {
    .get instance !'<y>j__TPar' '<>f__AnonymousType0`2'::get_y()
  } // end of property '<>f__AnonymousType0`2'::y
  .property instance !'<recenterY>j__TPar'
          recenterY()
  {
    .get instance !'<recenterY>j__TPar' '<>f__AnonymousType0`2'::get_recenterY()
  } // end of property '<>f__AnonymousType0`2'::recenterY
} // end of class '<>f__AnonymousType0`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType1`2'<'<x>j__TPar','<recenterX>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 25 5C 7B 20 78 20 3D 20 7B 78 7D 2C 20 72   // ..%\{ x = {x}, r
                                                                                                 65 63 65 6E 74 65 72 58 20 3D 20 7B 72 65 63 65   // ecenterX = {rece
                                                                                                 6E 74 65 72 58 7D 20 7D 01 00 54 0E 04 54 79 70   // nterX} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<x>j__TPar' '<x>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<recenterX>j__TPar' '<recenterX>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<x>j__TPar' x,
                               !'<recenterX>j__TPar' recenterX) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<x>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<recenterX>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType1`2'::.ctor

  .method public hidebysig specialname instance !'<x>j__TPar' 
          get_x() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<x>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<x>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1`2'::get_x

  .method public hidebysig specialname instance !'<recenterX>j__TPar' 
          get_recenterX() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<recenterX>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<recenterX>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1`2'::get_recenterX

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ x = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<x>i__Field'
    IL_0019:  box        !'<x>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", recenterX = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<recenterX>i__Field'
    IL_0037:  box        !'<recenterX>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType1`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<x>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<x>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<x>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<x>j__TPar'>::Equals(!0,
                                                                                                                            !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterX>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<recenterX>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<recenterX>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterX>j__TPar'>::Equals(!0,
                                                                                                                                    !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType1`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x55511ae6
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<x>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<x>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<x>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterX>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType1`2'<!'<x>j__TPar',!'<recenterX>j__TPar'>::'<recenterX>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<recenterX>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType1`2'::GetHashCode

  .property instance !'<x>j__TPar' x()
  {
    .get instance !'<x>j__TPar' '<>f__AnonymousType1`2'::get_x()
  } // end of property '<>f__AnonymousType1`2'::x
  .property instance !'<recenterX>j__TPar'
          recenterX()
  {
    .get instance !'<recenterX>j__TPar' '<>f__AnonymousType1`2'::get_recenterX()
  } // end of property '<>f__AnonymousType1`2'::recenterX
} // end of class '<>f__AnonymousType1`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType2`2'<'<<>h__TransparentIdentifier10>j__TPar','<point>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 53 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..S\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 30 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 10 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 30 7D 2C 20 70 6F 69 6E 74 20 3D 20 7B 70 6F   // 10}, point = {po
                                                                                                 69 6E 74 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // int} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier10>j__TPar' '<<>h__TransparentIdentifier10>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<point>j__TPar' '<point>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier10>j__TPar' '<>h__TransparentIdentifier10',
                               !'<point>j__TPar' point) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier10>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType2`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier10>j__TPar' 
          'get_<>h__TransparentIdentifier10'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier10>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier10>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2`2'::'get_<>h__TransparentIdentifier10'

  .method public hidebysig specialname instance !'<point>j__TPar' 
          get_point() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<point>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2`2'::get_point

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier10 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier10>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier10>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", point = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0037:  box        !'<point>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType2`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier10>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier10>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier10>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier10>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType2`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x40b130b9
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier10>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier10>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier10>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType2`2'<!'<<>h__TransparentIdentifier10>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType2`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier10>j__TPar'
          '<>h__TransparentIdentifier10'()
  {
    .get instance !'<<>h__TransparentIdentifier10>j__TPar' '<>f__AnonymousType2`2'::'get_<>h__TransparentIdentifier10'()
  } // end of property '<>f__AnonymousType2`2'::'<>h__TransparentIdentifier10'
  .property instance !'<point>j__TPar' point()
  {
    .get instance !'<point>j__TPar' '<>f__AnonymousType2`2'::get_point()
  } // end of property '<>f__AnonymousType2`2'::point
} // end of class '<>f__AnonymousType2`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType3`2'<'<<>h__TransparentIdentifier11>j__TPar','<ray>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 4F 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..O\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 31 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 11 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 31 7D 2C 20 72 61 79 20 3D 20 7B 72 61 79 7D   // 11}, ray = {ray}
                                                                                                 20 7D 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F   //  }..T..Type.<Ano
                                                                                                 6E 79 6D 6F 75 73 20 54 79 70 65 3E )             // nymous Type>
  .field private initonly !'<<>h__TransparentIdentifier11>j__TPar' '<<>h__TransparentIdentifier11>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<ray>j__TPar' '<ray>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier11>j__TPar' '<>h__TransparentIdentifier11',
                               !'<ray>j__TPar' ray) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier11>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType3`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier11>j__TPar' 
          'get_<>h__TransparentIdentifier11'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier11>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier11>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType3`2'::'get_<>h__TransparentIdentifier11'

  .method public hidebysig specialname instance !'<ray>j__TPar' 
          get_ray() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<ray>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType3`2'::get_ray

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier11 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier11>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier11>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", ray = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0037:  box        !'<ray>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType3`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier11>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier11>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier11>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier11>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::Equals(!0,
                                                                                                                              !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType3`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xb8c98f6
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier11>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier11>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier11>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType3`2'<!'<<>h__TransparentIdentifier11>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType3`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier11>j__TPar'
          '<>h__TransparentIdentifier11'()
  {
    .get instance !'<<>h__TransparentIdentifier11>j__TPar' '<>f__AnonymousType3`2'::'get_<>h__TransparentIdentifier11'()
  } // end of property '<>f__AnonymousType3`2'::'<>h__TransparentIdentifier11'
  .property instance !'<ray>j__TPar' ray()
  {
    .get instance !'<ray>j__TPar' '<>f__AnonymousType3`2'::get_ray()
  } // end of property '<>f__AnonymousType3`2'::ray
} // end of class '<>f__AnonymousType3`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType4`2'<'<isect>j__TPar','<d>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 1D 5C 7B 20 69 73 65 63 74 20 3D 20 7B 69   // ...\{ isect = {i
                                                                                                 73 65 63 74 7D 2C 20 64 20 3D 20 7B 64 7D 20 7D   // sect}, d = {d} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<isect>j__TPar' '<isect>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<d>j__TPar' '<d>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<isect>j__TPar' isect,
                               !'<d>j__TPar' d) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<isect>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<d>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType4`2'::.ctor

  .method public hidebysig specialname instance !'<isect>j__TPar' 
          get_isect() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<isect>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<isect>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType4`2'::get_isect

  .method public hidebysig specialname instance !'<d>j__TPar' 
          get_d() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<d>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<d>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType4`2'::get_d

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ isect = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<isect>i__Field'
    IL_0019:  box        !'<isect>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", d = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<d>i__Field'
    IL_0037:  box        !'<d>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType4`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isect>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<isect>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<isect>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isect>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<d>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<d>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<d>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<d>j__TPar'>::Equals(!0,
                                                                                                                            !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType4`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x361f1ee1
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isect>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<isect>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isect>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<d>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType4`2'<!'<isect>j__TPar',!'<d>j__TPar'>::'<d>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<d>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType4`2'::GetHashCode

  .property instance !'<isect>j__TPar' isect()
  {
    .get instance !'<isect>j__TPar' '<>f__AnonymousType4`2'::get_isect()
  } // end of property '<>f__AnonymousType4`2'::isect
  .property instance !'<d>j__TPar' d()
  {
    .get instance !'<d>j__TPar' '<>f__AnonymousType4`2'::get_d()
  } // end of property '<>f__AnonymousType4`2'::d
} // end of class '<>f__AnonymousType4`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType5`2'<'<<>h__TransparentIdentifier15>j__TPar','<pos>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 4F 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..O\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 35 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 15 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 35 7D 2C 20 70 6F 73 20 3D 20 7B 70 6F 73 7D   // 15}, pos = {pos}
                                                                                                 20 7D 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F   //  }..T..Type.<Ano
                                                                                                 6E 79 6D 6F 75 73 20 54 79 70 65 3E )             // nymous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier15>j__TPar' '<<>h__TransparentIdentifier15>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<pos>j__TPar' '<pos>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier15>j__TPar' '<>h__TransparentIdentifier15',
                               !'<pos>j__TPar' pos) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier15>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType5`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier15>j__TPar' 
          'get_<>h__TransparentIdentifier15'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier15>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier15>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType5`2'::'get_<>h__TransparentIdentifier15'

  .method public hidebysig specialname instance !'<pos>j__TPar' 
          get_pos() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<pos>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType5`2'::get_pos

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier15 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier15>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier15>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", pos = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0037:  box        !'<pos>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType5`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier15>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier15>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier15>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier15>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::Equals(!0,
                                                                                                                              !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType5`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x9e2202d4
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier15>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier15>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier15>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType5`2'<!'<<>h__TransparentIdentifier15>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType5`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier15>j__TPar'
          '<>h__TransparentIdentifier15'()
  {
    .get instance !'<<>h__TransparentIdentifier15>j__TPar' '<>f__AnonymousType5`2'::'get_<>h__TransparentIdentifier15'()
  } // end of property '<>f__AnonymousType5`2'::'<>h__TransparentIdentifier15'
  .property instance !'<pos>j__TPar' pos()
  {
    .get instance !'<pos>j__TPar' '<>f__AnonymousType5`2'::get_pos()
  } // end of property '<>f__AnonymousType5`2'::pos
} // end of class '<>f__AnonymousType5`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType6`2'<'<<>h__TransparentIdentifier16>j__TPar','<normal>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 55 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..U\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 36 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 16 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 36 7D 2C 20 6E 6F 72 6D 61 6C 20 3D 20 7B 6E   // 16}, normal = {n
                                                                                                 6F 72 6D 61 6C 7D 20 7D 01 00 54 0E 04 54 79 70   // ormal} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier16>j__TPar' '<<>h__TransparentIdentifier16>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<normal>j__TPar' '<normal>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier16>j__TPar' '<>h__TransparentIdentifier16',
                               !'<normal>j__TPar' normal) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier16>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType6`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier16>j__TPar' 
          'get_<>h__TransparentIdentifier16'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier16>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier16>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType6`2'::'get_<>h__TransparentIdentifier16'

  .method public hidebysig specialname instance !'<normal>j__TPar' 
          get_normal() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<normal>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType6`2'::get_normal

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier16 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier16>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier16>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", normal = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0037:  box        !'<normal>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType6`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier16>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier16>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier16>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier16>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::Equals(!0,
                                                                                                                                 !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType6`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x310352a7
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier16>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier16>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier16>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType6`2'<!'<<>h__TransparentIdentifier16>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType6`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier16>j__TPar'
          '<>h__TransparentIdentifier16'()
  {
    .get instance !'<<>h__TransparentIdentifier16>j__TPar' '<>f__AnonymousType6`2'::'get_<>h__TransparentIdentifier16'()
  } // end of property '<>f__AnonymousType6`2'::'<>h__TransparentIdentifier16'
  .property instance !'<normal>j__TPar' normal()
  {
    .get instance !'<normal>j__TPar' '<>f__AnonymousType6`2'::get_normal()
  } // end of property '<>f__AnonymousType6`2'::normal
} // end of class '<>f__AnonymousType6`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType7`2'<'<<>h__TransparentIdentifier17>j__TPar','<reflectDir>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 37 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 17 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 37 7D 2C 20 72 65 66 6C 65 63 74 44 69 72 20   // 17}, reflectDir 
                                                                                                 3D 20 7B 72 65 66 6C 65 63 74 44 69 72 7D 20 7D   // = {reflectDir} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .field private initonly !'<<>h__TransparentIdentifier17>j__TPar' '<<>h__TransparentIdentifier17>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<reflectDir>j__TPar' '<reflectDir>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier17>j__TPar' '<>h__TransparentIdentifier17',
                               !'<reflectDir>j__TPar' reflectDir) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier17>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType7`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier17>j__TPar' 
          'get_<>h__TransparentIdentifier17'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier17>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier17>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType7`2'::'get_<>h__TransparentIdentifier17'

  .method public hidebysig specialname instance !'<reflectDir>j__TPar' 
          get_reflectDir() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<reflectDir>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType7`2'::get_reflectDir

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier17 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier17>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier17>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", reflectDir = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0037:  box        !'<reflectDir>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType7`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier17>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier17>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier17>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier17>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType7`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xf7460eef
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier17>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier17>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier17>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType7`2'<!'<<>h__TransparentIdentifier17>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType7`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier17>j__TPar'
          '<>h__TransparentIdentifier17'()
  {
    .get instance !'<<>h__TransparentIdentifier17>j__TPar' '<>f__AnonymousType7`2'::'get_<>h__TransparentIdentifier17'()
  } // end of property '<>f__AnonymousType7`2'::'<>h__TransparentIdentifier17'
  .property instance !'<reflectDir>j__TPar'
          reflectDir()
  {
    .get instance !'<reflectDir>j__TPar' '<>f__AnonymousType7`2'::get_reflectDir()
  } // end of property '<>f__AnonymousType7`2'::reflectDir
} // end of class '<>f__AnonymousType7`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType8`2'<'<light>j__TPar','<ldis>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 23 5C 7B 20 6C 69 67 68 74 20 3D 20 7B 6C   // ..#\{ light = {l
                                                                                                 69 67 68 74 7D 2C 20 6C 64 69 73 20 3D 20 7B 6C   // ight}, ldis = {l
                                                                                                 64 69 73 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // dis} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<light>j__TPar' '<light>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<ldis>j__TPar' '<ldis>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<light>j__TPar' light,
                               !'<ldis>j__TPar' ldis) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<light>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<ldis>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType8`2'::.ctor

  .method public hidebysig specialname instance !'<light>j__TPar' 
          get_light() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<light>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<light>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType8`2'::get_light

  .method public hidebysig specialname instance !'<ldis>j__TPar' 
          get_ldis() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<ldis>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<ldis>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType8`2'::get_ldis

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ light = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<light>i__Field'
    IL_0019:  box        !'<light>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", ldis = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<ldis>i__Field'
    IL_0037:  box        !'<ldis>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType8`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<light>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<light>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<light>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<light>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ldis>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<ldis>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<ldis>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ldis>j__TPar'>::Equals(!0,
                                                                                                                               !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType8`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xceb011a9
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<light>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<light>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<light>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ldis>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType8`2'<!'<light>j__TPar',!'<ldis>j__TPar'>::'<ldis>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ldis>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType8`2'::GetHashCode

  .property instance !'<light>j__TPar' light()
  {
    .get instance !'<light>j__TPar' '<>f__AnonymousType8`2'::get_light()
  } // end of property '<>f__AnonymousType8`2'::light
  .property instance !'<ldis>j__TPar' ldis()
  {
    .get instance !'<ldis>j__TPar' '<>f__AnonymousType8`2'::get_ldis()
  } // end of property '<>f__AnonymousType8`2'::ldis
} // end of class '<>f__AnonymousType8`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType9`2'<'<<>h__TransparentIdentifier1c>j__TPar','<livec>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 53 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..S\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 63 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 1c = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 63 7D 2C 20 6C 69 76 65 63 20 3D 20 7B 6C 69   // 1c}, livec = {li
                                                                                                 76 65 63 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // vec} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier1c>j__TPar' '<<>h__TransparentIdentifier1c>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<livec>j__TPar' '<livec>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier1c>j__TPar' '<>h__TransparentIdentifier1c',
                               !'<livec>j__TPar' livec) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier1c>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType9`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier1c>j__TPar' 
          'get_<>h__TransparentIdentifier1c'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier1c>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier1c>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType9`2'::'get_<>h__TransparentIdentifier1c'

  .method public hidebysig specialname instance !'<livec>j__TPar' 
          get_livec() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<livec>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType9`2'::get_livec

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier1c = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier1c>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier1c>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", livec = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0037:  box        !'<livec>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType9`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1c>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier1c>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier1c>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1c>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType9`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x2dc0902d
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1c>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier1c>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1c>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType9`2'<!'<<>h__TransparentIdentifier1c>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType9`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier1c>j__TPar'
          '<>h__TransparentIdentifier1c'()
  {
    .get instance !'<<>h__TransparentIdentifier1c>j__TPar' '<>f__AnonymousType9`2'::'get_<>h__TransparentIdentifier1c'()
  } // end of property '<>f__AnonymousType9`2'::'<>h__TransparentIdentifier1c'
  .property instance !'<livec>j__TPar' livec()
  {
    .get instance !'<livec>j__TPar' '<>f__AnonymousType9`2'::get_livec()
  } // end of property '<>f__AnonymousType9`2'::livec
} // end of class '<>f__AnonymousType9`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousTypea`2'<'<<>h__TransparentIdentifier1d>j__TPar','<testRay>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 57 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..W\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 64 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 1d = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 64 7D 2C 20 74 65 73 74 52 61 79 20 3D 20 7B   // 1d}, testRay = {
                                                                                                 74 65 73 74 52 61 79 7D 20 7D 01 00 54 0E 04 54   // testRay} }..T..T
                                                                                                 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54   // ype.<Anonymous T
                                                                                                 79 70 65 3E )                                     // ype>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier1d>j__TPar' '<<>h__TransparentIdentifier1d>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<testRay>j__TPar' '<testRay>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier1d>j__TPar' '<>h__TransparentIdentifier1d',
                               !'<testRay>j__TPar' testRay) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier1d>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousTypea`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier1d>j__TPar' 
          'get_<>h__TransparentIdentifier1d'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier1d>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier1d>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypea`2'::'get_<>h__TransparentIdentifier1d'

  .method public hidebysig specialname instance !'<testRay>j__TPar' 
          get_testRay() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<testRay>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypea`2'::get_testRay

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier1d = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier1d>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier1d>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", testRay = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0037:  box        !'<testRay>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousTypea`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1d>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier1d>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier1d>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1d>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::Equals(!0,
                                                                                                                                  !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousTypea`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x7d91be06
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1d>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier1d>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1d>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousTypea`2'<!'<<>h__TransparentIdentifier1d>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousTypea`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier1d>j__TPar'
          '<>h__TransparentIdentifier1d'()
  {
    .get instance !'<<>h__TransparentIdentifier1d>j__TPar' '<>f__AnonymousTypea`2'::'get_<>h__TransparentIdentifier1d'()
  } // end of property '<>f__AnonymousTypea`2'::'<>h__TransparentIdentifier1d'
  .property instance !'<testRay>j__TPar' testRay()
  {
    .get instance !'<testRay>j__TPar' '<>f__AnonymousTypea`2'::get_testRay()
  } // end of property '<>f__AnonymousTypea`2'::testRay
} // end of class '<>f__AnonymousTypea`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousTypeb`2'<'<<>h__TransparentIdentifier1e>j__TPar','<testIsects>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 65 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 1e = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 65 7D 2C 20 74 65 73 74 49 73 65 63 74 73 20   // 1e}, testIsects 
                                                                                                 3D 20 7B 74 65 73 74 49 73 65 63 74 73 7D 20 7D   // = {testIsects} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .field private initonly !'<<>h__TransparentIdentifier1e>j__TPar' '<<>h__TransparentIdentifier1e>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<testIsects>j__TPar' '<testIsects>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier1e>j__TPar' '<>h__TransparentIdentifier1e',
                               !'<testIsects>j__TPar' testIsects) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier1e>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousTypeb`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier1e>j__TPar' 
          'get_<>h__TransparentIdentifier1e'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier1e>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier1e>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypeb`2'::'get_<>h__TransparentIdentifier1e'

  .method public hidebysig specialname instance !'<testIsects>j__TPar' 
          get_testIsects() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<testIsects>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypeb`2'::get_testIsects

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier1e = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier1e>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier1e>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", testIsects = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0037:  box        !'<testIsects>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousTypeb`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1e>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier1e>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier1e>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1e>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousTypeb`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x50d87a66
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1e>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier1e>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1e>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousTypeb`2'<!'<<>h__TransparentIdentifier1e>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousTypeb`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier1e>j__TPar'
          '<>h__TransparentIdentifier1e'()
  {
    .get instance !'<<>h__TransparentIdentifier1e>j__TPar' '<>f__AnonymousTypeb`2'::'get_<>h__TransparentIdentifier1e'()
  } // end of property '<>f__AnonymousTypeb`2'::'<>h__TransparentIdentifier1e'
  .property instance !'<testIsects>j__TPar'
          testIsects()
  {
    .get instance !'<testIsects>j__TPar' '<>f__AnonymousTypeb`2'::get_testIsects()
  } // end of property '<>f__AnonymousTypeb`2'::testIsects
} // end of class '<>f__AnonymousTypeb`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousTypec`2'<'<<>h__TransparentIdentifier1f>j__TPar','<testIsect>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5B 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..[\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 66 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 1f = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 66 7D 2C 20 74 65 73 74 49 73 65 63 74 20 3D   // 1f}, testIsect =
                                                                                                 20 7B 74 65 73 74 49 73 65 63 74 7D 20 7D 01 00   //  {testIsect} }..
                                                                                                 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F   // T..Type.<Anonymo
                                                                                                 75 73 20 54 79 70 65 3E )                         // us Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier1f>j__TPar' '<<>h__TransparentIdentifier1f>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<testIsect>j__TPar' '<testIsect>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier1f>j__TPar' '<>h__TransparentIdentifier1f',
                               !'<testIsect>j__TPar' testIsect) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier1f>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousTypec`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier1f>j__TPar' 
          'get_<>h__TransparentIdentifier1f'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier1f>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier1f>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypec`2'::'get_<>h__TransparentIdentifier1f'

  .method public hidebysig specialname instance !'<testIsect>j__TPar' 
          get_testIsect() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<testIsect>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypec`2'::get_testIsect

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier1f = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier1f>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier1f>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", testIsect = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0037:  box        !'<testIsect>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousTypec`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1f>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier1f>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier1f>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1f>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::Equals(!0,
                                                                                                                                    !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousTypec`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xead05b27
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1f>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier1f>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1f>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousTypec`2'<!'<<>h__TransparentIdentifier1f>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousTypec`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier1f>j__TPar'
          '<>h__TransparentIdentifier1f'()
  {
    .get instance !'<<>h__TransparentIdentifier1f>j__TPar' '<>f__AnonymousTypec`2'::'get_<>h__TransparentIdentifier1f'()
  } // end of property '<>f__AnonymousTypec`2'::'<>h__TransparentIdentifier1f'
  .property instance !'<testIsect>j__TPar'
          testIsect()
  {
    .get instance !'<testIsect>j__TPar' '<>f__AnonymousTypec`2'::get_testIsect()
  } // end of property '<>f__AnonymousTypec`2'::testIsect
} // end of class '<>f__AnonymousTypec`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousTyped`2'<'<<>h__TransparentIdentifier20>j__TPar','<neatIsect>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5B 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..[\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 30 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 20 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 30 7D 2C 20 6E 65 61 74 49 73 65 63 74 20 3D   // 20}, neatIsect =
                                                                                                 20 7B 6E 65 61 74 49 73 65 63 74 7D 20 7D 01 00   //  {neatIsect} }..
                                                                                                 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F   // T..Type.<Anonymo
                                                                                                 75 73 20 54 79 70 65 3E )                         // us Type>
  .field private initonly !'<<>h__TransparentIdentifier20>j__TPar' '<<>h__TransparentIdentifier20>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<neatIsect>j__TPar' '<neatIsect>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier20>j__TPar' '<>h__TransparentIdentifier20',
                               !'<neatIsect>j__TPar' neatIsect) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier20>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousTyped`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier20>j__TPar' 
          'get_<>h__TransparentIdentifier20'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier20>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier20>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTyped`2'::'get_<>h__TransparentIdentifier20'

  .method public hidebysig specialname instance !'<neatIsect>j__TPar' 
          get_neatIsect() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<neatIsect>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTyped`2'::get_neatIsect

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier20 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier20>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier20>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", neatIsect = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0037:  box        !'<neatIsect>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousTyped`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier20>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier20>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier20>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier20>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::Equals(!0,
                                                                                                                                    !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousTyped`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x5ec5e11
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier20>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier20>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier20>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousTyped`2'<!'<<>h__TransparentIdentifier20>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousTyped`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier20>j__TPar'
          '<>h__TransparentIdentifier20'()
  {
    .get instance !'<<>h__TransparentIdentifier20>j__TPar' '<>f__AnonymousTyped`2'::'get_<>h__TransparentIdentifier20'()
  } // end of property '<>f__AnonymousTyped`2'::'<>h__TransparentIdentifier20'
  .property instance !'<neatIsect>j__TPar'
          neatIsect()
  {
    .get instance !'<neatIsect>j__TPar' '<>f__AnonymousTyped`2'::get_neatIsect()
  } // end of property '<>f__AnonymousTyped`2'::neatIsect
} // end of class '<>f__AnonymousTyped`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousTypee`2'<'<<>h__TransparentIdentifier21>j__TPar','<isInShadow>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 31 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 21 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 31 7D 2C 20 69 73 49 6E 53 68 61 64 6F 77 20   // 21}, isInShadow 
                                                                                                 3D 20 7B 69 73 49 6E 53 68 61 64 6F 77 7D 20 7D   // = {isInShadow} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .field private initonly !'<<>h__TransparentIdentifier21>j__TPar' '<<>h__TransparentIdentifier21>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<isInShadow>j__TPar' '<isInShadow>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier21>j__TPar' '<>h__TransparentIdentifier21',
                               !'<isInShadow>j__TPar' isInShadow) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier21>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousTypee`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier21>j__TPar' 
          'get_<>h__TransparentIdentifier21'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier21>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier21>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypee`2'::'get_<>h__TransparentIdentifier21'

  .method public hidebysig specialname instance !'<isInShadow>j__TPar' 
          get_isInShadow() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<isInShadow>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypee`2'::get_isInShadow

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier21 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier21>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier21>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", isInShadow = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0037:  box        !'<isInShadow>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousTypee`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier21>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier21>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier21>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier21>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousTypee`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x8e60f9e6
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier21>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier21>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier21>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousTypee`2'<!'<<>h__TransparentIdentifier21>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousTypee`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier21>j__TPar'
          '<>h__TransparentIdentifier21'()
  {
    .get instance !'<<>h__TransparentIdentifier21>j__TPar' '<>f__AnonymousTypee`2'::'get_<>h__TransparentIdentifier21'()
  } // end of property '<>f__AnonymousTypee`2'::'<>h__TransparentIdentifier21'
  .property instance !'<isInShadow>j__TPar'
          isInShadow()
  {
    .get instance !'<isInShadow>j__TPar' '<>f__AnonymousTypee`2'::get_isInShadow()
  } // end of property '<>f__AnonymousTypee`2'::isInShadow
} // end of class '<>f__AnonymousTypee`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousTypef`2'<'<<>h__TransparentIdentifier22>j__TPar','<illum>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 53 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..S\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 32 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 22 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 32 7D 2C 20 69 6C 6C 75 6D 20 3D 20 7B 69 6C   // 22}, illum = {il
                                                                                                 6C 75 6D 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // lum} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier22>j__TPar' '<<>h__TransparentIdentifier22>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<illum>j__TPar' '<illum>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier22>j__TPar' '<>h__TransparentIdentifier22',
                               !'<illum>j__TPar' illum) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier22>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousTypef`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier22>j__TPar' 
          'get_<>h__TransparentIdentifier22'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier22>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier22>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypef`2'::'get_<>h__TransparentIdentifier22'

  .method public hidebysig specialname instance !'<illum>j__TPar' 
          get_illum() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<illum>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousTypef`2'::get_illum

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier22 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier22>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier22>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", illum = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0037:  box        !'<illum>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousTypef`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier22>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier22>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier22>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier22>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousTypef`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xa71e05c3
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier22>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier22>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier22>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousTypef`2'<!'<<>h__TransparentIdentifier22>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousTypef`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier22>j__TPar'
          '<>h__TransparentIdentifier22'()
  {
    .get instance !'<<>h__TransparentIdentifier22>j__TPar' '<>f__AnonymousTypef`2'::'get_<>h__TransparentIdentifier22'()
  } // end of property '<>f__AnonymousTypef`2'::'<>h__TransparentIdentifier22'
  .property instance !'<illum>j__TPar' illum()
  {
    .get instance !'<illum>j__TPar' '<>f__AnonymousTypef`2'::get_illum()
  } // end of property '<>f__AnonymousTypef`2'::illum
} // end of class '<>f__AnonymousTypef`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType10`2'<'<<>h__TransparentIdentifier23>j__TPar','<lcolor>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 55 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..U\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 33 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 23 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 33 7D 2C 20 6C 63 6F 6C 6F 72 20 3D 20 7B 6C   // 23}, lcolor = {l
                                                                                                 63 6F 6C 6F 72 7D 20 7D 01 00 54 0E 04 54 79 70   // color} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier23>j__TPar' '<<>h__TransparentIdentifier23>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<lcolor>j__TPar' '<lcolor>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier23>j__TPar' '<>h__TransparentIdentifier23',
                               !'<lcolor>j__TPar' lcolor) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier23>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType10`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier23>j__TPar' 
          'get_<>h__TransparentIdentifier23'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier23>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier23>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType10`2'::'get_<>h__TransparentIdentifier23'

  .method public hidebysig specialname instance !'<lcolor>j__TPar' 
          get_lcolor() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<lcolor>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType10`2'::get_lcolor

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier23 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier23>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier23>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", lcolor = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0037:  box        !'<lcolor>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType10`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier23>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier23>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier23>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier23>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::Equals(!0,
                                                                                                                                 !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType10`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x54ab80f4
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier23>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier23>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier23>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType10`2'<!'<<>h__TransparentIdentifier23>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType10`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier23>j__TPar'
          '<>h__TransparentIdentifier23'()
  {
    .get instance !'<<>h__TransparentIdentifier23>j__TPar' '<>f__AnonymousType10`2'::'get_<>h__TransparentIdentifier23'()
  } // end of property '<>f__AnonymousType10`2'::'<>h__TransparentIdentifier23'
  .property instance !'<lcolor>j__TPar' lcolor()
  {
    .get instance !'<lcolor>j__TPar' '<>f__AnonymousType10`2'::get_lcolor()
  } // end of property '<>f__AnonymousType10`2'::lcolor
} // end of class '<>f__AnonymousType10`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType11`2'<'<<>h__TransparentIdentifier24>j__TPar','<specular>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 59 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..Y\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 34 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 24 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 34 7D 2C 20 73 70 65 63 75 6C 61 72 20 3D 20   // 24}, specular = 
                                                                                                 7B 73 70 65 63 75 6C 61 72 7D 20 7D 01 00 54 0E   // {specular} }..T.
                                                                                                 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73   // .Type.<Anonymous
                                                                                                 20 54 79 70 65 3E )                               //  Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier24>j__TPar' '<<>h__TransparentIdentifier24>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<specular>j__TPar' '<specular>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier24>j__TPar' '<>h__TransparentIdentifier24',
                               !'<specular>j__TPar' specular) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier24>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType11`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier24>j__TPar' 
          'get_<>h__TransparentIdentifier24'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier24>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier24>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType11`2'::'get_<>h__TransparentIdentifier24'

  .method public hidebysig specialname instance !'<specular>j__TPar' 
          get_specular() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<specular>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType11`2'::get_specular

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier24 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier24>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier24>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", specular = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0037:  box        !'<specular>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType11`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier24>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier24>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier24>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier24>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::Equals(!0,
                                                                                                                                   !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType11`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xe4b8b70d
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier24>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier24>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier24>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType11`2'<!'<<>h__TransparentIdentifier24>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType11`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier24>j__TPar'
          '<>h__TransparentIdentifier24'()
  {
    .get instance !'<<>h__TransparentIdentifier24>j__TPar' '<>f__AnonymousType11`2'::'get_<>h__TransparentIdentifier24'()
  } // end of property '<>f__AnonymousType11`2'::'<>h__TransparentIdentifier24'
  .property instance !'<specular>j__TPar'
          specular()
  {
    .get instance !'<specular>j__TPar' '<>f__AnonymousType11`2'::get_specular()
  } // end of property '<>f__AnonymousType11`2'::specular
} // end of class '<>f__AnonymousType11`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType12`2'<'<<>h__TransparentIdentifier25>j__TPar','<scolor>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 55 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..U\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 35 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 25 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 32 35 7D 2C 20 73 63 6F 6C 6F 72 20 3D 20 7B 73   // 25}, scolor = {s
                                                                                                 63 6F 6C 6F 72 7D 20 7D 01 00 54 0E 04 54 79 70   // color} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier25>j__TPar' '<<>h__TransparentIdentifier25>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<scolor>j__TPar' '<scolor>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier25>j__TPar' '<>h__TransparentIdentifier25',
                               !'<scolor>j__TPar' scolor) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier25>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType12`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier25>j__TPar' 
          'get_<>h__TransparentIdentifier25'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier25>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier25>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType12`2'::'get_<>h__TransparentIdentifier25'

  .method public hidebysig specialname instance !'<scolor>j__TPar' 
          get_scolor() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<scolor>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType12`2'::get_scolor

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier25 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier25>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier25>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", scolor = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0037:  box        !'<scolor>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType12`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier25>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier25>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier25>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier25>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::Equals(!0,
                                                                                                                                 !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType12`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x3f0d9a63
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier25>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier25>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier25>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType12`2'<!'<<>h__TransparentIdentifier25>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType12`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier25>j__TPar'
          '<>h__TransparentIdentifier25'()
  {
    .get instance !'<<>h__TransparentIdentifier25>j__TPar' '<>f__AnonymousType12`2'::'get_<>h__TransparentIdentifier25'()
  } // end of property '<>f__AnonymousType12`2'::'<>h__TransparentIdentifier25'
  .property instance !'<scolor>j__TPar' scolor()
  {
    .get instance !'<scolor>j__TPar' '<>f__AnonymousType12`2'::get_scolor()
  } // end of property '<>f__AnonymousType12`2'::scolor
} // end of class '<>f__AnonymousType12`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType13`2'<'<<>h__TransparentIdentifier18>j__TPar','<naturalColors>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 63 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..c\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 38 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 18 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 38 7D 2C 20 6E 61 74 75 72 61 6C 43 6F 6C 6F   // 18}, naturalColo
                                                                                                 72 73 20 3D 20 7B 6E 61 74 75 72 61 6C 43 6F 6C   // rs = {naturalCol
                                                                                                 6F 72 73 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // ors} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier18>j__TPar' '<<>h__TransparentIdentifier18>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<naturalColors>j__TPar' '<naturalColors>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier18>j__TPar' '<>h__TransparentIdentifier18',
                               !'<naturalColors>j__TPar' naturalColors) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier18>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType13`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier18>j__TPar' 
          'get_<>h__TransparentIdentifier18'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier18>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier18>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType13`2'::'get_<>h__TransparentIdentifier18'

  .method public hidebysig specialname instance !'<naturalColors>j__TPar' 
          get_naturalColors() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<naturalColors>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType13`2'::get_naturalColors

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier18 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier18>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier18>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", naturalColors = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0037:  box        !'<naturalColors>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType13`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier18>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier18>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier18>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier18>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::Equals(!0,
                                                                                                                                        !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType13`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xbbd61f35
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier18>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier18>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier18>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType13`2'<!'<<>h__TransparentIdentifier18>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType13`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier18>j__TPar'
          '<>h__TransparentIdentifier18'()
  {
    .get instance !'<<>h__TransparentIdentifier18>j__TPar' '<>f__AnonymousType13`2'::'get_<>h__TransparentIdentifier18'()
  } // end of property '<>f__AnonymousType13`2'::'<>h__TransparentIdentifier18'
  .property instance !'<naturalColors>j__TPar'
          naturalColors()
  {
    .get instance !'<naturalColors>j__TPar' '<>f__AnonymousType13`2'::get_naturalColors()
  } // end of property '<>f__AnonymousType13`2'::naturalColors
} // end of class '<>f__AnonymousType13`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType14`2'<'<<>h__TransparentIdentifier19>j__TPar','<reflectPos>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 39 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 19 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 39 7D 2C 20 72 65 66 6C 65 63 74 50 6F 73 20   // 19}, reflectPos 
                                                                                                 3D 20 7B 72 65 66 6C 65 63 74 50 6F 73 7D 20 7D   // = {reflectPos} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier19>j__TPar' '<<>h__TransparentIdentifier19>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<reflectPos>j__TPar' '<reflectPos>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier19>j__TPar' '<>h__TransparentIdentifier19',
                               !'<reflectPos>j__TPar' reflectPos) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier19>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType14`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier19>j__TPar' 
          'get_<>h__TransparentIdentifier19'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier19>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier19>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType14`2'::'get_<>h__TransparentIdentifier19'

  .method public hidebysig specialname instance !'<reflectPos>j__TPar' 
          get_reflectPos() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<reflectPos>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType14`2'::get_reflectPos

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier19 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier19>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier19>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", reflectPos = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0037:  box        !'<reflectPos>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType14`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier19>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier19>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier19>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier19>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType14`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xaeb7dffd
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier19>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier19>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier19>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType14`2'<!'<<>h__TransparentIdentifier19>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType14`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier19>j__TPar'
          '<>h__TransparentIdentifier19'()
  {
    .get instance !'<<>h__TransparentIdentifier19>j__TPar' '<>f__AnonymousType14`2'::'get_<>h__TransparentIdentifier19'()
  } // end of property '<>f__AnonymousType14`2'::'<>h__TransparentIdentifier19'
  .property instance !'<reflectPos>j__TPar'
          reflectPos()
  {
    .get instance !'<reflectPos>j__TPar' '<>f__AnonymousType14`2'::get_reflectPos()
  } // end of property '<>f__AnonymousType14`2'::reflectPos
} // end of class '<>f__AnonymousType14`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType15`2'<'<<>h__TransparentIdentifier1a>j__TPar','<reflectColor>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 61 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..a\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 61 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 1a = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 61 7D 2C 20 72 65 66 6C 65 63 74 43 6F 6C 6F   // 1a}, reflectColo
                                                                                                 72 20 3D 20 7B 72 65 66 6C 65 63 74 43 6F 6C 6F   // r = {reflectColo
                                                                                                 72 7D 20 7D 01 00 54 0E 04 54 79 70 65 10 3C 41   // r} }..T..Type.<A
                                                                                                 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E )       // nonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier1a>j__TPar' '<<>h__TransparentIdentifier1a>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<reflectColor>j__TPar' '<reflectColor>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier1a>j__TPar' '<>h__TransparentIdentifier1a',
                               !'<reflectColor>j__TPar' reflectColor) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier1a>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType15`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier1a>j__TPar' 
          'get_<>h__TransparentIdentifier1a'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier1a>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier1a>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType15`2'::'get_<>h__TransparentIdentifier1a'

  .method public hidebysig specialname instance !'<reflectColor>j__TPar' 
          get_reflectColor() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<reflectColor>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType15`2'::get_reflectColor

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier1a = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier1a>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier1a>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", reflectColor = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0037:  box        !'<reflectColor>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType15`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1a>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier1a>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier1a>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1a>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::Equals(!0,
                                                                                                                                       !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType15`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x2303d5b2
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1a>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier1a>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier1a>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType15`2'<!'<<>h__TransparentIdentifier1a>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType15`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier1a>j__TPar'
          '<>h__TransparentIdentifier1a'()
  {
    .get instance !'<<>h__TransparentIdentifier1a>j__TPar' '<>f__AnonymousType15`2'::'get_<>h__TransparentIdentifier1a'()
  } // end of property '<>f__AnonymousType15`2'::'<>h__TransparentIdentifier1a'
  .property instance !'<reflectColor>j__TPar'
          reflectColor()
  {
    .get instance !'<reflectColor>j__TPar' '<>f__AnonymousType15`2'::get_reflectColor()
  } // end of property '<>f__AnonymousType15`2'::reflectColor
} // end of class '<>f__AnonymousType15`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType16`2'<'<<>h__TransparentIdentifier12>j__TPar','<computeTraceRay>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 67 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..g\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 32 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 12 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 32 7D 2C 20 63 6F 6D 70 75 74 65 54 72 61 63   // 12}, computeTrac
                                                                                                 65 52 61 79 20 3D 20 7B 63 6F 6D 70 75 74 65 54   // eRay = {computeT
                                                                                                 72 61 63 65 52 61 79 7D 20 7D 01 00 54 0E 04 54   // raceRay} }..T..T
                                                                                                 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54   // ype.<Anonymous T
                                                                                                 79 70 65 3E )                                     // ype>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier12>j__TPar' '<<>h__TransparentIdentifier12>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<computeTraceRay>j__TPar' '<computeTraceRay>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier12>j__TPar' '<>h__TransparentIdentifier12',
                               !'<computeTraceRay>j__TPar' computeTraceRay) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier12>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType16`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier12>j__TPar' 
          'get_<>h__TransparentIdentifier12'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier12>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier12>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType16`2'::'get_<>h__TransparentIdentifier12'

  .method public hidebysig specialname instance !'<computeTraceRay>j__TPar' 
          get_computeTraceRay() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<computeTraceRay>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType16`2'::get_computeTraceRay

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier12 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier12>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier12>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", computeTraceRay = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0037:  box        !'<computeTraceRay>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType16`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier12>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier12>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier12>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier12>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::Equals(!0,
                                                                                                                                          !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType16`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x69442e45
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier12>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier12>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier12>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType16`2'<!'<<>h__TransparentIdentifier12>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType16`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier12>j__TPar'
          '<>h__TransparentIdentifier12'()
  {
    .get instance !'<<>h__TransparentIdentifier12>j__TPar' '<>f__AnonymousType16`2'::'get_<>h__TransparentIdentifier12'()
  } // end of property '<>f__AnonymousType16`2'::'<>h__TransparentIdentifier12'
  .property instance !'<computeTraceRay>j__TPar'
          computeTraceRay()
  {
    .get instance !'<computeTraceRay>j__TPar' '<>f__AnonymousType16`2'::get_computeTraceRay()
  } // end of property '<>f__AnonymousType16`2'::computeTraceRay
} // end of class '<>f__AnonymousType16`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType17`2'<'<<>h__TransparentIdentifier13>j__TPar','<traceRay>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 59 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..Y\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 33 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 13 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 31 33 7D 2C 20 74 72 61 63 65 52 61 79 20 3D 20   // 13}, traceRay = 
                                                                                                 7B 74 72 61 63 65 52 61 79 7D 20 7D 01 00 54 0E   // {traceRay} }..T.
                                                                                                 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73   // .Type.<Anonymous
                                                                                                 20 54 79 70 65 3E )                               //  Type>
  .field private initonly !'<<>h__TransparentIdentifier13>j__TPar' '<<>h__TransparentIdentifier13>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<traceRay>j__TPar' '<traceRay>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier13>j__TPar' '<>h__TransparentIdentifier13',
                               !'<traceRay>j__TPar' traceRay) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier13>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType17`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier13>j__TPar' 
          'get_<>h__TransparentIdentifier13'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier13>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier13>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType17`2'::'get_<>h__TransparentIdentifier13'

  .method public hidebysig specialname instance !'<traceRay>j__TPar' 
          get_traceRay() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<traceRay>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType17`2'::get_traceRay

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier13 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier13>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier13>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", traceRay = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0037:  box        !'<traceRay>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType17`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier13>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier13>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier13>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier13>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::Equals(!0,
                                                                                                                                   !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType17`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x1d2cadf5
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier13>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier13>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier13>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType17`2'<!'<<>h__TransparentIdentifier13>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType17`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier13>j__TPar'
          '<>h__TransparentIdentifier13'()
  {
    .get instance !'<<>h__TransparentIdentifier13>j__TPar' '<>f__AnonymousType17`2'::'get_<>h__TransparentIdentifier13'()
  } // end of property '<>f__AnonymousType17`2'::'<>h__TransparentIdentifier13'
  .property instance !'<traceRay>j__TPar'
          traceRay()
  {
    .get instance !'<traceRay>j__TPar' '<>f__AnonymousType17`2'::get_traceRay()
  } // end of property '<>f__AnonymousType17`2'::traceRay
} // end of class '<>f__AnonymousType17`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType18`3'<'<X>j__TPar','<Y>j__TPar','<Color>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 26 5C 7B 20 58 20 3D 20 7B 58 7D 2C 20 59   // ..&\{ X = {X}, Y
                                                                                                 20 3D 20 7B 59 7D 2C 20 43 6F 6C 6F 72 20 3D 20   //  = {Y}, Color = 
                                                                                                 7B 43 6F 6C 6F 72 7D 20 7D 01 00 54 0E 04 54 79   // {Color} }..T..Ty
                                                                                                 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79   // pe.<Anonymous Ty
                                                                                                 70 65 3E )                                        // pe>
  .field private initonly !'<X>j__TPar' '<X>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<Y>j__TPar' '<Y>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<Color>j__TPar' '<Color>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<X>j__TPar' X,
                               !'<Y>j__TPar' Y,
                               !'<Color>j__TPar' Color) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       28 (0x1c)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<X>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Y>i__Field'
    IL_0014:  ldarg.0
    IL_0015:  ldarg.3
    IL_0016:  stfld      !2 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Color>i__Field'
    IL_001b:  ret
  } // end of method '<>f__AnonymousType18`3'::.ctor

  .method public hidebysig specialname instance !'<X>j__TPar' 
          get_X() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<X>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<X>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType18`3'::get_X

  .method public hidebysig specialname instance !'<Y>j__TPar' 
          get_Y() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<Y>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Y>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType18`3'::get_Y

  .method public hidebysig specialname instance !'<Color>j__TPar' 
          get_Color() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<Color>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !2 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Color>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType18`3'::get_Color

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       119 (0x77)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ X = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<X>i__Field'
    IL_0019:  box        !'<X>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", Y = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Y>i__Field'
    IL_0037:  box        !'<Y>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      ", Color = "
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  ldarg.0
    IL_0050:  ldfld      !2 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Color>i__Field'
    IL_0055:  box        !'<Color>j__TPar'
    IL_005a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_005f:  pop
    IL_0060:  ldloc.0
    IL_0061:  ldstr      " }"
    IL_0066:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_006b:  pop
    IL_006c:  ldloc.0
    IL_006d:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0072:  stloc.1
    IL_0073:  br.s       IL_0075

    IL_0075:  ldloc.1
    IL_0076:  ret
  } // end of method '<>f__AnonymousType18`3'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       88 (0x58)
    .maxstack  3
    .locals init (class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_0052

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<X>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<X>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<X>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<X>j__TPar'>::Equals(!0,
                                                                                                                            !0)
    IL_0020:  brfalse.s  IL_0052

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Y>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Y>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Y>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Y>j__TPar'>::Equals(!0,
                                                                                                                            !0)
    IL_0038:  brfalse.s  IL_0052

    IL_003a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Color>j__TPar'>::get_Default()
    IL_003f:  ldarg.0
    IL_0040:  ldfld      !2 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Color>i__Field'
    IL_0045:  ldloc.0
    IL_0046:  ldfld      !2 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Color>i__Field'
    IL_004b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Color>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0050:  br.s       IL_0053

    IL_0052:  ldc.i4.0
    IL_0053:  stloc.1
    IL_0054:  br.s       IL_0056

    IL_0056:  ldloc.1
    IL_0057:  ret
  } // end of method '<>f__AnonymousType18`3'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       87 (0x57)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xae467c64
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<X>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<X>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<X>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Y>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Y>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Y>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldc.i4     0xa5555529
    IL_003d:  ldloc.0
    IL_003e:  mul
    IL_003f:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Color>j__TPar'>::get_Default()
    IL_0044:  ldarg.0
    IL_0045:  ldfld      !2 class '<>f__AnonymousType18`3'<!'<X>j__TPar',!'<Y>j__TPar',!'<Color>j__TPar'>::'<Color>i__Field'
    IL_004a:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<Color>j__TPar'>::GetHashCode(!0)
    IL_004f:  add
    IL_0050:  stloc.0
    IL_0051:  ldloc.0
    IL_0052:  stloc.1
    IL_0053:  br.s       IL_0055

    IL_0055:  ldloc.1
    IL_0056:  ret
  } // end of method '<>f__AnonymousType18`3'::GetHashCode

  .property instance !'<X>j__TPar' X()
  {
    .get instance !'<X>j__TPar' '<>f__AnonymousType18`3'::get_X()
  } // end of property '<>f__AnonymousType18`3'::X
  .property instance !'<Y>j__TPar' Y()
  {
    .get instance !'<Y>j__TPar' '<>f__AnonymousType18`3'::get_Y()
  } // end of property '<>f__AnonymousType18`3'::Y
  .property instance !'<Color>j__TPar' Color()
  {
    .get instance !'<Color>j__TPar' '<>f__AnonymousType18`3'::get_Color()
  } // end of property '<>f__AnonymousType18`3'::Color
} // end of class '<>f__AnonymousType18`3'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType19`2'<'<<>h__TransparentIdentifier71>j__TPar','<point>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 53 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..S\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 31 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 71 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 31 7D 2C 20 70 6F 69 6E 74 20 3D 20 7B 70 6F   // 71}, point = {po
                                                                                                 69 6E 74 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // int} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier71>j__TPar' '<<>h__TransparentIdentifier71>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<point>j__TPar' '<point>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier71>j__TPar' '<>h__TransparentIdentifier71',
                               !'<point>j__TPar' point) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier71>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType19`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier71>j__TPar' 
          'get_<>h__TransparentIdentifier71'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier71>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier71>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType19`2'::'get_<>h__TransparentIdentifier71'

  .method public hidebysig specialname instance !'<point>j__TPar' 
          get_point() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<point>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType19`2'::get_point

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier71 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier71>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier71>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", point = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0037:  box        !'<point>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType19`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier71>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier71>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier71>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier71>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType19`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x35242641
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier71>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<<>h__TransparentIdentifier71>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier71>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType19`2'<!'<<>h__TransparentIdentifier71>j__TPar',!'<point>j__TPar'>::'<point>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<point>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType19`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier71>j__TPar'
          '<>h__TransparentIdentifier71'()
  {
    .get instance !'<<>h__TransparentIdentifier71>j__TPar' '<>f__AnonymousType19`2'::'get_<>h__TransparentIdentifier71'()
  } // end of property '<>f__AnonymousType19`2'::'<>h__TransparentIdentifier71'
  .property instance !'<point>j__TPar' point()
  {
    .get instance !'<point>j__TPar' '<>f__AnonymousType19`2'::get_point()
  } // end of property '<>f__AnonymousType19`2'::point
} // end of class '<>f__AnonymousType19`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType1a`2'<'<<>h__TransparentIdentifier72>j__TPar','<ray>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 4F 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..O\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 32 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 72 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 32 7D 2C 20 72 61 79 20 3D 20 7B 72 61 79 7D   // 72}, ray = {ray}
                                                                                                 20 7D 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F   //  }..T..Type.<Ano
                                                                                                 6E 79 6D 6F 75 73 20 54 79 70 65 3E )             // nymous Type>
  .field private initonly !'<<>h__TransparentIdentifier72>j__TPar' '<<>h__TransparentIdentifier72>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<ray>j__TPar' '<ray>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier72>j__TPar' '<>h__TransparentIdentifier72',
                               !'<ray>j__TPar' ray) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier72>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType1a`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier72>j__TPar' 
          'get_<>h__TransparentIdentifier72'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier72>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier72>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1a`2'::'get_<>h__TransparentIdentifier72'

  .method public hidebysig specialname instance !'<ray>j__TPar' 
          get_ray() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<ray>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1a`2'::get_ray

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier72 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier72>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier72>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", ray = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0037:  box        !'<ray>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType1a`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier72>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier72>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier72>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier72>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::Equals(!0,
                                                                                                                              !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType1a`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x949eaeb5
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier72>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<<>h__TransparentIdentifier72>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier72>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType1a`2'<!'<<>h__TransparentIdentifier72>j__TPar',!'<ray>j__TPar'>::'<ray>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<ray>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType1a`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier72>j__TPar'
          '<>h__TransparentIdentifier72'()
  {
    .get instance !'<<>h__TransparentIdentifier72>j__TPar' '<>f__AnonymousType1a`2'::'get_<>h__TransparentIdentifier72'()
  } // end of property '<>f__AnonymousType1a`2'::'<>h__TransparentIdentifier72'
  .property instance !'<ray>j__TPar' ray()
  {
    .get instance !'<ray>j__TPar' '<>f__AnonymousType1a`2'::get_ray()
  } // end of property '<>f__AnonymousType1a`2'::ray
} // end of class '<>f__AnonymousType1a`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType1b`2'<'<<>h__TransparentIdentifier76>j__TPar','<pos>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 4F 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..O\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 36 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 76 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 36 7D 2C 20 70 6F 73 20 3D 20 7B 70 6F 73 7D   // 76}, pos = {pos}
                                                                                                 20 7D 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F   //  }..T..Type.<Ano
                                                                                                 6E 79 6D 6F 75 73 20 54 79 70 65 3E )             // nymous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier76>j__TPar' '<<>h__TransparentIdentifier76>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<pos>j__TPar' '<pos>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier76>j__TPar' '<>h__TransparentIdentifier76',
                               !'<pos>j__TPar' pos) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier76>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType1b`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier76>j__TPar' 
          'get_<>h__TransparentIdentifier76'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier76>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier76>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1b`2'::'get_<>h__TransparentIdentifier76'

  .method public hidebysig specialname instance !'<pos>j__TPar' 
          get_pos() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<pos>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1b`2'::get_pos

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier76 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier76>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier76>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", pos = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0037:  box        !'<pos>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType1b`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier76>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier76>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier76>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier76>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::Equals(!0,
                                                                                                                              !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType1b`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xbf346f62
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier76>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<<>h__TransparentIdentifier76>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier76>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType1b`2'<!'<<>h__TransparentIdentifier76>j__TPar',!'<pos>j__TPar'>::'<pos>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<pos>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType1b`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier76>j__TPar'
          '<>h__TransparentIdentifier76'()
  {
    .get instance !'<<>h__TransparentIdentifier76>j__TPar' '<>f__AnonymousType1b`2'::'get_<>h__TransparentIdentifier76'()
  } // end of property '<>f__AnonymousType1b`2'::'<>h__TransparentIdentifier76'
  .property instance !'<pos>j__TPar' pos()
  {
    .get instance !'<pos>j__TPar' '<>f__AnonymousType1b`2'::get_pos()
  } // end of property '<>f__AnonymousType1b`2'::pos
} // end of class '<>f__AnonymousType1b`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType1c`2'<'<<>h__TransparentIdentifier77>j__TPar','<normal>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 55 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..U\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 37 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 77 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 37 7D 2C 20 6E 6F 72 6D 61 6C 20 3D 20 7B 6E   // 77}, normal = {n
                                                                                                 6F 72 6D 61 6C 7D 20 7D 01 00 54 0E 04 54 79 70   // ormal} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier77>j__TPar' '<<>h__TransparentIdentifier77>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<normal>j__TPar' '<normal>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier77>j__TPar' '<>h__TransparentIdentifier77',
                               !'<normal>j__TPar' normal) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier77>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType1c`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier77>j__TPar' 
          'get_<>h__TransparentIdentifier77'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier77>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier77>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1c`2'::'get_<>h__TransparentIdentifier77'

  .method public hidebysig specialname instance !'<normal>j__TPar' 
          get_normal() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<normal>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1c`2'::get_normal

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier77 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier77>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier77>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", normal = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0037:  box        !'<normal>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType1c`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier77>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier77>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier77>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier77>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::Equals(!0,
                                                                                                                                 !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType1c`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xd2467d3f
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier77>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<<>h__TransparentIdentifier77>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier77>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType1c`2'<!'<<>h__TransparentIdentifier77>j__TPar',!'<normal>j__TPar'>::'<normal>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<normal>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType1c`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier77>j__TPar'
          '<>h__TransparentIdentifier77'()
  {
    .get instance !'<<>h__TransparentIdentifier77>j__TPar' '<>f__AnonymousType1c`2'::'get_<>h__TransparentIdentifier77'()
  } // end of property '<>f__AnonymousType1c`2'::'<>h__TransparentIdentifier77'
  .property instance !'<normal>j__TPar' normal()
  {
    .get instance !'<normal>j__TPar' '<>f__AnonymousType1c`2'::get_normal()
  } // end of property '<>f__AnonymousType1c`2'::normal
} // end of class '<>f__AnonymousType1c`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType1d`2'<'<<>h__TransparentIdentifier78>j__TPar','<reflectDir>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 38 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 78 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 38 7D 2C 20 72 65 66 6C 65 63 74 44 69 72 20   // 78}, reflectDir 
                                                                                                 3D 20 7B 72 65 66 6C 65 63 74 44 69 72 7D 20 7D   // = {reflectDir} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier78>j__TPar' '<<>h__TransparentIdentifier78>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<reflectDir>j__TPar' '<reflectDir>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier78>j__TPar' '<>h__TransparentIdentifier78',
                               !'<reflectDir>j__TPar' reflectDir) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier78>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType1d`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier78>j__TPar' 
          'get_<>h__TransparentIdentifier78'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier78>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier78>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1d`2'::'get_<>h__TransparentIdentifier78'

  .method public hidebysig specialname instance !'<reflectDir>j__TPar' 
          get_reflectDir() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<reflectDir>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1d`2'::get_reflectDir

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier78 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier78>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier78>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", reflectDir = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0037:  box        !'<reflectDir>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType1d`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier78>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier78>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier78>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier78>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType1d`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x738a948b
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier78>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<<>h__TransparentIdentifier78>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier78>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType1d`2'<!'<<>h__TransparentIdentifier78>j__TPar',!'<reflectDir>j__TPar'>::'<reflectDir>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectDir>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType1d`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier78>j__TPar'
          '<>h__TransparentIdentifier78'()
  {
    .get instance !'<<>h__TransparentIdentifier78>j__TPar' '<>f__AnonymousType1d`2'::'get_<>h__TransparentIdentifier78'()
  } // end of property '<>f__AnonymousType1d`2'::'<>h__TransparentIdentifier78'
  .property instance !'<reflectDir>j__TPar'
          reflectDir()
  {
    .get instance !'<reflectDir>j__TPar' '<>f__AnonymousType1d`2'::get_reflectDir()
  } // end of property '<>f__AnonymousType1d`2'::reflectDir
} // end of class '<>f__AnonymousType1d`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType1e`2'<'<<>h__TransparentIdentifier7d>j__TPar','<livec>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 53 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..S\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 64 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 7d = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 64 7D 2C 20 6C 69 76 65 63 20 3D 20 7B 6C 69   // 7d}, livec = {li
                                                                                                 76 65 63 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // vec} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier7d>j__TPar' '<<>h__TransparentIdentifier7d>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<livec>j__TPar' '<livec>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier7d>j__TPar' '<>h__TransparentIdentifier7d',
                               !'<livec>j__TPar' livec) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier7d>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType1e`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier7d>j__TPar' 
          'get_<>h__TransparentIdentifier7d'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier7d>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier7d>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1e`2'::'get_<>h__TransparentIdentifier7d'

  .method public hidebysig specialname instance !'<livec>j__TPar' 
          get_livec() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<livec>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1e`2'::get_livec

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier7d = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier7d>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier7d>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", livec = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0037:  box        !'<livec>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType1e`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7d>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier7d>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier7d>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7d>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType1e`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x5051178e
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7d>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<<>h__TransparentIdentifier7d>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7d>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType1e`2'<!'<<>h__TransparentIdentifier7d>j__TPar',!'<livec>j__TPar'>::'<livec>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<livec>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType1e`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier7d>j__TPar'
          '<>h__TransparentIdentifier7d'()
  {
    .get instance !'<<>h__TransparentIdentifier7d>j__TPar' '<>f__AnonymousType1e`2'::'get_<>h__TransparentIdentifier7d'()
  } // end of property '<>f__AnonymousType1e`2'::'<>h__TransparentIdentifier7d'
  .property instance !'<livec>j__TPar' livec()
  {
    .get instance !'<livec>j__TPar' '<>f__AnonymousType1e`2'::get_livec()
  } // end of property '<>f__AnonymousType1e`2'::livec
} // end of class '<>f__AnonymousType1e`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType1f`2'<'<<>h__TransparentIdentifier7e>j__TPar','<testRay>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 57 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..W\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 65 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 7e = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 65 7D 2C 20 74 65 73 74 52 61 79 20 3D 20 7B   // 7e}, testRay = {
                                                                                                 74 65 73 74 52 61 79 7D 20 7D 01 00 54 0E 04 54   // testRay} }..T..T
                                                                                                 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54   // ype.<Anonymous T
                                                                                                 79 70 65 3E )                                     // ype>
  .field private initonly !'<<>h__TransparentIdentifier7e>j__TPar' '<<>h__TransparentIdentifier7e>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<testRay>j__TPar' '<testRay>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier7e>j__TPar' '<>h__TransparentIdentifier7e',
                               !'<testRay>j__TPar' testRay) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier7e>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType1f`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier7e>j__TPar' 
          'get_<>h__TransparentIdentifier7e'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier7e>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier7e>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1f`2'::'get_<>h__TransparentIdentifier7e'

  .method public hidebysig specialname instance !'<testRay>j__TPar' 
          get_testRay() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<testRay>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType1f`2'::get_testRay

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier7e = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier7e>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier7e>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", testRay = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0037:  box        !'<testRay>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType1f`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7e>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier7e>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier7e>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7e>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::Equals(!0,
                                                                                                                                  !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType1f`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x91ce9821
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7e>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<<>h__TransparentIdentifier7e>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7e>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType1f`2'<!'<<>h__TransparentIdentifier7e>j__TPar',!'<testRay>j__TPar'>::'<testRay>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testRay>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType1f`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier7e>j__TPar'
          '<>h__TransparentIdentifier7e'()
  {
    .get instance !'<<>h__TransparentIdentifier7e>j__TPar' '<>f__AnonymousType1f`2'::'get_<>h__TransparentIdentifier7e'()
  } // end of property '<>f__AnonymousType1f`2'::'<>h__TransparentIdentifier7e'
  .property instance !'<testRay>j__TPar' testRay()
  {
    .get instance !'<testRay>j__TPar' '<>f__AnonymousType1f`2'::get_testRay()
  } // end of property '<>f__AnonymousType1f`2'::testRay
} // end of class '<>f__AnonymousType1f`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType20`2'<'<<>h__TransparentIdentifier7f>j__TPar','<testIsects>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 66 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 7f = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 66 7D 2C 20 74 65 73 74 49 73 65 63 74 73 20   // 7f}, testIsects 
                                                                                                 3D 20 7B 74 65 73 74 49 73 65 63 74 73 7D 20 7D   // = {testIsects} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier7f>j__TPar' '<<>h__TransparentIdentifier7f>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<testIsects>j__TPar' '<testIsects>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier7f>j__TPar' '<>h__TransparentIdentifier7f',
                               !'<testIsects>j__TPar' testIsects) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier7f>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType20`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier7f>j__TPar' 
          'get_<>h__TransparentIdentifier7f'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier7f>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier7f>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType20`2'::'get_<>h__TransparentIdentifier7f'

  .method public hidebysig specialname instance !'<testIsects>j__TPar' 
          get_testIsects() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<testIsects>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType20`2'::get_testIsects

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier7f = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier7f>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier7f>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", testIsects = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0037:  box        !'<testIsects>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType20`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7f>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier7f>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier7f>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7f>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType20`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x42b0c16b
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7f>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<<>h__TransparentIdentifier7f>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7f>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType20`2'<!'<<>h__TransparentIdentifier7f>j__TPar',!'<testIsects>j__TPar'>::'<testIsects>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsects>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType20`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier7f>j__TPar'
          '<>h__TransparentIdentifier7f'()
  {
    .get instance !'<<>h__TransparentIdentifier7f>j__TPar' '<>f__AnonymousType20`2'::'get_<>h__TransparentIdentifier7f'()
  } // end of property '<>f__AnonymousType20`2'::'<>h__TransparentIdentifier7f'
  .property instance !'<testIsects>j__TPar'
          testIsects()
  {
    .get instance !'<testIsects>j__TPar' '<>f__AnonymousType20`2'::get_testIsects()
  } // end of property '<>f__AnonymousType20`2'::testIsects
} // end of class '<>f__AnonymousType20`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType21`2'<'<<>h__TransparentIdentifier80>j__TPar','<testIsect>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5B 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..[\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 30 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 80 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 30 7D 2C 20 74 65 73 74 49 73 65 63 74 20 3D   // 80}, testIsect =
                                                                                                 20 7B 74 65 73 74 49 73 65 63 74 7D 20 7D 01 00   //  {testIsect} }..
                                                                                                 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F   // T..Type.<Anonymo
                                                                                                 75 73 20 54 79 70 65 3E )                         // us Type>
  .field private initonly !'<<>h__TransparentIdentifier80>j__TPar' '<<>h__TransparentIdentifier80>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<testIsect>j__TPar' '<testIsect>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier80>j__TPar' '<>h__TransparentIdentifier80',
                               !'<testIsect>j__TPar' testIsect) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier80>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType21`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier80>j__TPar' 
          'get_<>h__TransparentIdentifier80'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier80>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier80>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType21`2'::'get_<>h__TransparentIdentifier80'

  .method public hidebysig specialname instance !'<testIsect>j__TPar' 
          get_testIsect() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<testIsect>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType21`2'::get_testIsect

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier80 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier80>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier80>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", testIsect = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0037:  box        !'<testIsect>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType21`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier80>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier80>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier80>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier80>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::Equals(!0,
                                                                                                                                    !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType21`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x23cf3a8e
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier80>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<<>h__TransparentIdentifier80>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier80>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType21`2'<!'<<>h__TransparentIdentifier80>j__TPar',!'<testIsect>j__TPar'>::'<testIsect>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<testIsect>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType21`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier80>j__TPar'
          '<>h__TransparentIdentifier80'()
  {
    .get instance !'<<>h__TransparentIdentifier80>j__TPar' '<>f__AnonymousType21`2'::'get_<>h__TransparentIdentifier80'()
  } // end of property '<>f__AnonymousType21`2'::'<>h__TransparentIdentifier80'
  .property instance !'<testIsect>j__TPar'
          testIsect()
  {
    .get instance !'<testIsect>j__TPar' '<>f__AnonymousType21`2'::get_testIsect()
  } // end of property '<>f__AnonymousType21`2'::testIsect
} // end of class '<>f__AnonymousType21`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType22`2'<'<<>h__TransparentIdentifier81>j__TPar','<neatIsect>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5B 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..[\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 31 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 81 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 31 7D 2C 20 6E 65 61 74 49 73 65 63 74 20 3D   // 81}, neatIsect =
                                                                                                 20 7B 6E 65 61 74 49 73 65 63 74 7D 20 7D 01 00   //  {neatIsect} }..
                                                                                                 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F   // T..Type.<Anonymo
                                                                                                 75 73 20 54 79 70 65 3E )                         // us Type>
  .field private initonly !'<<>h__TransparentIdentifier81>j__TPar' '<<>h__TransparentIdentifier81>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<neatIsect>j__TPar' '<neatIsect>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier81>j__TPar' '<>h__TransparentIdentifier81',
                               !'<neatIsect>j__TPar' neatIsect) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier81>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType22`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier81>j__TPar' 
          'get_<>h__TransparentIdentifier81'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier81>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier81>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType22`2'::'get_<>h__TransparentIdentifier81'

  .method public hidebysig specialname instance !'<neatIsect>j__TPar' 
          get_neatIsect() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<neatIsect>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType22`2'::get_neatIsect

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier81 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier81>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier81>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", neatIsect = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0037:  box        !'<neatIsect>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType22`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier81>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier81>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier81>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier81>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::Equals(!0,
                                                                                                                                    !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType22`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x358951e9
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier81>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<<>h__TransparentIdentifier81>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier81>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType22`2'<!'<<>h__TransparentIdentifier81>j__TPar',!'<neatIsect>j__TPar'>::'<neatIsect>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<neatIsect>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType22`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier81>j__TPar'
          '<>h__TransparentIdentifier81'()
  {
    .get instance !'<<>h__TransparentIdentifier81>j__TPar' '<>f__AnonymousType22`2'::'get_<>h__TransparentIdentifier81'()
  } // end of property '<>f__AnonymousType22`2'::'<>h__TransparentIdentifier81'
  .property instance !'<neatIsect>j__TPar'
          neatIsect()
  {
    .get instance !'<neatIsect>j__TPar' '<>f__AnonymousType22`2'::get_neatIsect()
  } // end of property '<>f__AnonymousType22`2'::neatIsect
} // end of class '<>f__AnonymousType22`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType23`2'<'<<>h__TransparentIdentifier82>j__TPar','<isInShadow>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 32 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 82 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 32 7D 2C 20 69 73 49 6E 53 68 61 64 6F 77 20   // 82}, isInShadow 
                                                                                                 3D 20 7B 69 73 49 6E 53 68 61 64 6F 77 7D 20 7D   // = {isInShadow} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier82>j__TPar' '<<>h__TransparentIdentifier82>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<isInShadow>j__TPar' '<isInShadow>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier82>j__TPar' '<>h__TransparentIdentifier82',
                               !'<isInShadow>j__TPar' isInShadow) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier82>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType23`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier82>j__TPar' 
          'get_<>h__TransparentIdentifier82'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier82>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier82>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType23`2'::'get_<>h__TransparentIdentifier82'

  .method public hidebysig specialname instance !'<isInShadow>j__TPar' 
          get_isInShadow() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<isInShadow>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType23`2'::get_isInShadow

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier82 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier82>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier82>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", isInShadow = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0037:  box        !'<isInShadow>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType23`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier82>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier82>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier82>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier82>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType23`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xb48fd826
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier82>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<<>h__TransparentIdentifier82>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier82>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType23`2'<!'<<>h__TransparentIdentifier82>j__TPar',!'<isInShadow>j__TPar'>::'<isInShadow>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<isInShadow>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType23`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier82>j__TPar'
          '<>h__TransparentIdentifier82'()
  {
    .get instance !'<<>h__TransparentIdentifier82>j__TPar' '<>f__AnonymousType23`2'::'get_<>h__TransparentIdentifier82'()
  } // end of property '<>f__AnonymousType23`2'::'<>h__TransparentIdentifier82'
  .property instance !'<isInShadow>j__TPar'
          isInShadow()
  {
    .get instance !'<isInShadow>j__TPar' '<>f__AnonymousType23`2'::get_isInShadow()
  } // end of property '<>f__AnonymousType23`2'::isInShadow
} // end of class '<>f__AnonymousType23`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType24`2'<'<<>h__TransparentIdentifier83>j__TPar','<illum>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 53 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..S\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 33 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 83 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 33 7D 2C 20 69 6C 6C 75 6D 20 3D 20 7B 69 6C   // 83}, illum = {il
                                                                                                 6C 75 6D 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // lum} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .field private initonly !'<<>h__TransparentIdentifier83>j__TPar' '<<>h__TransparentIdentifier83>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<illum>j__TPar' '<illum>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier83>j__TPar' '<>h__TransparentIdentifier83',
                               !'<illum>j__TPar' illum) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier83>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType24`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier83>j__TPar' 
          'get_<>h__TransparentIdentifier83'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier83>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier83>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType24`2'::'get_<>h__TransparentIdentifier83'

  .method public hidebysig specialname instance !'<illum>j__TPar' 
          get_illum() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<illum>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType24`2'::get_illum

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier83 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier83>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier83>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", illum = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0037:  box        !'<illum>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType24`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier83>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier83>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier83>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier83>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::Equals(!0,
                                                                                                                                !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType24`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x1f6320a0
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier83>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<<>h__TransparentIdentifier83>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier83>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType24`2'<!'<<>h__TransparentIdentifier83>j__TPar',!'<illum>j__TPar'>::'<illum>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<illum>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType24`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier83>j__TPar'
          '<>h__TransparentIdentifier83'()
  {
    .get instance !'<<>h__TransparentIdentifier83>j__TPar' '<>f__AnonymousType24`2'::'get_<>h__TransparentIdentifier83'()
  } // end of property '<>f__AnonymousType24`2'::'<>h__TransparentIdentifier83'
  .property instance !'<illum>j__TPar' illum()
  {
    .get instance !'<illum>j__TPar' '<>f__AnonymousType24`2'::get_illum()
  } // end of property '<>f__AnonymousType24`2'::illum
} // end of class '<>f__AnonymousType24`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType25`2'<'<<>h__TransparentIdentifier84>j__TPar','<lcolor>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 55 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..U\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 34 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 84 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 34 7D 2C 20 6C 63 6F 6C 6F 72 20 3D 20 7B 6C   // 84}, lcolor = {l
                                                                                                 63 6F 6C 6F 72 7D 20 7D 01 00 54 0E 04 54 79 70   // color} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier84>j__TPar' '<<>h__TransparentIdentifier84>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<lcolor>j__TPar' '<lcolor>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier84>j__TPar' '<>h__TransparentIdentifier84',
                               !'<lcolor>j__TPar' lcolor) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier84>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType25`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier84>j__TPar' 
          'get_<>h__TransparentIdentifier84'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier84>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier84>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType25`2'::'get_<>h__TransparentIdentifier84'

  .method public hidebysig specialname instance !'<lcolor>j__TPar' 
          get_lcolor() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<lcolor>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType25`2'::get_lcolor

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier84 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier84>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier84>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", lcolor = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0037:  box        !'<lcolor>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType25`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier84>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier84>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier84>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier84>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::Equals(!0,
                                                                                                                                 !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType25`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xf9d84698
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier84>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<<>h__TransparentIdentifier84>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier84>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType25`2'<!'<<>h__TransparentIdentifier84>j__TPar',!'<lcolor>j__TPar'>::'<lcolor>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<lcolor>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType25`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier84>j__TPar'
          '<>h__TransparentIdentifier84'()
  {
    .get instance !'<<>h__TransparentIdentifier84>j__TPar' '<>f__AnonymousType25`2'::'get_<>h__TransparentIdentifier84'()
  } // end of property '<>f__AnonymousType25`2'::'<>h__TransparentIdentifier84'
  .property instance !'<lcolor>j__TPar' lcolor()
  {
    .get instance !'<lcolor>j__TPar' '<>f__AnonymousType25`2'::get_lcolor()
  } // end of property '<>f__AnonymousType25`2'::lcolor
} // end of class '<>f__AnonymousType25`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType26`2'<'<<>h__TransparentIdentifier85>j__TPar','<specular>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 59 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..Y\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 35 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 85 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 35 7D 2C 20 73 70 65 63 75 6C 61 72 20 3D 20   // 85}, specular = 
                                                                                                 7B 73 70 65 63 75 6C 61 72 7D 20 7D 01 00 54 0E   // {specular} }..T.
                                                                                                 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73   // .Type.<Anonymous
                                                                                                 20 54 79 70 65 3E )                               //  Type>
  .field private initonly !'<<>h__TransparentIdentifier85>j__TPar' '<<>h__TransparentIdentifier85>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<specular>j__TPar' '<specular>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier85>j__TPar' '<>h__TransparentIdentifier85',
                               !'<specular>j__TPar' specular) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier85>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType26`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier85>j__TPar' 
          'get_<>h__TransparentIdentifier85'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier85>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier85>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType26`2'::'get_<>h__TransparentIdentifier85'

  .method public hidebysig specialname instance !'<specular>j__TPar' 
          get_specular() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<specular>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType26`2'::get_specular

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier85 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier85>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier85>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", specular = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0037:  box        !'<specular>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType26`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier85>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier85>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier85>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier85>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::Equals(!0,
                                                                                                                                   !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType26`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x24db8f99
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier85>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<<>h__TransparentIdentifier85>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier85>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType26`2'<!'<<>h__TransparentIdentifier85>j__TPar',!'<specular>j__TPar'>::'<specular>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<specular>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType26`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier85>j__TPar'
          '<>h__TransparentIdentifier85'()
  {
    .get instance !'<<>h__TransparentIdentifier85>j__TPar' '<>f__AnonymousType26`2'::'get_<>h__TransparentIdentifier85'()
  } // end of property '<>f__AnonymousType26`2'::'<>h__TransparentIdentifier85'
  .property instance !'<specular>j__TPar'
          specular()
  {
    .get instance !'<specular>j__TPar' '<>f__AnonymousType26`2'::get_specular()
  } // end of property '<>f__AnonymousType26`2'::specular
} // end of class '<>f__AnonymousType26`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType27`2'<'<<>h__TransparentIdentifier86>j__TPar','<scolor>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 55 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..U\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 36 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 86 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 38 36 7D 2C 20 73 63 6F 6C 6F 72 20 3D 20 7B 73   // 86}, scolor = {s
                                                                                                 63 6F 6C 6F 72 7D 20 7D 01 00 54 0E 04 54 79 70   // color} }..T..Typ
                                                                                                 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70   // e.<Anonymous Typ
                                                                                                 65 3E )                                           // e>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier86>j__TPar' '<<>h__TransparentIdentifier86>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<scolor>j__TPar' '<scolor>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier86>j__TPar' '<>h__TransparentIdentifier86',
                               !'<scolor>j__TPar' scolor) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier86>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType27`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier86>j__TPar' 
          'get_<>h__TransparentIdentifier86'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier86>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier86>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType27`2'::'get_<>h__TransparentIdentifier86'

  .method public hidebysig specialname instance !'<scolor>j__TPar' 
          get_scolor() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<scolor>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType27`2'::get_scolor

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier86 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier86>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier86>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", scolor = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0037:  box        !'<scolor>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType27`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier86>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier86>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier86>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier86>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::Equals(!0,
                                                                                                                                 !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType27`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xaa5af462
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier86>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<<>h__TransparentIdentifier86>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier86>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType27`2'<!'<<>h__TransparentIdentifier86>j__TPar',!'<scolor>j__TPar'>::'<scolor>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<scolor>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType27`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier86>j__TPar'
          '<>h__TransparentIdentifier86'()
  {
    .get instance !'<<>h__TransparentIdentifier86>j__TPar' '<>f__AnonymousType27`2'::'get_<>h__TransparentIdentifier86'()
  } // end of property '<>f__AnonymousType27`2'::'<>h__TransparentIdentifier86'
  .property instance !'<scolor>j__TPar' scolor()
  {
    .get instance !'<scolor>j__TPar' '<>f__AnonymousType27`2'::get_scolor()
  } // end of property '<>f__AnonymousType27`2'::scolor
} // end of class '<>f__AnonymousType27`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType28`2'<'<<>h__TransparentIdentifier79>j__TPar','<naturalColors>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 63 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..c\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 39 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 79 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 39 7D 2C 20 6E 61 74 75 72 61 6C 43 6F 6C 6F   // 79}, naturalColo
                                                                                                 72 73 20 3D 20 7B 6E 61 74 75 72 61 6C 43 6F 6C   // rs = {naturalCol
                                                                                                 6F 72 73 7D 20 7D 01 00 54 0E 04 54 79 70 65 10   // ors} }..T..Type.
                                                                                                 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E ) // <Anonymous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier79>j__TPar' '<<>h__TransparentIdentifier79>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<naturalColors>j__TPar' '<naturalColors>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier79>j__TPar' '<>h__TransparentIdentifier79',
                               !'<naturalColors>j__TPar' naturalColors) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier79>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType28`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier79>j__TPar' 
          'get_<>h__TransparentIdentifier79'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier79>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier79>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType28`2'::'get_<>h__TransparentIdentifier79'

  .method public hidebysig specialname instance !'<naturalColors>j__TPar' 
          get_naturalColors() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<naturalColors>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType28`2'::get_naturalColors

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier79 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier79>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier79>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", naturalColors = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0037:  box        !'<naturalColors>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType28`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier79>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier79>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier79>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier79>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::Equals(!0,
                                                                                                                                        !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType28`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x4ad5ec34
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier79>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<<>h__TransparentIdentifier79>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier79>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType28`2'<!'<<>h__TransparentIdentifier79>j__TPar',!'<naturalColors>j__TPar'>::'<naturalColors>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<naturalColors>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType28`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier79>j__TPar'
          '<>h__TransparentIdentifier79'()
  {
    .get instance !'<<>h__TransparentIdentifier79>j__TPar' '<>f__AnonymousType28`2'::'get_<>h__TransparentIdentifier79'()
  } // end of property '<>f__AnonymousType28`2'::'<>h__TransparentIdentifier79'
  .property instance !'<naturalColors>j__TPar'
          naturalColors()
  {
    .get instance !'<naturalColors>j__TPar' '<>f__AnonymousType28`2'::get_naturalColors()
  } // end of property '<>f__AnonymousType28`2'::naturalColors
} // end of class '<>f__AnonymousType28`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType29`2'<'<<>h__TransparentIdentifier7a>j__TPar','<reflectPos>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 5D 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..]\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 61 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 7a = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 61 7D 2C 20 72 65 66 6C 65 63 74 50 6F 73 20   // 7a}, reflectPos 
                                                                                                 3D 20 7B 72 65 66 6C 65 63 74 50 6F 73 7D 20 7D   // = {reflectPos} }
                                                                                                 01 00 54 0E 04 54 79 70 65 10 3C 41 6E 6F 6E 79   // ..T..Type.<Anony
                                                                                                 6D 6F 75 73 20 54 79 70 65 3E )                   // mous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier7a>j__TPar' '<<>h__TransparentIdentifier7a>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<reflectPos>j__TPar' '<reflectPos>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier7a>j__TPar' '<>h__TransparentIdentifier7a',
                               !'<reflectPos>j__TPar' reflectPos) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier7a>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType29`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier7a>j__TPar' 
          'get_<>h__TransparentIdentifier7a'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier7a>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier7a>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType29`2'::'get_<>h__TransparentIdentifier7a'

  .method public hidebysig specialname instance !'<reflectPos>j__TPar' 
          get_reflectPos() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<reflectPos>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType29`2'::get_reflectPos

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier7a = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier7a>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier7a>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", reflectPos = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0037:  box        !'<reflectPos>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType29`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7a>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier7a>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier7a>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7a>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::Equals(!0,
                                                                                                                                     !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType29`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xc7857f63
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7a>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<<>h__TransparentIdentifier7a>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7a>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType29`2'<!'<<>h__TransparentIdentifier7a>j__TPar',!'<reflectPos>j__TPar'>::'<reflectPos>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectPos>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType29`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier7a>j__TPar'
          '<>h__TransparentIdentifier7a'()
  {
    .get instance !'<<>h__TransparentIdentifier7a>j__TPar' '<>f__AnonymousType29`2'::'get_<>h__TransparentIdentifier7a'()
  } // end of property '<>f__AnonymousType29`2'::'<>h__TransparentIdentifier7a'
  .property instance !'<reflectPos>j__TPar'
          reflectPos()
  {
    .get instance !'<reflectPos>j__TPar' '<>f__AnonymousType29`2'::get_reflectPos()
  } // end of property '<>f__AnonymousType29`2'::reflectPos
} // end of class '<>f__AnonymousType29`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType2a`2'<'<<>h__TransparentIdentifier7b>j__TPar','<reflectColor>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 61 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..a\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 62 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 7b = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 62 7D 2C 20 72 65 66 6C 65 63 74 43 6F 6C 6F   // 7b}, reflectColo
                                                                                                 72 20 3D 20 7B 72 65 66 6C 65 63 74 43 6F 6C 6F   // r = {reflectColo
                                                                                                 72 7D 20 7D 01 00 54 0E 04 54 79 70 65 10 3C 41   // r} }..T..Type.<A
                                                                                                 6E 6F 6E 79 6D 6F 75 73 20 54 79 70 65 3E )       // nonymous Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier7b>j__TPar' '<<>h__TransparentIdentifier7b>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<reflectColor>j__TPar' '<reflectColor>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier7b>j__TPar' '<>h__TransparentIdentifier7b',
                               !'<reflectColor>j__TPar' reflectColor) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier7b>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType2a`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier7b>j__TPar' 
          'get_<>h__TransparentIdentifier7b'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier7b>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier7b>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2a`2'::'get_<>h__TransparentIdentifier7b'

  .method public hidebysig specialname instance !'<reflectColor>j__TPar' 
          get_reflectColor() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<reflectColor>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2a`2'::get_reflectColor

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier7b = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier7b>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier7b>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", reflectColor = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0037:  box        !'<reflectColor>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType2a`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7b>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier7b>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier7b>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7b>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::Equals(!0,
                                                                                                                                       !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType2a`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x74263ca1
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7b>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<<>h__TransparentIdentifier7b>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier7b>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType2a`2'<!'<<>h__TransparentIdentifier7b>j__TPar',!'<reflectColor>j__TPar'>::'<reflectColor>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<reflectColor>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType2a`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier7b>j__TPar'
          '<>h__TransparentIdentifier7b'()
  {
    .get instance !'<<>h__TransparentIdentifier7b>j__TPar' '<>f__AnonymousType2a`2'::'get_<>h__TransparentIdentifier7b'()
  } // end of property '<>f__AnonymousType2a`2'::'<>h__TransparentIdentifier7b'
  .property instance !'<reflectColor>j__TPar'
          reflectColor()
  {
    .get instance !'<reflectColor>j__TPar' '<>f__AnonymousType2a`2'::get_reflectColor()
  } // end of property '<>f__AnonymousType2a`2'::reflectColor
} // end of class '<>f__AnonymousType2a`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType2b`2'<'<<>h__TransparentIdentifier73>j__TPar','<computeTraceRay>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 67 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..g\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 33 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 73 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 33 7D 2C 20 63 6F 6D 70 75 74 65 54 72 61 63   // 73}, computeTrac
                                                                                                 65 52 61 79 20 3D 20 7B 63 6F 6D 70 75 74 65 54   // eRay = {computeT
                                                                                                 72 61 63 65 52 61 79 7D 20 7D 01 00 54 0E 04 54   // raceRay} }..T..T
                                                                                                 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73 20 54   // ype.<Anonymous T
                                                                                                 79 70 65 3E )                                     // ype>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier73>j__TPar' '<<>h__TransparentIdentifier73>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<computeTraceRay>j__TPar' '<computeTraceRay>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier73>j__TPar' '<>h__TransparentIdentifier73',
                               !'<computeTraceRay>j__TPar' computeTraceRay) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier73>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType2b`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier73>j__TPar' 
          'get_<>h__TransparentIdentifier73'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier73>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier73>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2b`2'::'get_<>h__TransparentIdentifier73'

  .method public hidebysig specialname instance !'<computeTraceRay>j__TPar' 
          get_computeTraceRay() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<computeTraceRay>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2b`2'::get_computeTraceRay

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier73 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier73>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier73>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", computeTraceRay = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0037:  box        !'<computeTraceRay>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType2b`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier73>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier73>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier73>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier73>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::Equals(!0,
                                                                                                                                          !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType2b`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0x266908fa
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier73>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<<>h__TransparentIdentifier73>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier73>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType2b`2'<!'<<>h__TransparentIdentifier73>j__TPar',!'<computeTraceRay>j__TPar'>::'<computeTraceRay>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<computeTraceRay>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType2b`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier73>j__TPar'
          '<>h__TransparentIdentifier73'()
  {
    .get instance !'<<>h__TransparentIdentifier73>j__TPar' '<>f__AnonymousType2b`2'::'get_<>h__TransparentIdentifier73'()
  } // end of property '<>f__AnonymousType2b`2'::'<>h__TransparentIdentifier73'
  .property instance !'<computeTraceRay>j__TPar'
          computeTraceRay()
  {
    .get instance !'<computeTraceRay>j__TPar' '<>f__AnonymousType2b`2'::get_computeTraceRay()
  } // end of property '<>f__AnonymousType2b`2'::computeTraceRay
} // end of class '<>f__AnonymousType2b`2'

.class private auto ansi sealed beforefieldinit '<>f__AnonymousType2c`2'<'<<>h__TransparentIdentifier74>j__TPar','<traceRay>j__TPar'>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 59 5C 7B 20 3C 3E 68 5F 5F 54 72 61 6E 73   // ..Y\{ <>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 34 20 3D 20 7B 3C 3E 68 5F 5F 54 72 61 6E 73   // 74 = {<>h__Trans
                                                                                                 70 61 72 65 6E 74 49 64 65 6E 74 69 66 69 65 72   // parentIdentifier
                                                                                                 37 34 7D 2C 20 74 72 61 63 65 52 61 79 20 3D 20   // 74}, traceRay = 
                                                                                                 7B 74 72 61 63 65 52 61 79 7D 20 7D 01 00 54 0E   // {traceRay} }..T.
                                                                                                 04 54 79 70 65 10 3C 41 6E 6F 6E 79 6D 6F 75 73   // .Type.<Anonymous
                                                                                                 20 54 79 70 65 3E )                               //  Type>
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private initonly !'<<>h__TransparentIdentifier74>j__TPar' '<<>h__TransparentIdentifier74>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field private initonly !'<traceRay>j__TPar' '<traceRay>i__Field'
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!'<<>h__TransparentIdentifier74>j__TPar' '<>h__TransparentIdentifier74',
                               !'<traceRay>j__TPar' traceRay) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ldarg.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      !0 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier74>i__Field'
    IL_000d:  ldarg.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      !1 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0014:  ret
  } // end of method '<>f__AnonymousType2c`2'::.ctor

  .method public hidebysig specialname instance !'<<>h__TransparentIdentifier74>j__TPar' 
          'get_<>h__TransparentIdentifier74'() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<<>h__TransparentIdentifier74>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier74>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2c`2'::'get_<>h__TransparentIdentifier74'

  .method public hidebysig specialname instance !'<traceRay>j__TPar' 
          get_traceRay() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!'<traceRay>j__TPar' V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !1 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method '<>f__AnonymousType2c`2'::get_traceRay

  .method public hidebysig virtual instance string 
          ToString() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       89 (0x59)
    .maxstack  2
    .locals init (class [mscorlib]System.Text.StringBuilder V_0,
             string V_1)
    IL_0000:  newobj     instance void [mscorlib]System.Text.StringBuilder::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldstr      "{ <>h__TransparentIdentifier74 = "
    IL_000c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_0011:  pop
    IL_0012:  ldloc.0
    IL_0013:  ldarg.0
    IL_0014:  ldfld      !0 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier74>i__Field'
    IL_0019:  box        !'<<>h__TransparentIdentifier74>j__TPar'
    IL_001e:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0023:  pop
    IL_0024:  ldloc.0
    IL_0025:  ldstr      ", traceRay = "
    IL_002a:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_002f:  pop
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      !1 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0037:  box        !'<traceRay>j__TPar'
    IL_003c:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(object)
    IL_0041:  pop
    IL_0042:  ldloc.0
    IL_0043:  ldstr      " }"
    IL_0048:  callvirt   instance class [mscorlib]System.Text.StringBuilder [mscorlib]System.Text.StringBuilder::Append(string)
    IL_004d:  pop
    IL_004e:  ldloc.0
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  stloc.1
    IL_0055:  br.s       IL_0057

    IL_0057:  ldloc.1
    IL_0058:  ret
  } // end of method '<>f__AnonymousType2c`2'::ToString

  .method public hidebysig virtual instance bool 
          Equals(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       64 (0x40)
    .maxstack  3
    .locals init (class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'> V_0,
             bool V_1)
    IL_0000:  ldarg.1
    IL_0001:  isinst     class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  brfalse.s  IL_003a

    IL_000a:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier74>j__TPar'>::get_Default()
    IL_000f:  ldarg.0
    IL_0010:  ldfld      !0 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier74>i__Field'
    IL_0015:  ldloc.0
    IL_0016:  ldfld      !0 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier74>i__Field'
    IL_001b:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier74>j__TPar'>::Equals(!0,
                                                                                                                                                       !0)
    IL_0020:  brfalse.s  IL_003a

    IL_0022:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::get_Default()
    IL_0027:  ldarg.0
    IL_0028:  ldfld      !1 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_002d:  ldloc.0
    IL_002e:  ldfld      !1 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0033:  callvirt   instance bool class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::Equals(!0,
                                                                                                                                   !0)
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.0
    IL_003b:  stloc.1
    IL_003c:  br.s       IL_003e

    IL_003e:  ldloc.1
    IL_003f:  ret
  } // end of method '<>f__AnonymousType2c`2'::Equals

  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       62 (0x3e)
    .maxstack  3
    .locals init (int32 V_0,
             int32 V_1)
    IL_0000:  ldc.i4     0xcf933ae6
    IL_0005:  stloc.0
    IL_0006:  ldc.i4     0xa5555529
    IL_000b:  ldloc.0
    IL_000c:  mul
    IL_000d:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier74>j__TPar'>::get_Default()
    IL_0012:  ldarg.0
    IL_0013:  ldfld      !0 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<<>h__TransparentIdentifier74>i__Field'
    IL_0018:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<<>h__TransparentIdentifier74>j__TPar'>::GetHashCode(!0)
    IL_001d:  add
    IL_001e:  stloc.0
    IL_001f:  ldc.i4     0xa5555529
    IL_0024:  ldloc.0
    IL_0025:  mul
    IL_0026:  call       class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::get_Default()
    IL_002b:  ldarg.0
    IL_002c:  ldfld      !1 class '<>f__AnonymousType2c`2'<!'<<>h__TransparentIdentifier74>j__TPar',!'<traceRay>j__TPar'>::'<traceRay>i__Field'
    IL_0031:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.EqualityComparer`1<!'<traceRay>j__TPar'>::GetHashCode(!0)
    IL_0036:  add
    IL_0037:  stloc.0
    IL_0038:  ldloc.0
    IL_0039:  stloc.1
    IL_003a:  br.s       IL_003c

    IL_003c:  ldloc.1
    IL_003d:  ret
  } // end of method '<>f__AnonymousType2c`2'::GetHashCode

  .property instance !'<<>h__TransparentIdentifier74>j__TPar'
          '<>h__TransparentIdentifier74'()
  {
    .get instance !'<<>h__TransparentIdentifier74>j__TPar' '<>f__AnonymousType2c`2'::'get_<>h__TransparentIdentifier74'()
  } // end of property '<>f__AnonymousType2c`2'::'<>h__TransparentIdentifier74'
  .property instance !'<traceRay>j__TPar'
          traceRay()
  {
    .get instance !'<traceRay>j__TPar' '<>f__AnonymousType2c`2'::get_traceRay()
  } // end of property '<>f__AnonymousType2c`2'::traceRay
} // end of class '<>f__AnonymousType2c`2'


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
