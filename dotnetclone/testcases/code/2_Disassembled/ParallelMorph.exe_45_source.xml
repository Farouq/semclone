<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Program.cs" startline="19" endline="23"><![CDATA[
         {
             Application.EnableVisualStyles();
             Application.SetCompatibleTextRenderingDefault(false);
             Application.Run(new MainForm());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.Designer.cs" startline="15" endline="21"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
             this.pbMorphStatus = new System.Windows.Forms.ProgressBar();
             this.btnMorph = new System.Windows.Forms.Button();
             this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
             this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
             this.splitContainer1 = new System.Windows.Forms.SplitContainer();
             this.menuStrip1 = new System.Windows.Forms.MenuStrip();
             this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.newToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.openToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.saveToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
             this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripSeparator();
             this.outputSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.outputSizeToolStripTextBox = new System.Windows.Forms.ToolStripTextBox();
             this.outputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.imagesOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.aviOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
             this.sizeModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.autoSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.zoomToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.processingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.sequentialProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.parallelProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.btnCancel = new System.Windows.Forms.Button();
             this.toolTip1 = new System.Windows.Forms.ToolTip();
             this.pbInProgressMorph = new System.Windows.Forms.PictureBox();
             this.morphInfoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripMenuItem3 = new System.Windows.Forms.ToolStripSeparator();
             this.pbStartImage = new ParallelMorph.LinedPictureBox();
             this.pbEndImage = new ParallelMorph.LinedPictureBox();
             this.splitContainer1.Panel1.SuspendLayout();
             this.splitContainer1.Panel2.SuspendLayout();
             this.splitContainer1.SuspendLayout();
             this.menuStrip1.SuspendLayout();
             this.SuspendLayout();
             // 
             // pbMorphStatus
             // 
             this.pbMorphStatus.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbMorphStatus.Location = new System.Drawing.Point(12, 350);
             this.pbMorphStatus.Name = "pbMorphStatus";
             this.pbMorphStatus.Size = new System.Drawing.Size(492, 23);
             this.pbMorphStatus.Style = System.Windows.Forms.ProgressBarStyle.Continuous;
             this.pbMorphStatus.TabIndex = 8;
             this.pbMorphStatus.Visible = false;
             // 
             // btnMorph
             // 
             this.btnMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.btnMorph.Enabled = false;
             this.btnMorph.Location = new System.Drawing.Point(510, 350);
             this.btnMorph.Name = "btnMorph";
             this.btnMorph.Size = new System.Drawing.Size(127, 23);
             this.btnMorph.TabIndex = 4;
             this.btnMorph.Text = "Morph";
             this.btnMorph.UseVisualStyleBackColor = true;
             this.btnMorph.Click += new System.EventHandler(this.btnMorph_Click);
             // 
             // splitContainer1
             // 
             this.splitContainer1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.splitContainer1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.splitContainer1.Location = new System.Drawing.Point(12, 27);
             this.splitContainer1.Name = "splitContainer1";
             // 
             // splitContainer1.Panel1
             // 
             this.splitContainer1.Panel1.AutoScroll = true;
             this.splitContainer1.Panel1.Controls.Add(this.pbStartImage);
             this.splitContainer1.Panel1.DoubleClick += new System.EventHandler(this.splitContainer1_Panel1_DoubleClick);
             // 
             // splitContainer1.Panel2
             // 
             this.splitContainer1.Panel2.AutoScroll = true;
             this.splitContainer1.Panel2.Controls.Add(this.pbEndImage);
             this.splitContainer1.Panel2.DoubleClick += new System.EventHandler(this.splitContainer1_Panel2_DoubleClick);
             this.splitContainer1.Size = new System.Drawing.Size(625, 317);
             this.splitContainer1.SplitterDistance = 312;
             this.splitContainer1.TabIndex = 9;
             // 
             // menuStrip1
             // 
             this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.fileToolStripMenuItem,
             this.toolsToolStripMenuItem});
             this.menuStrip1.Location = new System.Drawing.Point(0, 0);
             this.menuStrip1.Name = "menuStrip1";
             this.menuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.Professional;
             this.menuStrip1.Size = new System.Drawing.Size(649, 24);
             this.menuStrip1.TabIndex = 10;
             this.menuStrip1.Text = "menuStrip1";
             // 
             // fileToolStripMenuItem
             // 
             this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.newToolStripMenuItem,
             this.openToolStripMenuItem,
             this.saveToolStripMenuItem,
             this.toolStripSeparator2,
             this.exitToolStripMenuItem});
             this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
             this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
             this.fileToolStripMenuItem.Text = "&File";
             // 
             // newToolStripMenuItem
             // 
             this.newToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("newToolStripMenuItem.Image")));
             this.newToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.newToolStripMenuItem.Name = "newToolStripMenuItem";
             this.newToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.N)));
             this.newToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.newToolStripMenuItem.Text = "&New";
             this.newToolStripMenuItem.Click += new System.EventHandler(this.newToolStripMenuItem_Click);
             // 
             // openToolStripMenuItem
             // 
             this.openToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("openToolStripMenuItem.Image")));
             this.openToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.openToolStripMenuItem.Name = "openToolStripMenuItem";
             this.openToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
             this.openToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.openToolStripMenuItem.Text = "&Open";
             this.openToolStripMenuItem.Click += new System.EventHandler(this.openToolStripMenuItem_Click);
             // 
             // saveToolStripMenuItem
             // 
             this.saveToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("saveToolStripMenuItem.Image")));
             this.saveToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.saveToolStripMenuItem.Name = "saveToolStripMenuItem";
             this.saveToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));
             this.saveToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.saveToolStripMenuItem.Text = "&Save";
             this.saveToolStripMenuItem.Click += new System.EventHandler(this.saveToolStripMenuItem_Click);
             // 
             // toolStripSeparator2
             // 
             this.toolStripSeparator2.Name = "toolStripSeparator2";
             this.toolStripSeparator2.Size = new System.Drawing.Size(143, 6);
             // 
             // exitToolStripMenuItem
             // 
             this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
             this.exitToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.exitToolStripMenuItem.Text = "E&xit";
             this.exitToolStripMenuItem.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
             // 
             // toolsToolStripMenuItem
             // 
             this.toolsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.optionsToolStripMenuItem,
             this.toolStripMenuItem2,
             this.outputSizeToolStripMenuItem,
             this.outputToolStripMenuItem,
             this.toolStripMenuItem1,
             this.sizeModeToolStripMenuItem,
             this.processingModeToolStripMenuItem,
             this.toolStripMenuItem3,
             this.morphInfoToolStripMenuItem});
             this.toolsToolStripMenuItem.Name = "toolsToolStripMenuItem";
             this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48, 20);
             this.toolsToolStripMenuItem.Text = "&Tools";
             // 
             // optionsToolStripMenuItem
             // 
             this.optionsToolStripMenuItem.Name = "optionsToolStripMenuItem";
             this.optionsToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.optionsToolStripMenuItem.Text = "&Options...";
             this.optionsToolStripMenuItem.Click += new System.EventHandler(this.optionsToolStripMenuItem_Click);
             // 
             // toolStripMenuItem2
             // 
             this.toolStripMenuItem2.Name = "toolStripMenuItem2";
             this.toolStripMenuItem2.Size = new System.Drawing.Size(162, 6);
             // 
             // outputSizeToolStripMenuItem
             // 
             this.outputSizeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.outputSizeToolStripTextBox});
             this.outputSizeToolStripMenuItem.Name = "outputSizeToolStripMenuItem";
             this.outputSizeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.outputSizeToolStripMenuItem.Text = "Output Size";
             // 
             // outputSizeToolStripTextBox
             // 
             this.outputSizeToolStripTextBox.MaxLength = 3;
             this.outputSizeToolStripTextBox.Name = "outputSizeToolStripTextBox";
             this.outputSizeToolStripTextBox.Size = new System.Drawing.Size(100, 23);
             this.outputSizeToolStripTextBox.Text = "100";
             // 
             // outputToolStripMenuItem
             // 
             this.outputToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.imagesOutputToolStripMenuItem,
             this.aviOutputToolStripMenuItem});
             this.outputToolStripMenuItem.Name = "outputToolStripMenuItem";
             this.outputToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.outputToolStripMenuItem.Text = "Output Type";
             // 
             // imagesOutputToolStripMenuItem
             // 
             this.imagesOutputToolStripMenuItem.Checked = true;
             this.imagesOutputToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
             this.imagesOutputToolStripMenuItem.Name = "imagesOutputToolStripMenuItem";
             this.imagesOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
             this.imagesOutputToolStripMenuItem.Text = "Images";
             this.imagesOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
             // 
             // aviOutputToolStripMenuItem
             // 
             this.aviOutputToolStripMenuItem.Name = "aviOutputToolStripMenuItem";
             this.aviOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
             this.aviOutputToolStripMenuItem.Text = "AVI";
             this.aviOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
             // 
             // toolStripMenuItem1
             // 
             this.toolStripMenuItem1.Name = "toolStripMenuItem1";
             this.toolStripMenuItem1.Size = new System.Drawing.Size(162, 6);
             // 
             // sizeModeToolStripMenuItem
             // 
             this.sizeModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.autoSizeToolStripMenuItem,
             this.zoomToolStripMenuItem});
             this.sizeModeToolStripMenuItem.Name = "sizeModeToolStripMenuItem";
             this.sizeModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.sizeModeToolStripMenuItem.Text = "View Mode";
             // 
             // autoSizeToolStripMenuItem
             // 
             this.autoSizeToolStripMenuItem.Name = "autoSizeToolStripMenuItem";
             this.autoSizeToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
             this.autoSizeToolStripMenuItem.Text = "AutoSize";
             this.autoSizeToolStripMenuItem.Click += new System.EventHandler(this.autoSizeToolStripMenuItem_Click);
             // 
             // zoomToolStripMenuItem
             // 
             this.zoomToolStripMenuItem.Checked = true;
             this.zoomToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
             this.zoomToolStripMenuItem.Name = "zoomToolStripMenuItem";
             this.zoomToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
             this.zoomToolStripMenuItem.Text = "Zoom";
             this.zoomToolStripMenuItem.Click += new System.EventHandler(this.zoomToolStripMenuItem_Click);
             // 
             // processingModeToolStripMenuItem
             // 
             this.processingModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.sequentialProcessingModeToolStripMenuItem,
             this.parallelProcessingModeToolStripMenuItem});
             this.processingModeToolStripMenuItem.Name = "processingModeToolStripMenuItem";
             this.processingModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.processingModeToolStripMenuItem.Text = "Processing Mode";
             // 
             // sequentialProcessingModeToolStripMenuItem
             // 
             this.sequentialProcessingModeToolStripMenuItem.Checked = true;
             this.sequentialProcessingModeToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
             this.sequentialProcessingModeToolStripMenuItem.Name = "sequentialProcessingModeToolStripMenuItem";
             this.sequentialProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
             this.sequentialProcessingModeToolStripMenuItem.Text = "Sequential";
             this.sequentialProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
             // 
             // parallelProcessingModeToolStripMenuItem
             // 
             this.parallelProcessingModeToolStripMenuItem.Name = "parallelProcessingModeToolStripMenuItem";
             this.parallelProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
             this.parallelProcessingModeToolStripMenuItem.Text = "Parallel";
             this.parallelProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
             // 
             // btnCancel
             // 
             this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.btnCancel.Location = new System.Drawing.Point(509, 350);
             this.btnCancel.Name = "btnCancel";
             this.btnCancel.Size = new System.Drawing.Size(127, 23);
             this.btnCancel.TabIndex = 11;
             this.btnCancel.Text = "Cancel";
             this.btnCancel.UseVisualStyleBackColor = true;
             this.btnCancel.Visible = false;
             this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
             // 
             // pbInProgressMorph
             // 
             this.pbInProgressMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbInProgressMorph.BackColor = System.Drawing.SystemColors.ControlLightLight;
             this.pbInProgressMorph.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbInProgressMorph.Location = new System.Drawing.Point(12, 27);
             this.pbInProgressMorph.Name = "pbInProgressMorph";
             this.pbInProgressMorph.Size = new System.Drawing.Size(625, 317);
             this.pbInProgressMorph.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbInProgressMorph.TabIndex = 12;
             this.pbInProgressMorph.TabStop = false;
             this.pbInProgressMorph.Visible = false;
             // 
             // morphInfoToolStripMenuItem
             // 
             this.morphInfoToolStripMenuItem.Name = "morphInfoToolStripMenuItem";
             this.morphInfoToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.morphInfoToolStripMenuItem.Text = "Morph Info...";
             this.morphInfoToolStripMenuItem.Click += new System.EventHandler(this.morphInfoToolStripMenuItem_Click);
             // 
             // toolStripMenuItem3
             // 
             this.toolStripMenuItem3.Name = "toolStripMenuItem3";
             this.toolStripMenuItem3.Size = new System.Drawing.Size(162, 6);
             // 
             // pbStartImage
             // 
             this.pbStartImage.ImageNumber = 0;
             this.pbStartImage.LinePairs = null;
             this.pbStartImage.Location = new System.Drawing.Point(0, 0);
             this.pbStartImage.Name = "pbStartImage";
             this.pbStartImage.Size = new System.Drawing.Size(310, 315);
             this.pbStartImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
             this.pbStartImage.TabIndex = 0;
             this.pbStartImage.TabStop = false;
             this.pbStartImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
             this.pbStartImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
             this.pbStartImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
             this.pbStartImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
             // 
             // pbEndImage
             // 
             this.pbEndImage.ImageNumber = 0;
             this.pbEndImage.LinePairs = null;
             this.pbEndImage.Location = new System.Drawing.Point(0, 0);
             this.pbEndImage.Name = "pbEndImage";
             this.pbEndImage.Size = new System.Drawing.Size(307, 315);
             this.pbEndImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
             this.pbEndImage.TabIndex = 0;
             this.pbEndImage.TabStop = false;
             this.pbEndImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
             this.pbEndImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
             this.pbEndImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
             this.pbEndImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(649, 385);
             this.Controls.Add(this.pbInProgressMorph);
             this.Controls.Add(this.btnCancel);
             this.Controls.Add(this.splitContainer1);
             this.Controls.Add(this.btnMorph);
             this.Controls.Add(this.pbMorphStatus);
             this.Controls.Add(this.menuStrip1);
             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
             this.KeyPreview = true;
             this.MainMenuStrip = this.menuStrip1;
             this.Name = "MainForm";
             this.Text = "Parallel Morph";
             this.Load += new System.EventHandler(this.Form1_Load);
             this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.frmMainForm_KeyDown);
             this.splitContainer1.Panel1.ResumeLayout(false);
             this.splitContainer1.Panel1.PerformLayout();
             this.splitContainer1.Panel2.ResumeLayout(false);
             this.splitContainer1.Panel2.PerformLayout();
             this.splitContainer1.ResumeLayout(false);
             this.menuStrip1.ResumeLayout(false);
             this.menuStrip1.PerformLayout();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
 
         #endregion
 
         private System.Windows.Forms.Button btnMorph;
         private System.Windows.Forms.ColumnHeader columnHeader1;
         private System.Windows.Forms.ColumnHeader columnHeader2;
         private System.Windows.Forms.ProgressBar pbMorphStatus;
         private System.Windows.Forms.SplitContainer splitContainer1;
         private System.Windows.Forms.MenuStrip menuStrip1;
         private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem newToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem openToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem saveToolStripMenuItem;
         private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
         private System.Windows.Forms.ToolStripMenuItem exitToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem toolsToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem optionsToolStripMenuItem;
         private ParallelMorph.LinedPictureBox pbStartImage;
         private ParallelMorph.LinedPictureBox pbEndImage;
         private System.Windows.Forms.ToolStripMenuItem sizeModeToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem autoSizeToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem zoomToolStripMenuItem;
         private System.Windows.Forms.Button btnCancel;
         private System.Windows.Forms.ToolTip toolTip1;
         private System.Windows.Forms.ToolStripMenuItem processingModeToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem sequentialProcessingModeToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem parallelProcessingModeToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem outputToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem aviOutputToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem imagesOutputToolStripMenuItem;
         private System.Windows.Forms.ToolStripMenuItem outputSizeToolStripMenuItem;
         private System.Windows.Forms.PictureBox pbInProgressMorph;
         private System.Windows.Forms.ToolStripTextBox outputSizeToolStripTextBox;
         private System.Windows.Forms.ToolStripSeparator toolStripMenuItem2;
         private System.Windows.Forms.ToolStripSeparator toolStripMenuItem1;
         private System.Windows.Forms.ToolStripSeparator toolStripMenuItem3;
         private System.Windows.Forms.ToolStripMenuItem morphInfoToolStripMenuItem;
     }
 }
 
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.Designer.cs" startline="22" endline="405"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
             this.pbMorphStatus = new System.Windows.Forms.ProgressBar();
             this.btnMorph = new System.Windows.Forms.Button();
             this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
             this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
             this.splitContainer1 = new System.Windows.Forms.SplitContainer();
             this.menuStrip1 = new System.Windows.Forms.MenuStrip();
             this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.newToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.openToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.saveToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
             this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripSeparator();
             this.outputSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.outputSizeToolStripTextBox = new System.Windows.Forms.ToolStripTextBox();
             this.outputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.imagesOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.aviOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
             this.sizeModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.autoSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.zoomToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.processingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.sequentialProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.parallelProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.btnCancel = new System.Windows.Forms.Button();
             this.toolTip1 = new System.Windows.Forms.ToolTip();
             this.pbInProgressMorph = new System.Windows.Forms.PictureBox();
             this.morphInfoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripMenuItem3 = new System.Windows.Forms.ToolStripSeparator();
             this.pbStartImage = new ParallelMorph.LinedPictureBox();
             this.pbEndImage = new ParallelMorph.LinedPictureBox();
             this.splitContainer1.Panel1.SuspendLayout();
             this.splitContainer1.Panel2.SuspendLayout();
             this.splitContainer1.SuspendLayout();
             this.menuStrip1.SuspendLayout();
             this.SuspendLayout();
             // 
             // pbMorphStatus
             // 
             this.pbMorphStatus.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbMorphStatus.Location = new System.Drawing.Point(12, 350);
             this.pbMorphStatus.Name = "pbMorphStatus";
             this.pbMorphStatus.Size = new System.Drawing.Size(492, 23);
             this.pbMorphStatus.Style = System.Windows.Forms.ProgressBarStyle.Continuous;
             this.pbMorphStatus.TabIndex = 8;
             this.pbMorphStatus.Visible = false;
             // 
             // btnMorph
             // 
             this.btnMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.btnMorph.Enabled = false;
             this.btnMorph.Location = new System.Drawing.Point(510, 350);
             this.btnMorph.Name = "btnMorph";
             this.btnMorph.Size = new System.Drawing.Size(127, 23);
             this.btnMorph.TabIndex = 4;
             this.btnMorph.Text = "Morph";
             this.btnMorph.UseVisualStyleBackColor = true;
             this.btnMorph.Click += new System.EventHandler(this.btnMorph_Click);
             // 
             // splitContainer1
             // 
             this.splitContainer1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.splitContainer1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.splitContainer1.Location = new System.Drawing.Point(12, 27);
             this.splitContainer1.Name = "splitContainer1";
             // 
             // splitContainer1.Panel1
             // 
             this.splitContainer1.Panel1.AutoScroll = true;
             this.splitContainer1.Panel1.Controls.Add(this.pbStartImage);
             this.splitContainer1.Panel1.DoubleClick += new System.EventHandler(this.splitContainer1_Panel1_DoubleClick);
             // 
             // splitContainer1.Panel2
             // 
             this.splitContainer1.Panel2.AutoScroll = true;
             this.splitContainer1.Panel2.Controls.Add(this.pbEndImage);
             this.splitContainer1.Panel2.DoubleClick += new System.EventHandler(this.splitContainer1_Panel2_DoubleClick);
             this.splitContainer1.Size = new System.Drawing.Size(625, 317);
             this.splitContainer1.SplitterDistance = 312;
             this.splitContainer1.TabIndex = 9;
             // 
             // menuStrip1
             // 
             this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.fileToolStripMenuItem,
             this.toolsToolStripMenuItem});
             this.menuStrip1.Location = new System.Drawing.Point(0, 0);
             this.menuStrip1.Name = "menuStrip1";
             this.menuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.Professional;
             this.menuStrip1.Size = new System.Drawing.Size(649, 24);
             this.menuStrip1.TabIndex = 10;
             this.menuStrip1.Text = "menuStrip1";
             // 
             // fileToolStripMenuItem
             // 
             this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.newToolStripMenuItem,
             this.openToolStripMenuItem,
             this.saveToolStripMenuItem,
             this.toolStripSeparator2,
             this.exitToolStripMenuItem});
             this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
             this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
             this.fileToolStripMenuItem.Text = "&File";
             // 
             // newToolStripMenuItem
             // 
             this.newToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("newToolStripMenuItem.Image")));
             this.newToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.newToolStripMenuItem.Name = "newToolStripMenuItem";
             this.newToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.N)));
             this.newToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.newToolStripMenuItem.Text = "&New";
             this.newToolStripMenuItem.Click += new System.EventHandler(this.newToolStripMenuItem_Click);
             // 
             // openToolStripMenuItem
             // 
             this.openToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("openToolStripMenuItem.Image")));
             this.openToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.openToolStripMenuItem.Name = "openToolStripMenuItem";
             this.openToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
             this.openToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.openToolStripMenuItem.Text = "&Open";
             this.openToolStripMenuItem.Click += new System.EventHandler(this.openToolStripMenuItem_Click);
             // 
             // saveToolStripMenuItem
             // 
             this.saveToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("saveToolStripMenuItem.Image")));
             this.saveToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.saveToolStripMenuItem.Name = "saveToolStripMenuItem";
             this.saveToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));
             this.saveToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.saveToolStripMenuItem.Text = "&Save";
             this.saveToolStripMenuItem.Click += new System.EventHandler(this.saveToolStripMenuItem_Click);
             // 
             // toolStripSeparator2
             // 
             this.toolStripSeparator2.Name = "toolStripSeparator2";
             this.toolStripSeparator2.Size = new System.Drawing.Size(143, 6);
             // 
             // exitToolStripMenuItem
             // 
             this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
             this.exitToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
             this.exitToolStripMenuItem.Text = "E&xit";
             this.exitToolStripMenuItem.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
             // 
             // toolsToolStripMenuItem
             // 
             this.toolsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.optionsToolStripMenuItem,
             this.toolStripMenuItem2,
             this.outputSizeToolStripMenuItem,
             this.outputToolStripMenuItem,
             this.toolStripMenuItem1,
             this.sizeModeToolStripMenuItem,
             this.processingModeToolStripMenuItem,
             this.toolStripMenuItem3,
             this.morphInfoToolStripMenuItem});
             this.toolsToolStripMenuItem.Name = "toolsToolStripMenuItem";
             this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48, 20);
             this.toolsToolStripMenuItem.Text = "&Tools";
             // 
             // optionsToolStripMenuItem
             // 
             this.optionsToolStripMenuItem.Name = "optionsToolStripMenuItem";
             this.optionsToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.optionsToolStripMenuItem.Text = "&Options...";
             this.optionsToolStripMenuItem.Click += new System.EventHandler(this.optionsToolStripMenuItem_Click);
             // 
             // toolStripMenuItem2
             // 
             this.toolStripMenuItem2.Name = "toolStripMenuItem2";
             this.toolStripMenuItem2.Size = new System.Drawing.Size(162, 6);
             // 
             // outputSizeToolStripMenuItem
             // 
             this.outputSizeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.outputSizeToolStripTextBox});
             this.outputSizeToolStripMenuItem.Name = "outputSizeToolStripMenuItem";
             this.outputSizeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.outputSizeToolStripMenuItem.Text = "Output Size";
             // 
             // outputSizeToolStripTextBox
             // 
             this.outputSizeToolStripTextBox.MaxLength = 3;
             this.outputSizeToolStripTextBox.Name = "outputSizeToolStripTextBox";
             this.outputSizeToolStripTextBox.Size = new System.Drawing.Size(100, 23);
             this.outputSizeToolStripTextBox.Text = "100";
             // 
             // outputToolStripMenuItem
             // 
             this.outputToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.imagesOutputToolStripMenuItem,
             this.aviOutputToolStripMenuItem});
             this.outputToolStripMenuItem.Name = "outputToolStripMenuItem";
             this.outputToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.outputToolStripMenuItem.Text = "Output Type";
             // 
             // imagesOutputToolStripMenuItem
             // 
             this.imagesOutputToolStripMenuItem.Checked = true;
             this.imagesOutputToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
             this.imagesOutputToolStripMenuItem.Name = "imagesOutputToolStripMenuItem";
             this.imagesOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
             this.imagesOutputToolStripMenuItem.Text = "Images";
             this.imagesOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
             // 
             // aviOutputToolStripMenuItem
             // 
             this.aviOutputToolStripMenuItem.Name = "aviOutputToolStripMenuItem";
             this.aviOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
             this.aviOutputToolStripMenuItem.Text = "AVI";
             this.aviOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
             // 
             // toolStripMenuItem1
             // 
             this.toolStripMenuItem1.Name = "toolStripMenuItem1";
             this.toolStripMenuItem1.Size = new System.Drawing.Size(162, 6);
             // 
             // sizeModeToolStripMenuItem
             // 
             this.sizeModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.autoSizeToolStripMenuItem,
             this.zoomToolStripMenuItem});
             this.sizeModeToolStripMenuItem.Name = "sizeModeToolStripMenuItem";
             this.sizeModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.sizeModeToolStripMenuItem.Text = "View Mode";
             // 
             // autoSizeToolStripMenuItem
             // 
             this.autoSizeToolStripMenuItem.Name = "autoSizeToolStripMenuItem";
             this.autoSizeToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
             this.autoSizeToolStripMenuItem.Text = "AutoSize";
             this.autoSizeToolStripMenuItem.Click += new System.EventHandler(this.autoSizeToolStripMenuItem_Click);
             // 
             // zoomToolStripMenuItem
             // 
             this.zoomToolStripMenuItem.Checked = true;
             this.zoomToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
             this.zoomToolStripMenuItem.Name = "zoomToolStripMenuItem";
             this.zoomToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
             this.zoomToolStripMenuItem.Text = "Zoom";
             this.zoomToolStripMenuItem.Click += new System.EventHandler(this.zoomToolStripMenuItem_Click);
             // 
             // processingModeToolStripMenuItem
             // 
             this.processingModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.sequentialProcessingModeToolStripMenuItem,
             this.parallelProcessingModeToolStripMenuItem});
             this.processingModeToolStripMenuItem.Name = "processingModeToolStripMenuItem";
             this.processingModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.processingModeToolStripMenuItem.Text = "Processing Mode";
             // 
             // sequentialProcessingModeToolStripMenuItem
             // 
             this.sequentialProcessingModeToolStripMenuItem.Checked = true;
             this.sequentialProcessingModeToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
             this.sequentialProcessingModeToolStripMenuItem.Name = "sequentialProcessingModeToolStripMenuItem";
             this.sequentialProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
             this.sequentialProcessingModeToolStripMenuItem.Text = "Sequential";
             this.sequentialProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
             // 
             // parallelProcessingModeToolStripMenuItem
             // 
             this.parallelProcessingModeToolStripMenuItem.Name = "parallelProcessingModeToolStripMenuItem";
             this.parallelProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
             this.parallelProcessingModeToolStripMenuItem.Text = "Parallel";
             this.parallelProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
             // 
             // btnCancel
             // 
             this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.btnCancel.Location = new System.Drawing.Point(509, 350);
             this.btnCancel.Name = "btnCancel";
             this.btnCancel.Size = new System.Drawing.Size(127, 23);
             this.btnCancel.TabIndex = 11;
             this.btnCancel.Text = "Cancel";
             this.btnCancel.UseVisualStyleBackColor = true;
             this.btnCancel.Visible = false;
             this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
             // 
             // pbInProgressMorph
             // 
             this.pbInProgressMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbInProgressMorph.BackColor = System.Drawing.SystemColors.ControlLightLight;
             this.pbInProgressMorph.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbInProgressMorph.Location = new System.Drawing.Point(12, 27);
             this.pbInProgressMorph.Name = "pbInProgressMorph";
             this.pbInProgressMorph.Size = new System.Drawing.Size(625, 317);
             this.pbInProgressMorph.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbInProgressMorph.TabIndex = 12;
             this.pbInProgressMorph.TabStop = false;
             this.pbInProgressMorph.Visible = false;
             // 
             // morphInfoToolStripMenuItem
             // 
             this.morphInfoToolStripMenuItem.Name = "morphInfoToolStripMenuItem";
             this.morphInfoToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
             this.morphInfoToolStripMenuItem.Text = "Morph Info...";
             this.morphInfoToolStripMenuItem.Click += new System.EventHandler(this.morphInfoToolStripMenuItem_Click);
             // 
             // toolStripMenuItem3
             // 
             this.toolStripMenuItem3.Name = "toolStripMenuItem3";
             this.toolStripMenuItem3.Size = new System.Drawing.Size(162, 6);
             // 
             // pbStartImage
             // 
             this.pbStartImage.ImageNumber = 0;
             this.pbStartImage.LinePairs = null;
             this.pbStartImage.Location = new System.Drawing.Point(0, 0);
             this.pbStartImage.Name = "pbStartImage";
             this.pbStartImage.Size = new System.Drawing.Size(310, 315);
             this.pbStartImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
             this.pbStartImage.TabIndex = 0;
             this.pbStartImage.TabStop = false;
             this.pbStartImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
             this.pbStartImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
             this.pbStartImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
             this.pbStartImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
             // 
             // pbEndImage
             // 
             this.pbEndImage.ImageNumber = 0;
             this.pbEndImage.LinePairs = null;
             this.pbEndImage.Location = new System.Drawing.Point(0, 0);
             this.pbEndImage.Name = "pbEndImage";
             this.pbEndImage.Size = new System.Drawing.Size(307, 315);
             this.pbEndImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
             this.pbEndImage.TabIndex = 0;
             this.pbEndImage.TabStop = false;
             this.pbEndImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
             this.pbEndImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
             this.pbEndImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
             this.pbEndImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(649, 385);
             this.Controls.Add(this.pbInProgressMorph);
             this.Controls.Add(this.btnCancel);
             this.Controls.Add(this.splitContainer1);
             this.Controls.Add(this.btnMorph);
             this.Controls.Add(this.pbMorphStatus);
             this.Controls.Add(this.menuStrip1);
             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
             this.KeyPreview = true;
             this.MainMenuStrip = this.menuStrip1;
             this.Name = "MainForm";
             this.Text = "Parallel Morph";
             this.Load += new System.EventHandler(this.Form1_Load);
             this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.frmMainForm_KeyDown);
             this.splitContainer1.Panel1.ResumeLayout(false);
             this.splitContainer1.Panel1.PerformLayout();
             this.splitContainer1.Panel2.ResumeLayout(false);
             this.splitContainer1.Panel2.PerformLayout();
             this.splitContainer1.ResumeLayout(false);
             this.menuStrip1.ResumeLayout(false);
             this.menuStrip1.PerformLayout();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="8" endline="36"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         private UiSettings _morphSettings = new UiSettings();
         private LinePairCollection _lines;
         private int _currentLineImageNumber = 0;
         private int _currentLineEnd = 0;
         private bool _lineCreationInProcess = false;
         private TaskFactory _uiThread;
         private ComputeMorph _morpher;
         private CancellationTokenSource _currentCancellationSource;
 
         public MainForm()
         {
             InitializeComponent();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="37" endline="49"><![CDATA[
 
         private void Form1_Load(object sender, EventArgs e)
         {
             // Create a Task factory to use for targetting the UI thread
             _uiThread = new TaskFactory(TaskScheduler.FromCurrentSynchronizationContext());
 
             // Initialize the picture boxes
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
 
             // Set up the parallel menu item to reflect the number of cores
             parallelProcessingModeToolStripMenuItem.Text += " (" + Environment.ProcessorCount + "x)";
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="50" endline="82"><![CDATA[
 
         private void ConfigurePictureBoxes(LinePairCollection lines, Image startImage, Image endImage)
         {
             // The lines collection stores the line pairs.  Configure the start image to selec the 0th line from each pair.
             pbStartImage.LinePairs = _lines;
             pbStartImage.ImageNumber = 0;
             pbStartImage.Image = startImage;
 
             // ... and configure the start image to selec the 0th line from each pair.
             pbEndImage.LinePairs = _lines;
             pbEndImage.ImageNumber = 1;
             pbEndImage.Image = endImage;
 
             if (autoSizeToolStripMenuItem.Checked)
             {
                 pbStartImage.Dock = DockStyle.None;
                 pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
                 pbEndImage.Dock = DockStyle.None;
                 pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             }
             else if (zoomToolStripMenuItem.Checked)
             {
                 pbStartImage.Dock = DockStyle.Fill;
                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
                 pbEndImage.Dock = DockStyle.Fill;
                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             }
 
             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
 
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private string SelectOutputPath(OutputMode mode)
         {
             switch (mode)
             {
                 case OutputMode.Movie
                     // Get target movie path
                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
                     else return null;
 
                 case OutputMode.ImageSequence
                     // Get target directory path
                     var fbd = new FolderBrowserDialog();
                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
                     else return null;
 
                 default
                     throw new InvalidOperationException();
             }
         }
 
         private void PrepareUIDataForMorph(
             out UiSettings settings, out LinePairCollection lines,
             out Bitmap newStartImage, out Bitmap newEndImage)
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             {
                 pbStartImage.Dock = DockStyle.None;
                 pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
                 pbEndImage.Dock = DockStyle.None;
                 pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             }
             else if (zoomToolStripMenuItem.Checked)
             {
                 pbStartImage.Dock = DockStyle.Fill;
                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
                 pbEndImage.Dock = DockStyle.Fill;
                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             }
 
             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
 
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private string SelectOutputPath(OutputMode mode)
         {
             switch (mode)
             {
                 case OutputMode.Movie
                     // Get target movie path
                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
                     else return null;
 
                 case OutputMode.ImageSequence
                     // Get target directory path
                     var fbd = new FolderBrowserDialog();
                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
                     else return null;
 
                 default
                     throw new InvalidOperationException();
             }
         }
 
         private void PrepareUIDataForMorph(
             out UiSettings settings, out LinePairCollection lines,
             out Bitmap newStartImage, out Bitmap newEndImage)
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             else if (zoomToolStripMenuItem.Checked)
             {
                 pbStartImage.Dock = DockStyle.Fill;
                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
                 pbEndImage.Dock = DockStyle.Fill;
                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             }
 
             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
 
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private string SelectOutputPath(OutputMode mode)
         {
             switch (mode)
             {
                 case OutputMode.Movie
                     // Get target movie path
                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
                     else return null;
 
                 case OutputMode.ImageSequence
                     // Get target directory path
                     var fbd = new FolderBrowserDialog();
                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
                     else return null;
 
                 default
                     throw new InvalidOperationException();
             }
         }
 
         private void PrepareUIDataForMorph(
             out UiSettings settings, out LinePairCollection lines,
             out Bitmap newStartImage, out Bitmap newEndImage)
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             {
                 pbStartImage.Dock = DockStyle.Fill;
                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
                 pbEndImage.Dock = DockStyle.Fill;
                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             }
 
             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
 
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="83" endline="103"><![CDATA[
 
         private string SelectOutputPath(OutputMode mode)
         {
             switch (mode)
             {
                 case OutputMode.Movie
                     // Get target movie path
                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
                     else return null;
 
                 case OutputMode.ImageSequence
                     // Get target directory path
                     var fbd = new FolderBrowserDialog();
                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
                     else return null;
 
                 default
                     throw new InvalidOperationException();
             }
         }
 
         private void PrepareUIDataForMorph(
             out UiSettings settings, out LinePairCollection lines,
             out Bitmap newStartImage, out Bitmap newEndImage)
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
                     else return null;
 
                 case OutputMode.ImageSequence
                     // Get target directory path
                     var fbd = new FolderBrowserDialog();
                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
                     else return null;
 
                 default
                     throw new InvalidOperationException();
             }
         }
 
         private void PrepareUIDataForMorph(
             out UiSettings settings, out LinePairCollection lines,
             out Bitmap newStartImage, out Bitmap newEndImage)
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
                     else return null;
 
                 case OutputMode.ImageSequence
                     // Get target directory path
                     var fbd = new FolderBrowserDialog();
                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
                     else return null;
 
                 default
                     throw new InvalidOperationException();
             }
         }
 
         private void PrepareUIDataForMorph(
             out UiSettings settings, out LinePairCollection lines,
             out Bitmap newStartImage, out Bitmap newEndImage)
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
                     else return null;
 
                 default
                     throw new InvalidOperationException();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="104" endline="141"><![CDATA[
 
         private void PrepareUIDataForMorph(
             out UiSettings settings, out LinePairCollection lines,
             out Bitmap newStartImage, out Bitmap newEndImage)
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         {
             // Grab UI data
             settings = Utilities.DeepClone(_morphSettings);
             lines = Utilities.DeepClone(_lines);
 
             // Get the original iamges
             var origStartImage = (Bitmap)pbStartImage.Image;
             var origEndImage = (Bitmap)pbEndImage.Image;
 
             // Get a scale factor from the UI
             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
 
             // Create the starting and ending images.  The starting image is scaled by the UI setting,
             // and the ending image is created to match the starting image's size.
             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
 
             // Get a scale factor by comparing the new and old ending images
             var endImageScaleFactor = new PointF(
                 newEndImage.Width / (float)origEndImage.Width,
                 newEndImage.Height / (float)origEndImage.Height);
 
             // Create new line pairings to cope with the scaling
             var newlineList =
                 (from pair in _lines
                  select Tuple.Create(
                      new Line(
                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
                      new Line(
                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
             lines = new LinePairCollection(newlineList);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="142" endline="220"><![CDATA[
 
         private void btnMorph_Click(object sender, EventArgs e)
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         {
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
 
             // Get the parallel mode, the output mode, and query the user for the output path
             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie 
             string outputPath = SelectOutputPath(outputMode);
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             if (outputPath == null) return;
 
             // Grab UI data
             UiSettings settings;
             LinePairCollection lines;
             Bitmap startImage, endImage;
             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
 
             // Setup UI for run
             this.Text = "Parallel Morph - Running...";
             pbMorphStatus.Visible = true;
             splitContainer1.Visible = false;
             menuStrip1.Enabled = false;
             btnCancel.Visible = true;
             btnCancel.Enabled = true;
             btnMorph.Enabled = false;
             pbInProgressMorph.Visible = true;
             _currentCancellationSource = new CancellationTokenSource();
             var cancellationToken = _currentCancellationSource.Token;
 
             // Time how long the operation takes
             Stopwatch startTime = Stopwatch.StartNew();
 
             // Create the morpher and launch the algorithm to run asynchronously
             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="221" endline="241"><![CDATA[
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="242" endline="270"><![CDATA[
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="271" endline="291"><![CDATA[
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     end = i;
                     return true;
                 }
             }
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="292" endline="314"><![CDATA[
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="315" endline="336"><![CDATA[
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="337" endline="356"><![CDATA[
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="357" endline="361"><![CDATA[
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="362" endline="366"><![CDATA[
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="367" endline="371"><![CDATA[
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="372" endline="381"><![CDATA[
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="382" endline="391"><![CDATA[
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="392" endline="400"><![CDATA[
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="401" endline="405"><![CDATA[
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="406" endline="412"><![CDATA[
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="413" endline="432"><![CDATA[
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="433" endline="456"><![CDATA[
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="457" endline="470"><![CDATA[
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="471" endline="475"><![CDATA[
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="476" endline="480"><![CDATA[
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="481" endline="486"><![CDATA[
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="487" endline="494"><![CDATA[
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="495" endline="502"><![CDATA[
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="503" endline="514"><![CDATA[
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs" startline="515" endline="516"><![CDATA[
     }
 }
             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
             Task.Factory.StartNew(() =>
             {
                 // Create an output writer based on whether we're writing to image files or to a movie file
                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) 
                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
                 {
                     // Also display every frame to the UI
                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
                     {
                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
                         _uiThread.StartNew(() =>
                         {
                             Image oldImage = pbInProgressMorph.Image;
                             pbInProgressMorph.Image = clonedBmp;
                             if (oldImage != null) oldImage.Dispose();
                         });
                     });
 
                     // Run the morph synchronously
                     _morpher.Render(imageWriter, lines, startImage, endImage);
                 }
 
                 // When the morph completes, update the UI...
             }, cancellationToken).ContinueWith(t =>
             {
                 _morpher = null;
                 btnMorph.Enabled = true;
                 btnCancel.Visible = false;
                 pbMorphStatus.Visible = false;
                 splitContainer1.Visible = true;
                 menuStrip1.Enabled = true;
                 pbInProgressMorph.Visible = false;
                 if (pbInProgressMorph.Image != null)
                 {
                     Image oldImage = pbInProgressMorph.Image;
                     pbInProgressMorph.Image = null;
                     oldImage.Dispose();
                 }
 
                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
             }, _uiThread.Scheduler);
         }
 
 
         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
         {
             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
             // support deleting line pairs.
             switch (e.KeyCode)
             {
                 case Keys.Right
                 case Keys.Left
                 case Keys.Up
                 case Keys.Down
                 case Keys.Back
                 case Keys.Delete
                 case Keys.D
                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
                     break;
             }
             pbStartImage.Refresh();
             pbEndImage.Refresh();
         }
 
         private void SetFoundPairAtPoint(int imageNum, PointF location)
         {
             const int radius = 6;
             int end;
 
             // First check if the selected one fits, and keep it if it does
             if (_lines.Selected != null &&
                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
             {
                 _currentLineImageNumber = imageNum;
                 _currentLineEnd = end;
                 return;
             }
 
             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
             _lines.Selected = null;
             foreach (var pair in _lines)
             {
                 Line line = pair.Item(imageNum);
                 if (LineHitByPoint(line, location, radius, out end))
                 {
                     _currentLineImageNumber = imageNum;
                     _currentLineEnd = end;
                     _lines.Selected = pair;
                     return;
                 }
             }
         }
 
         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
         {
             end = -1;
             for (int i = 0; i < 2; i++)
             {
                 PointF p = line[i];
 
                 int x = (int)(p.X - radius);
                 if (x < 0) x = 0;
                 int y = (int)(p.Y - radius);
                 if (y < 0) y = 0;
 
                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
                 {
                     end = i;
                     return true;
                 }
             }
             return false;
         }
 
         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
                 if (e.Button == MouseButtons.Left)
                 {
                     SetFoundPairAtPoint(pb.ImageNumber, point);
                 }
                 else
                 {
                     _lines.Add(Tuple.Create(
                         new Line(point, point),
                         new Line(point, point)));
                     _currentLineImageNumber = pb.ImageNumber;
                     _currentLineEnd = 1;
                     _lineCreationInProcess = true;
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lineCreationInProcess)
                 {
                     // If we're creating a new line and if the line is too small, delete it.
                     if (_lines.Selected != null)
                     {
                         var line = _lines.Selected.Item(_currentLineImageNumber);
                         if (line.Item1.Equals(line.Item2))
                         {
                             _lines.Remove(_lines.Selected);
                         }
                     }
                 }
                 _lineCreationInProcess = false;
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
         {
             if (pbStartImage.Image != null && pbEndImage.Image != null)
             {
                 if (_lines.Selected != null &&
                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
                 {
                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
                     if (_lineCreationInProcess)
                     {
                         // if we're creating the line, shape both the start and end line the same
                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
                     }
                 }
                 pbStartImage.Refresh();
                 pbEndImage.Refresh();
             }
         }
 
         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseDown(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseMove(e, (LinedPictureBox)sender);
         }
 
         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
         {
             HandleMouseUp(e, (LinedPictureBox)sender);
         }
 
         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbStartImage.Dock = DockStyle.None;
             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
             pbEndImage.Dock = DockStyle.None;
             autoSizeToolStripMenuItem.Checked = true;
             zoomToolStripMenuItem.Checked = false;
         }
 
         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
         {
             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbStartImage.Dock = DockStyle.Fill;
             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
             pbEndImage.Dock = DockStyle.Fill;
             autoSizeToolStripMenuItem.Checked = false;
             zoomToolStripMenuItem.Checked = true;
         }
 
         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
         {
             using (EditSettings es = new EditSettings())
             {
                 es.Settings = _morphSettings;
                 es.ShowDialog(this);
             }
         }
 
         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
         {
             Application.Exit();
         }
 
         private void newToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Text = "Parallel Morph";
             _lines = new LinePairCollection();
             ConfigurePictureBoxes(_lines, null, null);
         }
 
         private void openToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = ofd.OpenFile())
                     {
                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
                         _lines = ss.Lines;
                         _morphSettings = ss.Settings;
                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
                     }
                 }
             }
         }
 
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             _lines.Selected = null;
             SavedSettings ss = new SavedSettings
             {
                 FirstImage = pbStartImage.Image,
                 SecondImage = pbEndImage.Image,
                 Lines = _lines,
                 Settings = _morphSettings
             };
             using (SaveFileDialog sfd = new SaveFileDialog())
             {
                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     var formatter = new BinaryFormatter();
                     using (Stream fileStream = sfd.OpenFile())
                     {
                         formatter.Serialize(fileStream, ss);
                     }
                 }
             }
         }
 
         private void LoadPictureBoxImage(object sender, EventArgs e)
         {
             _lines.Selected = null;
             using (OpenFileDialog ofd = new OpenFileDialog())
             {
                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
                 if (ofd.ShowDialog(this) == DialogResult.OK)
                 {
                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
                 }
             }
             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
         }
 
         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbStartImage, e);
         }
 
         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
         {
             LoadPictureBoxImage(pbEndImage, e);
         }
 
         private void btnCancel_Click(object sender, EventArgs e)
         {
             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
             btnCancel.Enabled = false;
         }
 
         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
         {
             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
             {
                 item.Checked = item == sender;
             }
         }
 
         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var image = pbStartImage.Image;
             MessageBox.Show(this, 
                 string.Format("Lines
                     Environment.NewLine,
                     _lines.Count, 
                     image != null ? image.Width 
                     image != null ? image.Height 
                 "Morph Information");
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Settings.Designer.cs" startline="21" endline="23"><![CDATA[
             get {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Settings.Designer.cs" startline="18" endline="26"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
         
         public static Settings Default {
             get {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\PassthroughImageWriter.cs" startline="19" endline="24"><![CDATA[
         public PassthroughImageWriter(IImageWriter writer, params Action<Bitmap> [] handlers)
         {
             if (writer == null) throw new ArgumentNullException("writer");
             _writer = writer;
             _handlers = handlers;
         }
 
         public void AddFrame(Bitmap frame)
         {
             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
             _writer.AddFrame(frame);
         }
 
         void IDisposable.Dispose() {}
     }
 }
             if (writer == null) throw new ArgumentNullException("writer");
             _writer = writer;
             _handlers = handlers;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\PassthroughImageWriter.cs" startline="25" endline="30"><![CDATA[
 
         public void AddFrame(Bitmap frame)
         {
             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
             _writer.AddFrame(frame);
         }
 
         void IDisposable.Dispose() {}
     }
 }
             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
             _writer.AddFrame(frame);
         }
 
         void IDisposable.Dispose() {}
     }
 }
             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
             _writer.AddFrame(frame);
         }
 
         void IDisposable.Dispose() {}
     }
 }
             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
             _writer.AddFrame(frame);
         }
 
         void IDisposable.Dispose() {}
     }
 }
             _writer.AddFrame(frame);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\PassthroughImageWriter.cs" startline="31" endline="32"><![CDATA[
 
         void IDisposable.Dispose() {}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\JpgImageWriter.cs" startline="20" endline="29"><![CDATA[
         private int _frameNum = 0;
 
         public JpgImageWriter(string directoryPath, string imageFilePrefix)
         {
             if (directoryPath == null) throw new ArgumentNullException("directoryPath");
             if (imageFilePrefix == null) throw new ArgumentNullException("imageFilePrefix");
             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
             _directoryPath = directoryPath;
             _imageFilePrefix = imageFilePrefix;
         }
 
         public void AddFrame(Bitmap frame)
         {
             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
         }
 
         public void Dispose() { }
     }
 }
             if (directoryPath == null) throw new ArgumentNullException("directoryPath");
             if (imageFilePrefix == null) throw new ArgumentNullException("imageFilePrefix");
             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
             _directoryPath = directoryPath;
             _imageFilePrefix = imageFilePrefix;
         }
 
         public void AddFrame(Bitmap frame)
         {
             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
         }
 
         public void Dispose() { }
     }
 }
             if (imageFilePrefix == null) throw new ArgumentNullException("imageFilePrefix");
             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
             _directoryPath = directoryPath;
             _imageFilePrefix = imageFilePrefix;
         }
 
         public void AddFrame(Bitmap frame)
         {
             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
         }
 
         public void Dispose() { }
     }
 }
             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
             _directoryPath = directoryPath;
             _imageFilePrefix = imageFilePrefix;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\JpgImageWriter.cs" startline="30" endline="34"><![CDATA[
 
         public void AddFrame(Bitmap frame)
         {
             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\JpgImageWriter.cs" startline="35" endline="36"><![CDATA[
 
         public void Dispose() { }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="22" endline="32"><![CDATA[
 		private int _curFrame = 0;
         private CancellationToken _cancellationToken;
         private bool _useParallelism;
 
         public ComputeMorph(ComputeMorphOptions options, bool useParallelism, CancellationToken cancellationToken)
         {
             if (options == null) throw new ArgumentNullException("options");
             _options = options;
             _useParallelism = useParallelism;
             _cancellationToken = cancellationToken;
         }
 
         public event ProgressChangedEventHandler ProgressChanged;
 
         private void UpdateProgressChanged()
         {
             ProgressChangedEventHandler handler = ProgressChanged;
             if (handler != null)
             {
                 double progress = _curFrame * 100.0 / _options.NumberOfOutputFrames;
                 handler(this, new ProgressChangedEventArgs((int)progress, null));
             }
         }
 
         public Bitmap RenderFrame(LinePairCollection lines, Bitmap startImage, Bitmap endImage, double percent)
         {
             using (FastBitmap fastStartImage = new FastBitmap(startImage))
             using (FastBitmap fastEndImage = new FastBitmap(endImage))
             {
                 return RenderFrame(lines, fastStartImage, fastEndImage, percent);
             }
         }
 
         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
         {
             var forwardsAndBackwards = InterpolateLines(lines, percent);
             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
                 return BlendImages(forward, backward, 1 - percent);
         }
 
 		/// <summary>Create the morphed images and video.</summary>
         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
         {
             _curFrame = 0;
             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
 
             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
             {
                 // Write out the starting picture
                 imageWriter.AddFrame(clonedStart);
                 _curFrame = 1;
                 UpdateProgressChanged();
 
                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
                 {
                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
                         {
                             imageWriter.AddFrame(frame);
                         }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             if (options == null) throw new ArgumentNullException("options");
             _options = options;
             _useParallelism = useParallelism;
             _cancellationToken = cancellationToken;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="33" endline="44"><![CDATA[
 
         public event ProgressChangedEventHandler ProgressChanged;
 
         private void UpdateProgressChanged()
         {
             ProgressChangedEventHandler handler = ProgressChanged;
             if (handler != null)
             {
                 double progress = _curFrame * 100.0 / _options.NumberOfOutputFrames;
                 handler(this, new ProgressChangedEventArgs((int)progress, null));
             }
         }
 
         public Bitmap RenderFrame(LinePairCollection lines, Bitmap startImage, Bitmap endImage, double percent)
         {
             using (FastBitmap fastStartImage = new FastBitmap(startImage))
             using (FastBitmap fastEndImage = new FastBitmap(endImage))
             {
                 return RenderFrame(lines, fastStartImage, fastEndImage, percent);
             }
         }
 
         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
         {
             var forwardsAndBackwards = InterpolateLines(lines, percent);
             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
                 return BlendImages(forward, backward, 1 - percent);
         }
 
 		/// <summary>Create the morphed images and video.</summary>
         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
         {
             _curFrame = 0;
             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
 
             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
             {
                 // Write out the starting picture
                 imageWriter.AddFrame(clonedStart);
                 _curFrame = 1;
                 UpdateProgressChanged();
 
                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
                 {
                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
                         {
                             imageWriter.AddFrame(frame);
                         }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             {
                 double progress = _curFrame * 100.0 / _options.NumberOfOutputFrames;
                 handler(this, new ProgressChangedEventArgs((int)progress, null));
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="45" endline="53"><![CDATA[
 
         public Bitmap RenderFrame(LinePairCollection lines, Bitmap startImage, Bitmap endImage, double percent)
         {
             using (FastBitmap fastStartImage = new FastBitmap(startImage))
             using (FastBitmap fastEndImage = new FastBitmap(endImage))
             {
                 return RenderFrame(lines, fastStartImage, fastEndImage, percent);
             }
         }
 
         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
         {
             var forwardsAndBackwards = InterpolateLines(lines, percent);
             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
                 return BlendImages(forward, backward, 1 - percent);
         }
 
 		/// <summary>Create the morphed images and video.</summary>
         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
         {
             _curFrame = 0;
             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
 
             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
             {
                 // Write out the starting picture
                 imageWriter.AddFrame(clonedStart);
                 _curFrame = 1;
                 UpdateProgressChanged();
 
                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
                 {
                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
                         {
                             imageWriter.AddFrame(frame);
                         }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="54" endline="61"><![CDATA[
 
         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
         {
             var forwardsAndBackwards = InterpolateLines(lines, percent);
             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
                 return BlendImages(forward, backward, 1 - percent);
         }
 
 		/// <summary>Create the morphed images and video.</summary>
         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
         {
             _curFrame = 0;
             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
 
             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
             {
                 // Write out the starting picture
                 imageWriter.AddFrame(clonedStart);
                 _curFrame = 1;
                 UpdateProgressChanged();
 
                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
                 {
                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
                         {
                             imageWriter.AddFrame(frame);
                         }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="62" endline="96"><![CDATA[
 
 		/// <summary>Create the morphed images and video.</summary>
         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
         {
             _curFrame = 0;
             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
 
             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
             {
                 // Write out the starting picture
                 imageWriter.AddFrame(clonedStart);
                 _curFrame = 1;
                 UpdateProgressChanged();
 
                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
                 {
                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
                         {
                             imageWriter.AddFrame(frame);
                         }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
                         {
                             imageWriter.AddFrame(frame);
                         }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
                         {
                             imageWriter.AddFrame(frame);
                         }
                         _curFrame++;
                         UpdateProgressChanged();
                     }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 }
 
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 imageWriter.AddFrame(clonedEnd);
                 _curFrame++;
                 UpdateProgressChanged();
             }
         }
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="97" endline="123"><![CDATA[
 
 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
 		/// <param name="pairs">The morph lines to interpolate.</param>
 		/// <param name="percent">The percent of the way through the morph.</param>
 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
 			LinePairCollection pairs, double percent)
 		{
             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             foreach (Tuple<Line,Line> pair in pairs)
 		    {
                 // Source line is the same as the original; dest line is the interpolated line
 				// Add the new pair to the forwards list and the inverse to the backwards list.
                 var newPair = Tuple.Create(
                     new Line(pair.Item1.Item1, pair.Item1.Item2),
                     new Line(
                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
                     ));
                 interpolatedForwards.Add(newPair);
                 interpolatedBackwards.Add(Tuple.Create(
                     new Line(pair.Item2.Item1, pair.Item2.Item2),
                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
 			}
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="124" endline="132"><![CDATA[
 
 		/// <summary>Add two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 + p2</returns>
 		private PointF AddPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="133" endline="141"><![CDATA[
 
 		/// <summary>Subtract two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 - p2</returns>
 		private PointF SubPoints(PointF p1, PointF p2)
 		{
 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="142" endline="150"><![CDATA[
 
 		/// <summary>Scales a point/</summary>
 		/// <param name="p">The point to be scaled.</param>
 		/// <param name="scale">The scaled value.</param>
 		/// <returns>p * scale.</returns>
 		private PointF ScalePoint(PointF p, double scale)
 		{
 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="151" endline="158"><![CDATA[
 
 		/// <summary>Normalizes the point as a vector.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
 		private double NormalizePoint(PointF p)
 		{
 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="159" endline="167"><![CDATA[
 
 		/// <summary>Computes the dot product of two points.</summary>
 		/// <param name="p1">The first point.</param>
 		/// <param name="p2">The second point.</param>
 		/// <returns>p1 . p2</returns>
 		private double DotProduct(PointF p1, PointF p2)
 		{
 			return p1.X*p2.X + p1.Y*p2.Y;
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="168" endline="175"><![CDATA[
 
 		/// <summary>Mirros a point.</summary>
 		/// <param name="p">The point.</param>
 		/// <returns>The point flipped perpendicularlly.</returns>
 		private PointF FlipPerpendicular(PointF p)
 		{
 			return new PointF(p.Y*-1, p.X);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="176" endline="224"><![CDATA[
 
         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
         /// <param name="p">The point whose preimage location we need.</param>
         /// <param name="pairs">The morph line pairs used to translate the point.</param>
         /// <returns>The point in the original image.</returns>
         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
         {
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             if (pairs.Count == 0) return p;
 
             // Grab settings
             double constA = _options.ConstA;
             double constB = _options.ConstB;
             double constP = _options.ConstP;
 
             PointF dSum = PointF.Empty;
             double weightSum = 0;
 
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
             foreach (var pair in pairs)
             {
                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
                 if (srcStart == srcEnd || destStart == destEnd) continue;
 
                 PointF PQ = SubPoints(destEnd, destStart);
                 double length = NormalizePoint(PQ);
                 PointF PpQp = SubPoints(srcEnd, srcStart);
                 PointF PX = SubPoints(p, destStart);
 
                 double u = DotProduct(PX, PQ) / (length * length);
                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
 
                 PointF Xp = AddPoints(
                    AddPoints(srcStart, ScalePoint(PpQp, u)),
                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
 
                 // Compute shortest distance from X to the line segment PQ
                 double dist;
                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
                 else dist = Math.Abs(v);
 
                 double strength = Math.Pow(length, constP) / (constA + dist);
                 double weight = (constB == 2.0) ? strength * strength 
                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
                 weightSum += weight;
             }
 
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="225" endline="273"><![CDATA[
 
 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
 		/// <param name="bmp">The input image.</param>
 		/// <param name="pairs">The lines used to skew the image.</param>
 		/// <returns>The computed image.</returns>
         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
         {
             int width = bmp.Size.Width, height = bmp.Size.Height;
             Bitmap output = new Bitmap(width, height);
 
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             using (FastBitmap fastOut = new FastBitmap(output))
             {
                 if (!_useParallelism)
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 {
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                     }
                     for (int j = 0; j < height; j++)
                     {
                         _cancellationToken.ThrowIfCancellationRequested();
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 }
                 else
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 {
                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
                     {
                         for (int i = 0; i < width; i++)
                         {
                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
                             Point p = ClampPoint(pf, new Size(width, height));
                             PixelData* inPixel = bmp[p.X, p.Y];
                             PixelData* outPixel = fastOut[i, j];
                             outPixel->R = inPixel->R;
                             outPixel->G = inPixel->G;
                             outPixel->B = inPixel->B;
                         }
                     });
                 }
             }
             
             return output;
         }
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             return output;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="274" endline="290"><![CDATA[
 
 		/// <summary>Ensures that a point is within a set boundary.</summary>
 		/// <param name="p">The point to clamp.</param>
 		/// <param name="s">The boundaries.</param>
 		/// <returns>The clamped point.</returns>
 		private Point ClampPoint(PointF p, Size s)
 		{
             int x = (int)p.X, y = (int)p.Y;
 
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
 			if (x < 0) x = 0;
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
 			else if (x >= s.Width) x = s.Width-1;
 
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
 			if (y < 0) y = 0;
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
 			else if (y >= s.Height) y = s.Height-1;
 
             return new Point(x, y);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="291" endline="351"><![CDATA[
 
 		/// <summary>Blends two images.</summary>
 		/// <param name="start">The first image.</param>
 		/// <param name="end">The second image.</param>
 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
 		/// <returns>The blended image.</returns>
         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
         {
             // Validate parameters
             if (start.Width != end.Width ||
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Blend the images
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (!_useParallelism)
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 {
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                     }
                     for (int i = 0; i < width; i++)
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 }
                 else
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
                 {
                     Parallel.For(0, width, i =>
                     {
                         for (int j = 0; j < height; j++)
                         {
                             // Get the pixels for the starting, ending, and output images
                             PixelData* outPixel = fastOut[i, j];
                             PixelData* startPixel = fastStart[i, j];
                             PixelData* endPixel = fastEnd[i, j];
 
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
                         }
                     });
                 }
             }
             return output;
         }
 	}
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="28" endline="28"><![CDATA[
 			get { return _numberOfOutputFrames; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="29" endline="33"><![CDATA[
 			set 
 			{ 
 				if (value < 3) throw new ArgumentOutOfRangeException("NumberOfFrames", value, "There must be at least three output frames.");
 				_numberOfOutputFrames = value; 
 			} 
 		}
 
 		/// <summary>
 		/// If a is barely greater than zero, then if the distance from the line to the pixel is zero, 
 		/// the strength is nearly infinite. With this value for a, the user knows that pixels on the 
 		/// line will go exactly where he wants them. Values larger than that will yield a more smooth 
 		/// warping, but with less precise control.
 		/// </summary>
         [Description(
             "If a is barely greater than zero, then if the distance from the line to the pixel is zero, "+
 		    "the strength is nearly infinite. With this value for a, the user knows that pixels on the "+
 		    "line will go exactly where he wants them. Values larger than that will yield a more smooth "+
 		    "warping, but with less precise control.")]
         [Category("Algorithm")]
         public double ConstA 
 		{ 
 			get { return _constA; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
 				_constA = value; 
 			} 
 		}
 		
 		/// <summary>
 		/// The variable b determines how the relative strength of different lines falls off with distance. 
 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
 		/// most useful.
 		/// </summary>
         [Description(
             "The variable b determines how the relative strength of different lines falls off with distance. "+
 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
 		    "most useful.")]
         [Category("Algorithm")]
         public double ConstB 
 		{ 
 			get { return _constB; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
 				_constB = value; 
 			} 
 		}
 		
 		/// <summary>
 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
 		/// </summary>
         [Description(
             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
         [Category("Algorithm")]
         public double ConstP 
 		{ 
 			get { return _constP; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
 				_constP = value; 
 			} 
 		}
     }
 }
 				if (value < 3) throw new ArgumentOutOfRangeException("NumberOfFrames", value, "There must be at least three output frames.");
 				_numberOfOutputFrames = value; 
 			} 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="34" endline="50"><![CDATA[
 		}
 
 		/// <summary>
 		/// If a is barely greater than zero, then if the distance from the line to the pixel is zero, 
 		/// the strength is nearly infinite. With this value for a, the user knows that pixels on the 
 		/// line will go exactly where he wants them. Values larger than that will yield a more smooth 
 		/// warping, but with less precise control.
 		/// </summary>
         [Description(
             "If a is barely greater than zero, then if the distance from the line to the pixel is zero, "+
 		    "the strength is nearly infinite. With this value for a, the user knows that pixels on the "+
 		    "line will go exactly where he wants them. Values larger than that will yield a more smooth "+
 		    "warping, but with less precise control.")]
         [Category("Algorithm")]
         public double ConstA 
 		{ 
 			get { return _constA; } 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="51" endline="55"><![CDATA[
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
 				_constA = value; 
 			} 
 		}
 		
 		/// <summary>
 		/// The variable b determines how the relative strength of different lines falls off with distance. 
 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
 		/// most useful.
 		/// </summary>
         [Description(
             "The variable b determines how the relative strength of different lines falls off with distance. "+
 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
 		    "most useful.")]
         [Category("Algorithm")]
         public double ConstB 
 		{ 
 			get { return _constB; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
 				_constB = value; 
 			} 
 		}
 		
 		/// <summary>
 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
 		/// </summary>
         [Description(
             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
         [Category("Algorithm")]
         public double ConstP 
 		{ 
 			get { return _constP; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
 				_constP = value; 
 			} 
 		}
     }
 }
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
 				_constA = value; 
 			} 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="56" endline="72"><![CDATA[
 		}
 		
 		/// <summary>
 		/// The variable b determines how the relative strength of different lines falls off with distance. 
 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
 		/// most useful.
 		/// </summary>
         [Description(
             "The variable b determines how the relative strength of different lines falls off with distance. "+
 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
 		    "most useful.")]
         [Category("Algorithm")]
         public double ConstB 
 		{ 
 			get { return _constB; } 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="73" endline="77"><![CDATA[
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
 				_constB = value; 
 			} 
 		}
 		
 		/// <summary>
 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
 		/// </summary>
         [Description(
             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
         [Category("Algorithm")]
         public double ConstP 
 		{ 
 			get { return _constP; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
 				_constP = value; 
 			} 
 		}
     }
 }
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
 				_constB = value; 
 			} 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="78" endline="90"><![CDATA[
 		}
 		
 		/// <summary>
 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
 		/// </summary>
         [Description(
             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
         [Category("Algorithm")]
         public double ConstP 
 		{ 
 			get { return _constP; } 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="91" endline="95"><![CDATA[
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
 				_constP = value; 
 			} 
 		}
     }
 }
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
 				_constP = value; 
 			} 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs" startline="18" endline="98"><![CDATA[
 		private int _numberOfOutputFrames = 48;
         private double _constA = 2.0;
 		private double _constB = 2.0;
 		private double _constP = .25;
 
 		/// <summary>Gets or sets the number of output frames to generate.</summary>
         [Description("The number of output frames to generate.")]
         [Category("Algorithm")]
 		public int NumberOfOutputFrames 
 		{ 
 			get { return _numberOfOutputFrames; }
 			set 
 			{ 
 				if (value < 3) throw new ArgumentOutOfRangeException("NumberOfFrames", value, "There must be at least three output frames.");
 				_numberOfOutputFrames = value; 
 			} 
 		}
 
 		/// <summary>
 		/// If a is barely greater than zero, then if the distance from the line to the pixel is zero, 
 		/// the strength is nearly infinite. With this value for a, the user knows that pixels on the 
 		/// line will go exactly where he wants them. Values larger than that will yield a more smooth 
 		/// warping, but with less precise control.
 		/// </summary>
         [Description(
             "If a is barely greater than zero, then if the distance from the line to the pixel is zero, "+
 		    "the strength is nearly infinite. With this value for a, the user knows that pixels on the "+
 		    "line will go exactly where he wants them. Values larger than that will yield a more smooth "+
 		    "warping, but with less precise control.")]
         [Category("Algorithm")]
         public double ConstA 
 		{ 
 			get { return _constA; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
 				_constA = value; 
 			} 
 		}
 		
 		/// <summary>
 		/// The variable b determines how the relative strength of different lines falls off with distance. 
 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
 		/// most useful.
 		/// </summary>
         [Description(
             "The variable b determines how the relative strength of different lines falls off with distance. "+
 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
 		    "most useful.")]
         [Category("Algorithm")]
         public double ConstB 
 		{ 
 			get { return _constB; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
 				_constB = value; 
 			} 
 		}
 		
 		/// <summary>
 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
 		/// </summary>
         [Description(
             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
         [Category("Algorithm")]
         public double ConstP 
 		{ 
 			get { return _constP; } 
 			set 
 			{ 
 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
 				_constP = value; 
 			} 
 		}
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\UiSettings.cs" startline="50" endline="50"><![CDATA[
 			get { return _framesPerSecond; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\UiSettings.cs" startline="51" endline="55"><![CDATA[
 			set
 			{
 				if (value < 1) throw new ArgumentOutOfRangeException("FramesPerSecond", value, "Must be at least one frame per second.");
 				_framesPerSecond = value;
 			}
 		}
 
 		/// <summary>Gets or sets the FOURCC compression code for the output AVI.</summary>
         [Description("The FOURCC compression code to use for an output AVI movie.")]
         [Category("Movie")]
         public string FourCC
 		{
 			get { return _fourcc; }
 			set 
 			{
 				if (string.IsNullOrEmpty(value) || value.Length != 4)
 				{
 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
 				}
 				_fourcc = value; 
 			}
 		}
     }
 }
 				if (value < 1) throw new ArgumentOutOfRangeException("FramesPerSecond", value, "Must be at least one frame per second.");
 				_framesPerSecond = value;
 			}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\UiSettings.cs" startline="56" endline="63"><![CDATA[
 		}
 
 		/// <summary>Gets or sets the FOURCC compression code for the output AVI.</summary>
         [Description("The FOURCC compression code to use for an output AVI movie.")]
         [Category("Movie")]
         public string FourCC
 		{
 			get { return _fourcc; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\UiSettings.cs" startline="64" endline="71"><![CDATA[
 			set 
 			{
 				if (string.IsNullOrEmpty(value) || value.Length != 4)
 				{
 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
 				}
 				_fourcc = value; 
 			}
 		}
     }
 }
 				{
 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
 				}
 				_fourcc = value; 
 			}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\UiSettings.cs" startline="42" endline="74"><![CDATA[
         private int _framesPerSecond = 24;
         private string _fourcc = String.Empty;
 
 		/// <summary>Gets or sets the number of frames per second for the output AVI.</summary>
         [Description("The number of frames per second for an output AVI movie.")]
         [Category("Movie")]
 		public int FramesPerSecond
 		{
 			get { return _framesPerSecond; }
 			set
 			{
 				if (value < 1) throw new ArgumentOutOfRangeException("FramesPerSecond", value, "Must be at least one frame per second.");
 				_framesPerSecond = value;
 			}
 		}
 
 		/// <summary>Gets or sets the FOURCC compression code for the output AVI.</summary>
         [Description("The FOURCC compression code to use for an output AVI movie.")]
         [Category("Movie")]
         public string FourCC
 		{
 			get { return _fourcc; }
 			set 
 			{
 				if (string.IsNullOrEmpty(value) || value.Length != 4)
 				{
 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
 				}
 				_fourcc = value; 
 			}
 		}
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Resources.Designer.cs" startline="31" endline="33"><![CDATA[
         [global
         internal Resources() {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Resources.Designer.cs" startline="34" endline="46"><![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
             set {
                 resourceCulture = value;
             }
         }
     }
 }
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Resources.Designer.cs" startline="47" endline="57"><![CDATA[
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Resources.Designer.cs" startline="58" endline="60"><![CDATA[
             set {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\EditSettings.cs" startline="20" endline="25"><![CDATA[
 		private System.ComponentModel.Container components = null;
 
 		public EditSettings()
 		{
 			InitializeComponent();
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\EditSettings.cs" startline="26" endline="40"><![CDATA[
 
 		/// <summary>
 		/// Clean up any resources being used.
 		/// </summary>
 		protected override void Dispose( bool disposing )
 		{
 			if( disposing )
 			{
 				if(components != null)
 				{
 					components.Dispose();
 				}
 			}
 			base.Dispose( disposing );
 		}
 
 		#region Windows Form Designer generated code
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
             this.pgSettings = new System.Windows.Forms.PropertyGrid();
             this.SuspendLayout();
             // 
             // pgSettings
             // 
             this.pgSettings.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pgSettings.LineColor = System.Drawing.SystemColors.ScrollBar;
             this.pgSettings.Location = new System.Drawing.Point(0, 0);
             this.pgSettings.Name = "pgSettings";
             this.pgSettings.Size = new System.Drawing.Size(300, 237);
             this.pgSettings.TabIndex = 0;
             this.pgSettings.ToolbarVisible = false;
             // 
             // EditSettings
             // 
             this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
             this.ClientSize = new System.Drawing.Size(300, 237);
             this.Controls.Add(this.pgSettings);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow;
             this.Name = "EditSettings";
             this.Opacity = 0.97D;
             this.ShowInTaskbar = false;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
             this.Text = "Edit Settings";
             this.ResumeLayout(false);
 
 		}
 		#endregion
 
 		// ==========================================================================================
 		// ==========================================================================================
 		// ==========================================================================================
 
 		/// <summary>Gets or sets the settings being edited.</summary>
 		public UiSettings Settings
 		{
 			get { return (UiSettings)pgSettings.SelectedObject; }
 			set { pgSettings.SelectedObject = value; }
 		}
 	}
 }
 			{
 				if(components != null)
 				{
 					components.Dispose();
 				}
 			}
 			base.Dispose( disposing );
 		}
 
 		#region Windows Form Designer generated code
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
             this.pgSettings = new System.Windows.Forms.PropertyGrid();
             this.SuspendLayout();
             // 
             // pgSettings
             // 
             this.pgSettings.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pgSettings.LineColor = System.Drawing.SystemColors.ScrollBar;
             this.pgSettings.Location = new System.Drawing.Point(0, 0);
             this.pgSettings.Name = "pgSettings";
             this.pgSettings.Size = new System.Drawing.Size(300, 237);
             this.pgSettings.TabIndex = 0;
             this.pgSettings.ToolbarVisible = false;
             // 
             // EditSettings
             // 
             this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
             this.ClientSize = new System.Drawing.Size(300, 237);
             this.Controls.Add(this.pgSettings);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow;
             this.Name = "EditSettings";
             this.Opacity = 0.97D;
             this.ShowInTaskbar = false;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
             this.Text = "Edit Settings";
             this.ResumeLayout(false);
 
 		}
 		#endregion
 
 		// ==========================================================================================
 		// ==========================================================================================
 		// ==========================================================================================
 
 		/// <summary>Gets or sets the settings being edited.</summary>
 		public UiSettings Settings
 		{
 			get { return (UiSettings)pgSettings.SelectedObject; }
 			set { pgSettings.SelectedObject = value; }
 		}
 	}
 }
 				{
 					components.Dispose();
 				}
 			}
 			base.Dispose( disposing );
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\EditSettings.cs" startline="41" endline="75"><![CDATA[
 
 		#region Windows Form Designer generated code
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
             this.pgSettings = new System.Windows.Forms.PropertyGrid();
             this.SuspendLayout();
             // 
             // pgSettings
             // 
             this.pgSettings.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pgSettings.LineColor = System.Drawing.SystemColors.ScrollBar;
             this.pgSettings.Location = new System.Drawing.Point(0, 0);
             this.pgSettings.Name = "pgSettings";
             this.pgSettings.Size = new System.Drawing.Size(300, 237);
             this.pgSettings.TabIndex = 0;
             this.pgSettings.ToolbarVisible = false;
             // 
             // EditSettings
             // 
             this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
             this.ClientSize = new System.Drawing.Size(300, 237);
             this.Controls.Add(this.pgSettings);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow;
             this.Name = "EditSettings";
             this.Opacity = 0.97D;
             this.ShowInTaskbar = false;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
             this.Text = "Edit Settings";
             this.ResumeLayout(false);
 
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\EditSettings.cs" startline="76" endline="85"><![CDATA[
 		#endregion
 
 		// ==========================================================================================
 		// ==========================================================================================
 		// ==========================================================================================
 
 		/// <summary>Gets or sets the settings being edited.</summary>
 		public UiSettings Settings
 		{
 			get { return (UiSettings)pgSettings.SelectedObject; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\EditSettings.cs" startline="86" endline="86"><![CDATA[
 			set { pgSettings.SelectedObject = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\AviImageWriter.cs" startline="42" endline="109"><![CDATA[
 		public AviImageWriter(string path, int frameRate, int width, int height)
 		{
 			// Validate parameters
 			if (path == null) throw new ArgumentNullException("path");
 			if (frameRate <= 0) throw new ArgumentOutOfRangeException("frameRate", frameRate, "The frame rate must be at least 1 frame per second.");
 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
 
 			// Store parameters
 			uint fccType = GetFourCc("vids");
 			_width = width;
 			_height = height;
 
 			_disposed = false;
 
 			// Get the stride information by creating a new bitmap and querying it
 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
 			{
 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				_stride = (uint)bmpData.Stride;
 				bmp.UnlockBits(bmpData);
 			}
 
 			try
 			{
 				// Initialize the AVI library
 				AVIFileInit();
 
 				// Open the output AVI file
 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Create a new stream in the avi file
 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
 				aviStreamInfo.fccType = fccType;
 				aviStreamInfo.fccHandler = 0;
 				aviStreamInfo.dwScale = 1;
 				aviStreamInfo.dwRate = (uint)frameRate;
 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
 				aviStreamInfo.dwQuality = 0xffffffff;
 				aviStreamInfo.rcFrame = new RECT();
 				aviStreamInfo.rcFrame.bottom = _height;
 				aviStreamInfo.rcFrame.right = _width;
 
 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (path == null) throw new ArgumentNullException("path");
 			if (frameRate <= 0) throw new ArgumentOutOfRangeException("frameRate", frameRate, "The frame rate must be at least 1 frame per second.");
 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
 
 			// Store parameters
 			uint fccType = GetFourCc("vids");
 			_width = width;
 			_height = height;
 
 			_disposed = false;
 
 			// Get the stride information by creating a new bitmap and querying it
 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
 			{
 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				_stride = (uint)bmpData.Stride;
 				bmp.UnlockBits(bmpData);
 			}
 
 			try
 			{
 				// Initialize the AVI library
 				AVIFileInit();
 
 				// Open the output AVI file
 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Create a new stream in the avi file
 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
 				aviStreamInfo.fccType = fccType;
 				aviStreamInfo.fccHandler = 0;
 				aviStreamInfo.dwScale = 1;
 				aviStreamInfo.dwRate = (uint)frameRate;
 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
 				aviStreamInfo.dwQuality = 0xffffffff;
 				aviStreamInfo.rcFrame = new RECT();
 				aviStreamInfo.rcFrame.bottom = _height;
 				aviStreamInfo.rcFrame.right = _width;
 
 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (frameRate <= 0) throw new ArgumentOutOfRangeException("frameRate", frameRate, "The frame rate must be at least 1 frame per second.");
 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
 
 			// Store parameters
 			uint fccType = GetFourCc("vids");
 			_width = width;
 			_height = height;
 
 			_disposed = false;
 
 			// Get the stride information by creating a new bitmap and querying it
 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
 			{
 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				_stride = (uint)bmpData.Stride;
 				bmp.UnlockBits(bmpData);
 			}
 
 			try
 			{
 				// Initialize the AVI library
 				AVIFileInit();
 
 				// Open the output AVI file
 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Create a new stream in the avi file
 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
 				aviStreamInfo.fccType = fccType;
 				aviStreamInfo.fccHandler = 0;
 				aviStreamInfo.dwScale = 1;
 				aviStreamInfo.dwRate = (uint)frameRate;
 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
 				aviStreamInfo.dwQuality = 0xffffffff;
 				aviStreamInfo.rcFrame = new RECT();
 				aviStreamInfo.rcFrame.bottom = _height;
 				aviStreamInfo.rcFrame.right = _width;
 
 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
 
 			// Store parameters
 			uint fccType = GetFourCc("vids");
 			_width = width;
 			_height = height;
 
 			_disposed = false;
 
 			// Get the stride information by creating a new bitmap and querying it
 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
 			{
 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				_stride = (uint)bmpData.Stride;
 				bmp.UnlockBits(bmpData);
 			}
 
 			try
 			{
 				// Initialize the AVI library
 				AVIFileInit();
 
 				// Open the output AVI file
 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Create a new stream in the avi file
 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
 				aviStreamInfo.fccType = fccType;
 				aviStreamInfo.fccHandler = 0;
 				aviStreamInfo.dwScale = 1;
 				aviStreamInfo.dwRate = (uint)frameRate;
 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
 				aviStreamInfo.dwQuality = 0xffffffff;
 				aviStreamInfo.rcFrame = new RECT();
 				aviStreamInfo.rcFrame.bottom = _height;
 				aviStreamInfo.rcFrame.right = _width;
 
 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
 
 			// Store parameters
 			uint fccType = GetFourCc("vids");
 			_width = width;
 			_height = height;
 
 			_disposed = false;
 
 			// Get the stride information by creating a new bitmap and querying it
 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
 			{
 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				_stride = (uint)bmpData.Stride;
 				bmp.UnlockBits(bmpData);
 			}
 
 			try
 			{
 				// Initialize the AVI library
 				AVIFileInit();
 
 				// Open the output AVI file
 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Create a new stream in the avi file
 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
 				aviStreamInfo.fccType = fccType;
 				aviStreamInfo.fccHandler = 0;
 				aviStreamInfo.dwScale = 1;
 				aviStreamInfo.dwRate = (uint)frameRate;
 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
 				aviStreamInfo.dwQuality = 0xffffffff;
 				aviStreamInfo.rcFrame = new RECT();
 				aviStreamInfo.rcFrame.bottom = _height;
 				aviStreamInfo.rcFrame.right = _width;
 
 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			{
 				// Initialize the AVI library
 				AVIFileInit();
 
 				// Open the output AVI file
 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Create a new stream in the avi file
 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
 				aviStreamInfo.fccType = fccType;
 				aviStreamInfo.fccHandler = 0;
 				aviStreamInfo.dwScale = 1;
 				aviStreamInfo.dwRate = (uint)frameRate;
 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
 				aviStreamInfo.dwQuality = 0xffffffff;
 				aviStreamInfo.rcFrame = new RECT();
 				aviStreamInfo.rcFrame.bottom = _height;
 				aviStreamInfo.rcFrame.right = _width;
 
 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Create a new stream in the avi file
 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
 				aviStreamInfo.fccType = fccType;
 				aviStreamInfo.fccHandler = 0;
 				aviStreamInfo.dwScale = 1;
 				aviStreamInfo.dwRate = (uint)frameRate;
 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
 				aviStreamInfo.dwQuality = 0xffffffff;
 				aviStreamInfo.rcFrame = new RECT();
 				aviStreamInfo.rcFrame.bottom = _height;
 				aviStreamInfo.rcFrame.right = _width;
 
 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
 
 				// Configure the compressed stream
 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
 				streamFormat.biSize      = 40;
 				streamFormat.biWidth     = _width;
 				streamFormat.biHeight    = _height;
 				streamFormat.biPlanes    = 1;
 				streamFormat.biBitCount  = 24;
 				streamFormat.biSizeImage = (uint)(_stride * _height);
 
                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
 			}
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			catch
 			{
 				// Clean up
 				Dispose(false);
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				try { if (path != null && File.Exists(path)) File.Delete(path); }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				catch{}
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				throw;
 			}
 		}
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\AviImageWriter.cs" startline="110" endline="116"><![CDATA[
 
 		private uint GetFourCc(string fcc)
 		{
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
             if (fcc == null) throw new ArgumentNullException("fcc");
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\AviImageWriter.cs" startline="117" endline="122"><![CDATA[
 
 		/// <summary>Clean up the AviFile.</summary>
 		~AviImageWriter()
 		{
 			Dispose(false);
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\AviImageWriter.cs" startline="123" endline="144"><![CDATA[
 
 		/// <summary>Clean up the AviFile.</summary>
 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
 		protected void Dispose(bool disposing)
 		{
 			if (!_disposed)
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			{
 				_disposed = true;
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
                 if (disposing) GC.SuppressFinalize(this);
 				if (_aviStream != IntPtr.Zero)
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				{
 					AVIStreamRelease(_aviStream);
 					_aviStream = IntPtr.Zero;
 				}
 				if (_aviFile != IntPtr.Zero) 
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				{
 					AVIFileRelease(_aviFile);
                     _aviFile = IntPtr.Zero;
 				}
 				AVIFileExit();
 			}
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\AviImageWriter.cs" startline="145" endline="147"><![CDATA[
 
 		/// <summary>Clean up the AviFile.</summary>
 		public void Dispose() { Dispose(true); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\AviImageWriter.cs" startline="148" endline="173"><![CDATA[
 
 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
 		/// <param name="frame">The frame to be added.</param>
 		public void AddFrame(Bitmap frame)
 		{
 			// Validate the bitmap
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (frame == null) throw new ArgumentNullException("frame");
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
 
 			// Write the frame to the file
 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
 			BitmapData frameData = null;
 			try
 			{
 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
 			} 
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			catch
 			{
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 				throw;
 			}
 			_frameCount++;
 		}
 
 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
 		[StructLayout(LayoutKind.Sequential)]
 		private struct RECT
 		{
 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
 			public int left;
 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
 			public int top;
 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
 			public int right;
 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
 			public int bottom;
 		}
 
 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVISTREAMINFOW 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public UInt32 fccType;
 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
 			public UInt32 fccHandler;
 			/// <summary>Applicable flags for the stream.</summary>
 			public UInt32 dwFlags;
 			/// <summary>Capability flags; currently unused.</summary>
 			public UInt32 dwCaps;
 			/// <summary>Priority of the stream.</summary>
 			public UInt16 wPriority;
 			/// <summary>Language of the stream.</summary>
 			public UInt16 wLanguage;
 			/// <summary>Time scale applicable for the stream.</summary>
 			public UInt32 dwScale;
 			/// <summary>Rate in an integer format.</summary>
 			public UInt32 dwRate;
 			/// <summary>Sample number of the first frame of the AVI file.</summary>
 			public UInt32 dwStart;
 			/// <summary>Length of this stream.</summary>
 			public UInt32 dwLength;
 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
 			public UInt32 dwInitialFrames;
 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
 			public UInt32 dwSuggestedBufferSize;
 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
 			public UInt32 dwQuality;
 			/// <summary>Size, in bytes, of a single data sample.</summary>
 			public UInt32 dwSampleSize;
 			/// <summary>Dimensions of the video destination rectangle.</summary>
 			public RECT rcFrame;
 			/// <summary>Number of times the stream has been edited.</summary>
 			public UInt32 dwEditCount;
 			/// <summary>Number of times the stream format has changed.</summary>
 			public UInt32 dwFormatChangeCount;
             /// <summary>Null-terminated string containing a description of the stream.</summary>
             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
             public String szName;
 		}
 
 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct AVICOMPRESSOPTIONS 
 		{
 			/// <summary>Four-character code indicating the stream type.</summary>
 			public uint fccType;
 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
 			public uint fccHandler;
 			/// <summary>Maximum period between video key frames.</summary>
 			public uint dwKeyFrameEvery;
 			/// <summary>Quality value passed to a video compressor.</summary>
 			public uint dwQuality;
 			/// <summary>Video compressor data rate.</summary>
 			public uint dwBytesPerSecond;
 			/// <summary>Flags used for compression.</summary>
 			public uint dwFlags;
 			/// <summary>Pointer to a structure defining the data format.</summary>
 			public IntPtr lpFormat;
 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
 			public uint cbFormat;
 			/// <summary>Video-compressor-specific data; used internally.</summary>
 			public IntPtr lpParms;
 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
 			public uint cbParms;
 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
 			public uint dwInterleaveEvery;
 		}
 
 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
 		[StructLayout(LayoutKind.Sequential, Pack=1)]
 		private struct BITMAPINFOHEADER 
 		{
 			/// <summary>Specifies the number of bytes required by the structure.</summary>
 			public uint biSize;
 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
 			public int biWidth;
 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
 			public int biHeight;
 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
 			public short biPlanes;
 			/// <summary>Specifies the number of bits-per-pixel.</summary>
 			public short biBitCount;
 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
 			public uint biCompression;
 			/// <summary>Specifies the size, in bytes, of the image.</summary>
 			public uint biSizeImage;
 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biXPelsPerMeter;
 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
 			public int biYPelsPerMeter;
 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
 			public uint biClrUsed;
 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
 			public uint biClrImportant;
 		}
 
 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
 
 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileInit();
 
 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
 		/// <param name="uMode">Access mode to use when opening the file.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
 
 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <param name="ppavi">Pointer to the new stream interface.</param>
 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
 
 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
 		/// <returns></returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
 
 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lPos">Position in the stream to receive the format.</param>
 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
 
 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <param name="lStart">First sample to write.</param>
 		/// <param name="lSamples">Number of samples to write.</param>
 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
 		/// <param name="dwFlags">Flag associated with this data.</param>
 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
 		/// <returns>Returns zero if successful or an error otherwise.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
 
 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
 		/// <param name="pavi">Handle to an open stream.</param>
 		/// <returns>Returns the current reference count of the stream.</returns>
 		[DllImport("avifil32.dll")]
 		private static extern int AVIStreamRelease(IntPtr pavi);
 
 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
 		/// <param name="pfile">Handle to an open AVI file.</param>
 		/// <returns>Returns the reference count of the file.</returns>
 		[DllImport("avifil32.dll")]
         private static extern int AVIFileRelease(IntPtr pfile);
 
 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
 		[DllImport("avifil32.dll")]
 		private static extern void AVIFileExit();
 
         /// <summary>AVI error codes</summary>
         private enum AviErrors 
         {
             Unsupported = 0x80044065,
             BadFormat = 0x80044066,
             Memory = 0x80044067,
             Internal = 0x80044068,
             BadFlags = 0x80044069,
             BadParam = 0x8004406A,
             BadSize = 0x8004406B,
             BadHandle = 0x8004406C,
             FileRead = 0x8004406D,
             FileWrite = 0x8004406E,
             FileOpen = 0x8004406F,
             Compressor = 0x80044070,
             NoCompressor = 0x80044071,
             ReadOnly = 0x80044072,
             NoData = 0x80044073,
             BufferTooSmall = 0x80044074,
             CanNotCompress = 0x80044075,
             UserAbort = 0x800440C6,
             Error = 0x800440C7
         }
 	}
 }
 			_frameCount++;
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Utilities.cs" startline="25" endline="33"><![CDATA[
         {
             using (MemoryStream ms = new MemoryStream())
             {
                 var formatter = new BinaryFormatter();
                 formatter.Serialize(ms, source);
                 ms.Position = 0;
                 return (T)formatter.Deserialize(ms);
             }
         }
 
         /// <summary>Clones an image into a new Bitmap.</summary>
         /// <param name="source">The source image.</param>
         /// <returns>The new Bitmap.</returns>
         public static Bitmap CreateNewBitmapFrom(Image source) 
         { 
             return CreateNewBitmapFrom(source, 1); 
         }
 
         /// <summary>Creates a copy of the source image by scaling it with the specified scale value.</summary>
         /// <param name="source">The source image.</param>
         /// <param name="scalingFactor">The scaling factor to use when generating the target image.</param>
         /// <returns>The new Bitmap.</returns>
         public static Bitmap CreateNewBitmapFrom(Image source, float scalingFactor)
         {
             return CreateNewBitmapFrom(source, (int)(source.Width*scalingFactor), (int)(source.Height*scalingFactor));
         }
 
         /// <summary>Creates a copy of the source image using the specified target width and height.</summary>
         /// <param name="source">The source image.</param>
         /// <param name="targetWidth">The target width for the generated image.</param>
         /// <param name="targetHeight">The target height for the generated image.</param>
         /// <returns>The new Bitmap.</returns>
         public static Bitmap CreateNewBitmapFrom(Image source, int targetWidth, int targetHeight)
         {
             var newBmp = new Bitmap(targetWidth, targetHeight, PixelFormat.Format32bppArgb);
             using (var g = Graphics.FromImage(newBmp)) g.DrawImage(source, 0, 0, newBmp.Width, newBmp.Height);
             return newBmp;
         }
 
         /// <summary>Retrieves an element from a Tuple by item number.</summary>
         /// <typeparam name="T">Specifies the type of data contained in the tuple.</typeparam>
         /// <param name="tuple">The tuple.</param>
         /// <param name="itemNumber">The item number.</param>
         /// <returns>Item1 if itemNumber is 0, otherwise Item2 if itemNumber is 1.</returns>
         public static T Item<T>(this Tuple<T, T> tuple, int itemNumber)
         {
             switch (itemNumber)
             {
                 case 0
                 case 1
                 default
             }
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Utilities.cs" startline="34" endline="41"><![CDATA[
 
         /// <summary>Clones an image into a new Bitmap.</summary>
         /// <param name="source">The source image.</param>
         /// <returns>The new Bitmap.</returns>
         public static Bitmap CreateNewBitmapFrom(Image source) 
         { 
             return CreateNewBitmapFrom(source, 1); 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Utilities.cs" startline="42" endline="50"><![CDATA[
 
         /// <summary>Creates a copy of the source image by scaling it with the specified scale value.</summary>
         /// <param name="source">The source image.</param>
         /// <param name="scalingFactor">The scaling factor to use when generating the target image.</param>
         /// <returns>The new Bitmap.</returns>
         public static Bitmap CreateNewBitmapFrom(Image source, float scalingFactor)
         {
             return CreateNewBitmapFrom(source, (int)(source.Width*scalingFactor), (int)(source.Height*scalingFactor));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Utilities.cs" startline="51" endline="62"><![CDATA[
 
         /// <summary>Creates a copy of the source image using the specified target width and height.</summary>
         /// <param name="source">The source image.</param>
         /// <param name="targetWidth">The target width for the generated image.</param>
         /// <param name="targetHeight">The target height for the generated image.</param>
         /// <returns>The new Bitmap.</returns>
         public static Bitmap CreateNewBitmapFrom(Image source, int targetWidth, int targetHeight)
         {
             var newBmp = new Bitmap(targetWidth, targetHeight, PixelFormat.Format32bppArgb);
             using (var g = Graphics.FromImage(newBmp)) g.DrawImage(source, 0, 0, newBmp.Width, newBmp.Height);
             return newBmp;
         }
 
         /// <summary>Retrieves an element from a Tuple by item number.</summary>
         /// <typeparam name="T">Specifies the type of data contained in the tuple.</typeparam>
         /// <param name="tuple">The tuple.</param>
         /// <param name="itemNumber">The item number.</param>
         /// <returns>Item1 if itemNumber is 0, otherwise Item2 if itemNumber is 1.</returns>
         public static T Item<T>(this Tuple<T, T> tuple, int itemNumber)
         {
             switch (itemNumber)
             {
                 case 0
                 case 1
                 default
             }
         }
     }
 }
             return newBmp;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Utilities.cs" startline="63" endline="77"><![CDATA[
 
         /// <summary>Retrieves an element from a Tuple by item number.</summary>
         /// <typeparam name="T">Specifies the type of data contained in the tuple.</typeparam>
         /// <param name="tuple">The tuple.</param>
         /// <param name="itemNumber">The item number.</param>
         /// <returns>Item1 if itemNumber is 0, otherwise Item2 if itemNumber is 1.</returns>
         public static T Item<T>(this Tuple<T, T> tuple, int itemNumber)
         {
             switch (itemNumber)
             {
                 case 0
                 case 1
                 default
             }
         }
     }
 }
                 case 0
                 case 1
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="21" endline="21"><![CDATA[
         public LinePairCollection() {}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="22" endline="22"><![CDATA[
         public LinePairCollection(IList<Tuple<Line, Line>> source) 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="23" endline="28"><![CDATA[
 
         protected override void InsertItem(int index, Tuple<Line, Line> item)
         {
             base.InsertItem(index, item);
             _selected = item;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="29" endline="35"><![CDATA[
 
         protected override void RemoveItem(int index)
         {
             base.RemoveItem(index);
             if (Count > 0) _selected = this[0];
             else _selected = null;
         }
 
         public Tuple<Line, Line> Selected { get { return _selected; } set { _selected = value; } }
 
 		public void SelectFirst()
 		{
 			if (Count > 0) _selected = this[0];
 		}
 
 		public void SelectLast()
 		{
             if (Count > 0) _selected = this[Count - 1];
 		}
 
 		public void SelectNext()
 		{
 			MoveToNextLine(1);
 		}
 
 		public void SelectPrev()
 		{
 			MoveToNextLine(-1);
 		}
 
 		private void MoveToNextLine(int skip)
 		{
 			if (Count > 0) 
 			{
 				if (_selected == null) SelectFirst();
 				else
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
             if (Count > 0) _selected = this[0];
             else _selected = null;
         }
 
         public Tuple<Line, Line> Selected { get { return _selected; } set { _selected = value; } }
 
 		public void SelectFirst()
 		{
 			if (Count > 0) _selected = this[0];
 		}
 
 		public void SelectLast()
 		{
             if (Count > 0) _selected = this[Count - 1];
 		}
 
 		public void SelectNext()
 		{
 			MoveToNextLine(1);
 		}
 
 		public void SelectPrev()
 		{
 			MoveToNextLine(-1);
 		}
 
 		private void MoveToNextLine(int skip)
 		{
 			if (Count > 0) 
 			{
 				if (_selected == null) SelectFirst();
 				else
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
             else _selected = null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="36" endline="37"><![CDATA[
 
         public Tuple<Line, Line> Selected { get { return _selected; } set { _selected = value; } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="38" endline="42"><![CDATA[
 
 		public void SelectFirst()
 		{
 			if (Count > 0) _selected = this[0];
 		}
 
 		public void SelectLast()
 		{
             if (Count > 0) _selected = this[Count - 1];
 		}
 
 		public void SelectNext()
 		{
 			MoveToNextLine(1);
 		}
 
 		public void SelectPrev()
 		{
 			MoveToNextLine(-1);
 		}
 
 		private void MoveToNextLine(int skip)
 		{
 			if (Count > 0) 
 			{
 				if (_selected == null) SelectFirst();
 				else
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
 			if (Count > 0) _selected = this[0];
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="43" endline="47"><![CDATA[
 
 		public void SelectLast()
 		{
             if (Count > 0) _selected = this[Count - 1];
 		}
 
 		public void SelectNext()
 		{
 			MoveToNextLine(1);
 		}
 
 		public void SelectPrev()
 		{
 			MoveToNextLine(-1);
 		}
 
 		private void MoveToNextLine(int skip)
 		{
 			if (Count > 0) 
 			{
 				if (_selected == null) SelectFirst();
 				else
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
             if (Count > 0) _selected = this[Count - 1];
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="48" endline="52"><![CDATA[
 
 		public void SelectNext()
 		{
 			MoveToNextLine(1);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="53" endline="57"><![CDATA[
 
 		public void SelectPrev()
 		{
 			MoveToNextLine(-1);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs" startline="58" endline="77"><![CDATA[
 
 		private void MoveToNextLine(int skip)
 		{
 			if (Count > 0) 
 			{
 				if (_selected == null) SelectFirst();
 				else
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
 			{
 				if (_selected == null) SelectFirst();
 				else
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
 				if (_selected == null) SelectFirst();
 				else
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
 				{
 					int index = IndexOf(_selected);
 					if (index >= 0) 
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
 					{
 						index = index + skip;
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
                         while(index < 0) index += Count;
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
                         index %= Count;
 						_selected = this[index];
 					}
 					else SelectFirst();
 				}
 			}
 		}
     }
 }
 					else SelectFirst();
 				}
 			}
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="23" endline="23"><![CDATA[
         public Pair(T item1, T item2) { this.Item1 = item1; this.Item2 = item2; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="24" endline="39"><![CDATA[
 
         public T Item1 { get; set; }
 
         public T Item2 { get; set; }
 
         public T this[int itemNumber]
         {
             get
             {
                 switch (itemNumber)
                 {
                     case 0
                     case 1
                     default
                 }
             }
             set
             {
                 switch (itemNumber)
                 {
                     case 0
                     case 1
                     default
                 }
             }
         }
     }
 }
                     case 0
                     case 1
                     default
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="40" endline="48"><![CDATA[
             set
             {
                 switch (itemNumber)
                 {
                     case 0
                     case 1
                     default
                 }
             }
         }
     }
 }
                     case 0
                     case 1
                     default
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs" startline="17" endline="17"><![CDATA[
         public Line(PointF first, PointF second) 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="26" endline="39"><![CDATA[
         private BitmapData _bitmapData = null;
         private byte* _pBase = null;
         private PixelData* _pInitPixel = null;
         private bool _locked = false;
 
         public FastBitmap(Bitmap bmp)
         {
             if (bmp == null) throw new ArgumentNullException("bitmap");
 
             _bitmap = bmp;
             this.Size = new Size(bmp.Width, bmp.Height);
 
             LockBitmap();
         }
 
         public Size Size { get; private set; }
 
         public PixelData* GetInitialPixelForRow(int rowNumber)
         {
             return (PixelData*)(_pBase + rowNumber * _bytesInARow);
         }
 
         public PixelData* this[int x, int y]
         {
             get { return (PixelData*)(_pBase + y * _bytesInARow + x * sizeof(PixelData)); }
         }
 
         public Color GetColor(int x, int y)
         {
             PixelData* data = this[x, y];
             return Color.FromArgb(data->R, data->G, data->B);
         }
 
         public void SetColor(int x, int y, Color c)
         {
             PixelData* data = this[x, y];
             data->R = c.R;
             data->G = c.G;
             data->B = c.B;
         }
 
         private void LockBitmap()
         {
             if (_locked) throw new InvalidOperationException("Already locked");
 
             Rectangle bounds = new Rectangle(0, 0, _bitmap.Width, _bitmap.Height);
 
             // Figure out the number of bytes in a row. This is rounded up to be a multiple 
             // of 4 bytes, since a scan line in an image must always be a multiple of 4 bytes
             // in length. 
             _bytesInARow = bounds.Width * sizeof(PixelData);
             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
 
             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
 
             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
             _locked = true;
         }
 
         private void InitCurrentPixel()
         {
             _pInitPixel = (PixelData*)_pBase;
         }
 
         private void UnlockBitmap()
         {
             if (!_locked) throw new InvalidOperationException("Not currently locked");
 
             _bitmap.UnlockBits(_bitmapData);
             _bitmapData = null;
             _pBase = null;
             _locked = false;
         }
 
         public void Dispose()
         {
             if (_locked) UnlockBitmap();
         }
     }
 }
             if (bmp == null) throw new ArgumentNullException("bitmap");
 
             _bitmap = bmp;
             this.Size = new Size(bmp.Width, bmp.Height);
 
             LockBitmap();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="40" endline="46"><![CDATA[
 
         public Size Size { get; private set; }
 
         public PixelData* GetInitialPixelForRow(int rowNumber)
         {
             return (PixelData*)(_pBase + rowNumber * _bytesInARow);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="47" endline="50"><![CDATA[
 
         public PixelData* this[int x, int y]
         {
             get { return (PixelData*)(_pBase + y * _bytesInARow + x * sizeof(PixelData)); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="51" endline="57"><![CDATA[
         }
 
         public Color GetColor(int x, int y)
         {
             PixelData* data = this[x, y];
             return Color.FromArgb(data->R, data->G, data->B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="58" endline="65"><![CDATA[
 
         public void SetColor(int x, int y, Color c)
         {
             PixelData* data = this[x, y];
             data->R = c.R;
             data->G = c.G;
             data->B = c.B;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="66" endline="83"><![CDATA[
 
         private void LockBitmap()
         {
             if (_locked) throw new InvalidOperationException("Already locked");
 
             Rectangle bounds = new Rectangle(0, 0, _bitmap.Width, _bitmap.Height);
 
             // Figure out the number of bytes in a row. This is rounded up to be a multiple 
             // of 4 bytes, since a scan line in an image must always be a multiple of 4 bytes
             // in length. 
             _bytesInARow = bounds.Width * sizeof(PixelData);
             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
 
             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
 
             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
             _locked = true;
         }
 
         private void InitCurrentPixel()
         {
             _pInitPixel = (PixelData*)_pBase;
         }
 
         private void UnlockBitmap()
         {
             if (!_locked) throw new InvalidOperationException("Not currently locked");
 
             _bitmap.UnlockBits(_bitmapData);
             _bitmapData = null;
             _pBase = null;
             _locked = false;
         }
 
         public void Dispose()
         {
             if (_locked) UnlockBitmap();
         }
     }
 }
             if (_locked) throw new InvalidOperationException("Already locked");
 
             Rectangle bounds = new Rectangle(0, 0, _bitmap.Width, _bitmap.Height);
 
             // Figure out the number of bytes in a row. This is rounded up to be a multiple 
             // of 4 bytes, since a scan line in an image must always be a multiple of 4 bytes
             // in length. 
             _bytesInARow = bounds.Width * sizeof(PixelData);
             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
 
             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
 
             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
             _locked = true;
         }
 
         private void InitCurrentPixel()
         {
             _pInitPixel = (PixelData*)_pBase;
         }
 
         private void UnlockBitmap()
         {
             if (!_locked) throw new InvalidOperationException("Not currently locked");
 
             _bitmap.UnlockBits(_bitmapData);
             _bitmapData = null;
             _pBase = null;
             _locked = false;
         }
 
         public void Dispose()
         {
             if (_locked) UnlockBitmap();
         }
     }
 }
             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
 
             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
 
             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
             _locked = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="84" endline="88"><![CDATA[
 
         private void InitCurrentPixel()
         {
             _pInitPixel = (PixelData*)_pBase;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="89" endline="98"><![CDATA[
 
         private void UnlockBitmap()
         {
             if (!_locked) throw new InvalidOperationException("Not currently locked");
 
             _bitmap.UnlockBits(_bitmapData);
             _bitmapData = null;
             _pBase = null;
             _locked = false;
         }
 
         public void Dispose()
         {
             if (_locked) UnlockBitmap();
         }
     }
 }
             if (!_locked) throw new InvalidOperationException("Not currently locked");
 
             _bitmap.UnlockBits(_bitmapData);
             _bitmapData = null;
             _pBase = null;
             _locked = false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs" startline="99" endline="103"><![CDATA[
 
         public void Dispose()
         {
             if (_locked) UnlockBitmap();
         }
     }
 }
             if (_locked) UnlockBitmap();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="25" endline="34"><![CDATA[
 		public LinedPictureBox()
 		{
 			// Create the normal line pen
 			_linePen = new Pen(Brushes.Red, 1);
 			_linePen.CustomEndCap = new AdjustableArrowCap(2, 2, true);
 
 			// Create the selected line pen
 			_selectedLinePen = new Pen(Brushes.Yellow, 1);
 			_selectedLinePen.CustomEndCap = new AdjustableArrowCap(2, 2, true);
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="35" endline="49"><![CDATA[
 
 		/// <summary>Gets or sets the morph line pairs to be drawn.</summary>
         public LinePairCollection LinePairs { get; set; }
 		/// <summary>Gets or sets the number of the morph image held by this box.</summary>
 		public int ImageNumber { get; set; }
 
         protected override void Dispose(bool disposing)
         {
             if (disposing)
             {
                 _linePen.Dispose();
                 _selectedLinePen.Dispose();
             }
             base.Dispose(disposing);
         }
 
 		/// <summary>Renders the picture box.</summary>
 		/// <param name="e">The paint events.</param>
 		protected override void OnPaint(PaintEventArgs e)
 		{
 			// Render the base picture box (including the morph image)
 			base.OnPaint (e);
 
 			// If there are morph lines, render them.
 			if (LinePairs != null && Image != null)
 			{
 				Graphics g = e.Graphics;
                 foreach (var pair in LinePairs)
 				{
                     Line line = pair.Item(ImageNumber);
 					if (line != null)
 					{
 						g.DrawLine(
 							pair == LinePairs.Selected ? _selectedLinePen 
                             TranslateControlToImage(line[0]), 
                             TranslateControlToImage(line[1]));
 					}
 				}
 			}
 		}
 
         /// <summary>Translates a point from control space to image space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateControlToImage(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
         }
 
         /// <summary>Translates a point from image space to control space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateImageToControl(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
             {
                 _linePen.Dispose();
                 _selectedLinePen.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="50" endline="74"><![CDATA[
 
 		/// <summary>Renders the picture box.</summary>
 		/// <param name="e">The paint events.</param>
 		protected override void OnPaint(PaintEventArgs e)
 		{
 			// Render the base picture box (including the morph image)
 			base.OnPaint (e);
 
 			// If there are morph lines, render them.
 			if (LinePairs != null && Image != null)
 			{
 				Graphics g = e.Graphics;
                 foreach (var pair in LinePairs)
 				{
                     Line line = pair.Item(ImageNumber);
 					if (line != null)
 					{
 						g.DrawLine(
 							pair == LinePairs.Selected ? _selectedLinePen 
                             TranslateControlToImage(line[0]), 
                             TranslateControlToImage(line[1]));
 					}
 				}
 			}
 		}
 
         /// <summary>Translates a point from control space to image space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateControlToImage(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
         }
 
         /// <summary>Translates a point from image space to control space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateImageToControl(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
 			{
 				Graphics g = e.Graphics;
                 foreach (var pair in LinePairs)
 				{
                     Line line = pair.Item(ImageNumber);
 					if (line != null)
 					{
 						g.DrawLine(
 							pair == LinePairs.Selected ? _selectedLinePen 
                             TranslateControlToImage(line[0]), 
                             TranslateControlToImage(line[1]));
 					}
 				}
 			}
 		}
 
         /// <summary>Translates a point from control space to image space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateControlToImage(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
         }
 
         /// <summary>Translates a point from image space to control space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateImageToControl(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
                 foreach (var pair in LinePairs)
 				{
                     Line line = pair.Item(ImageNumber);
 					if (line != null)
 					{
 						g.DrawLine(
 							pair == LinePairs.Selected ? _selectedLinePen 
                             TranslateControlToImage(line[0]), 
                             TranslateControlToImage(line[1]));
 					}
 				}
 			}
 		}
 
         /// <summary>Translates a point from control space to image space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateControlToImage(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
         }
 
         /// <summary>Translates a point from image space to control space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateImageToControl(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
 					{
 						g.DrawLine(
 							pair == LinePairs.Selected ? _selectedLinePen 
                             TranslateControlToImage(line[0]), 
                             TranslateControlToImage(line[1]));
 					}
 				}
                 foreach (var pair in LinePairs)
 				{
                     Line line = pair.Item(ImageNumber);
 					if (line != null)
 					{
 						g.DrawLine(
 							pair == LinePairs.Selected ? _selectedLinePen 
                             TranslateControlToImage(line[0]), 
                             TranslateControlToImage(line[1]));
 					}
 				}
 			}
 		}
 
         /// <summary>Translates a point from control space to image space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateControlToImage(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
         }
 
         /// <summary>Translates a point from image space to control space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateImageToControl(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
 			}
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="75" endline="85"><![CDATA[
 
         /// <summary>Translates a point from control space to image space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateControlToImage(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
         }
 
         /// <summary>Translates a point from image space to control space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateImageToControl(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="86" endline="96"><![CDATA[
 
         /// <summary>Translates a point from image space to control space.</summary>
         /// <param name="point">The location to convert.</param>
         /// <returns>The converted location.</returns>
         public PointF TranslateImageToControl(PointF point)
         {
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
             if (Image == null) throw new InvalidOperationException();
             Rectangle targetRectangle = ImageRectangleFromSizeMode();
             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="97" endline="105"><![CDATA[
 
         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
         {
             rect.X += padding.Left;
             rect.Y += padding.Top;
             rect.Width -= padding.Horizontal;
             rect.Height -= padding.Vertical;
             return rect;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs" startline="106" endline="139"><![CDATA[
 
         public Rectangle ImageRectangleFromSizeMode()
         {
             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
             if (this.Image != null)
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
             {
                 switch (this.SizeMode)
                 {
                     case PictureBoxSizeMode.Normal
                     case PictureBoxSizeMode.AutoSize
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
 	}
 }
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.StretchImage
                         return rectangle;
 
                     case PictureBoxSizeMode.CenterImage
                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
                         rectangle.Size = this.Image.Size;
                         return rectangle;
 
                     case PictureBoxSizeMode.Zoom
                         Size size = this.Image.Size;
                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
                         rectangle.Width = (int)(size.Width * num);
                         rectangle.Height = (int)(size.Height * num);
                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
                         return rectangle;
                 }
             }
             return rectangle;
         }
]]></source>
</source_elements></project>
