
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern Microsoft.Ink
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 1:7:2600:2180
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms as System.Windows.Forms_5
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 1:0:3300:0
}
.assembly extern System.Drawing as System.Drawing_6
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 1:0:3300:0
}
.assembly extern ParallelExtensionsExtras
{
  .ver 1:2:0:0
}
.assembly ImageColorizer
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 0E 49 6D 61 67 65 43 6F 6C 6F 72 69 7A 65   // ...ImageColorize
                                                                                              72 00 00 )                                        // r..
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 0E 49 6D 61 67 65 43 6F 6C 6F 72 69 7A 65   // ...ImageColorize
                                                                                                72 00 00 )                                        // r..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 37 39 36 63 64 65 35 34 2D 30 66 32 32   // ..$796cde54-0f22
                                                                                                  2D 34 33 36 38 2D 38 63 31 66 2D 35 31 33 65 62   // -4368-8c1f-513eb
                                                                                                  33 63 31 39 33 65 31 00 00 )                      // 3c193e1..
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .permissionset reqmin
             = {[mscorlib]System.Security.Permissions.SecurityPermissionAttribute = {property bool 'SkipVerification' = bool(true)}}
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.resources
{
  // Offset: 0x00000000 Length: 0x00002776
}
.mresource public Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm.resources
{
  // Offset: 0x00002780 Length: 0x00005CC8
}
.module ImageColorizer.exe
// MVID: {2BE498C6-20DC-4C09-97C0-6532881E7B83}
.custom instance void [mscorlib]System.Security.UnverifiableCodeAttribute::.ctor() = ( 01 00 00 00 ) 
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x013D0000


// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection
       extends [mscorlib]System.Object
{
  .field private static bool _inkAssemblyAvailable
  .method private hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs' 
//000026: 		private PlatformDetection(){}
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  nop
    IL_0009:  ret
  } // end of method PlatformDetection::.ctor

  .method private hidebysig static class [mscorlib]System.Reflection.Assembly 
          LoadInkAssembly() cil managed
  {
    // Code size       38 (0x26)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Reflection.Assembly CS$1$0000)
//000027: 
//000028: 		/// <summary>Whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000029: 		private static bool _inkAssemblyAvailable = (LoadInkAssembly() != null);
//000030: 
//000031: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000032: 		/// <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
//000033: 		private static Assembly LoadInkAssembly()
//000034: 		{
    IL_0000:  nop
//000035: 			try 
//000036: 			{ 
    .try
    {
      IL_0001:  nop
//000037: 				return LoadInkAssemblyInternal(); 
      IL_0002:  call       class [mscorlib]System.Reflection.Assembly Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::LoadInkAssemblyInternal()
      IL_0007:  stloc.0
      IL_0008:  leave.s    IL_0023

//000038: 			}
//000039: 			catch(TypeLoadException) {}
    }  // end .try
    catch [mscorlib]System.TypeLoadException 
    {
      IL_000a:  pop
      IL_000b:  nop
      IL_000c:  nop
//000040: 			catch(IOException){}
//000041: 			catch(SecurityException){}
//000042: 			catch(BadImageFormatException){}
//000043: 			return null;
//000044: 		}
//000045: 
//000046: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000047: 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
//000048: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000049: 		private static Assembly LoadInkAssemblyInternal()
//000050: 		{
//000051: 			return typeof(InkOverlay).Assembly;
//000052: 		}
//000053: 
//000054:         /// <summary>Gets whether this platform supports using ink.</summary>
//000055:         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
//000056: 
//000057: 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000058: 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
//000059: 
//000060: 		/// <summary>Gets whether a valid recognizer is installed.</summary>
//000061: 		public static bool RecognizerInstalled
//000062: 		{
//000063: 			get
//000064: 			{
//000065: 				if (!_inkAssemblyAvailable) return false;
//000066: 				return GetDefaultRecognizer() != null;
//000067: 			}
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
//000075: 			Recognizer recognizer = null;
//000076: 			try 
//000077: 			{ 
//000078: 				Recognizers recognizers = new Recognizers();
//000079: 				if (recognizers.Count > 1)
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_000d:  leave.s    IL_001e

//000040: 			catch(IOException){}
    }  // end handler
    catch [mscorlib]System.IO.IOException 
    {
      IL_000f:  pop
      IL_0010:  nop
      IL_0011:  nop
//000041: 			catch(SecurityException){}
//000042: 			catch(BadImageFormatException){}
//000043: 			return null;
//000044: 		}
//000045: 
//000046: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000047: 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
//000048: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000049: 		private static Assembly LoadInkAssemblyInternal()
//000050: 		{
//000051: 			return typeof(InkOverlay).Assembly;
//000052: 		}
//000053: 
//000054:         /// <summary>Gets whether this platform supports using ink.</summary>
//000055:         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
//000056: 
//000057: 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000058: 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
//000059: 
//000060: 		/// <summary>Gets whether a valid recognizer is installed.</summary>
//000061: 		public static bool RecognizerInstalled
//000062: 		{
//000063: 			get
//000064: 			{
//000065: 				if (!_inkAssemblyAvailable) return false;
//000066: 				return GetDefaultRecognizer() != null;
//000067: 			}
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
//000075: 			Recognizer recognizer = null;
//000076: 			try 
//000077: 			{ 
//000078: 				Recognizers recognizers = new Recognizers();
//000079: 				if (recognizers.Count > 1)
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0012:  leave.s    IL_001e

//000041: 			catch(SecurityException){}
    }  // end handler
    catch [mscorlib]System.Security.SecurityException 
    {
      IL_0014:  pop
      IL_0015:  nop
      IL_0016:  nop
//000042: 			catch(BadImageFormatException){}
//000043: 			return null;
//000044: 		}
//000045: 
//000046: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000047: 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
//000048: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000049: 		private static Assembly LoadInkAssemblyInternal()
//000050: 		{
//000051: 			return typeof(InkOverlay).Assembly;
//000052: 		}
//000053: 
//000054:         /// <summary>Gets whether this platform supports using ink.</summary>
//000055:         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
//000056: 
//000057: 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000058: 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
//000059: 
//000060: 		/// <summary>Gets whether a valid recognizer is installed.</summary>
//000061: 		public static bool RecognizerInstalled
//000062: 		{
//000063: 			get
//000064: 			{
//000065: 				if (!_inkAssemblyAvailable) return false;
//000066: 				return GetDefaultRecognizer() != null;
//000067: 			}
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
//000075: 			Recognizer recognizer = null;
//000076: 			try 
//000077: 			{ 
//000078: 				Recognizers recognizers = new Recognizers();
//000079: 				if (recognizers.Count > 1)
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0017:  leave.s    IL_001e

//000042: 			catch(BadImageFormatException){}
    }  // end handler
    catch [mscorlib]System.BadImageFormatException 
    {
      IL_0019:  pop
      IL_001a:  nop
      IL_001b:  nop
//000043: 			return null;
//000044: 		}
//000045: 
//000046: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000047: 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
//000048: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000049: 		private static Assembly LoadInkAssemblyInternal()
//000050: 		{
//000051: 			return typeof(InkOverlay).Assembly;
//000052: 		}
//000053: 
//000054:         /// <summary>Gets whether this platform supports using ink.</summary>
//000055:         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
//000056: 
//000057: 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000058: 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
//000059: 
//000060: 		/// <summary>Gets whether a valid recognizer is installed.</summary>
//000061: 		public static bool RecognizerInstalled
//000062: 		{
//000063: 			get
//000064: 			{
//000065: 				if (!_inkAssemblyAvailable) return false;
//000066: 				return GetDefaultRecognizer() != null;
//000067: 			}
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
//000075: 			Recognizer recognizer = null;
//000076: 			try 
//000077: 			{ 
//000078: 				Recognizers recognizers = new Recognizers();
//000079: 				if (recognizers.Count > 1)
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_001c:  leave.s    IL_001e

    }  // end handler
    IL_001e:  nop
//000043: 			return null;
    IL_001f:  ldnull
    IL_0020:  stloc.0
    IL_0021:  br.s       IL_0023

//000044: 		}
//000045: 
//000046: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000047: 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
//000048: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000049: 		private static Assembly LoadInkAssemblyInternal()
//000050: 		{
//000051: 			return typeof(InkOverlay).Assembly;
//000052: 		}
//000053: 
//000054:         /// <summary>Gets whether this platform supports using ink.</summary>
//000055:         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
//000056: 
//000057: 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000058: 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
//000059: 
//000060: 		/// <summary>Gets whether a valid recognizer is installed.</summary>
//000061: 		public static bool RecognizerInstalled
//000062: 		{
//000063: 			get
//000064: 			{
//000065: 				if (!_inkAssemblyAvailable) return false;
//000066: 				return GetDefaultRecognizer() != null;
//000067: 			}
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
//000075: 			Recognizer recognizer = null;
//000076: 			try 
//000077: 			{ 
//000078: 				Recognizers recognizers = new Recognizers();
//000079: 				if (recognizers.Count > 1)
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
    IL_0023:  nop
//000044: 		}
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method PlatformDetection::LoadInkAssembly

  .method private hidebysig static class [mscorlib]System.Reflection.Assembly 
          LoadInkAssemblyInternal() cil managed noinlining
  {
    // Code size       21 (0x15)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Reflection.Assembly CS$1$0000)
//000045: 
//000046: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000047: 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
//000048: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000049: 		private static Assembly LoadInkAssemblyInternal()
//000050: 		{
    IL_0000:  nop
//000051: 			return typeof(InkOverlay).Assembly;
    IL_0001:  ldtoken    [Microsoft.Ink]Microsoft.Ink.InkOverlay
    IL_0006:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_000b:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0010:  stloc.0
    IL_0011:  br.s       IL_0013

//000052: 		}
    IL_0013:  ldloc.0
    IL_0014:  ret
  } // end of method PlatformDetection::LoadInkAssemblyInternal

  .method public hidebysig specialname static 
          bool  get_SupportsInk() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  1
    .locals init ([0] bool CS$1$0000)
//000053: 
//000054:         /// <summary>Gets whether this platform supports using ink.</summary>
//000055:         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
    IL_0000:  nop
    IL_0001:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_InkAssemblyAvailable()
    IL_0006:  brfalse.s  IL_000f

    IL_0008:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_RecognizerInstalled()
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.0
    IL_0010:  stloc.0
    IL_0011:  br.s       IL_0013

    IL_0013:  ldloc.0
    IL_0014:  ret
  } // end of method PlatformDetection::get_SupportsInk

  .method public hidebysig specialname static 
          bool  get_InkAssemblyAvailable() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] bool CS$1$0000)
//000056: 
//000057: 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000058: 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
    IL_0000:  nop
    IL_0001:  ldsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method PlatformDetection::get_InkAssemblyAvailable

  .method public hidebysig specialname static 
          bool  get_RecognizerInstalled() cil managed
  {
    // Code size       30 (0x1e)
    .maxstack  2
    .locals init ([0] bool CS$1$0000,
             [1] bool CS$4$0001)
//000059: 
//000060: 		/// <summary>Gets whether a valid recognizer is installed.</summary>
//000061: 		public static bool RecognizerInstalled
//000062: 		{
//000063: 			get
//000064: 			{
    IL_0000:  nop
//000065: 				if (!_inkAssemblyAvailable) return false;
    IL_0001:  ldsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
    IL_0006:  stloc.1
//000066: 				return GetDefaultRecognizer() != null;
//000067: 			}
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
//000075: 			Recognizer recognizer = null;
//000076: 			try 
//000077: 			{ 
//000078: 				Recognizers recognizers = new Recognizers();
//000079: 				if (recognizers.Count > 1)
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
    IL_0007:  ldloc.1
    IL_0008:  brtrue.s   IL_000e

//000065: 				if (!_inkAssemblyAvailable) return false;
    IL_000a:  ldc.i4.0
    IL_000b:  stloc.0
    IL_000c:  br.s       IL_001c

//000066: 				return GetDefaultRecognizer() != null;
    IL_000e:  call       class [Microsoft.Ink]Microsoft.Ink.Recognizer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::GetDefaultRecognizer()
    IL_0013:  ldnull
    IL_0014:  ceq
    IL_0016:  ldc.i4.0
    IL_0017:  ceq
    IL_0019:  stloc.0
    IL_001a:  br.s       IL_001c

//000067: 			}
    IL_001c:  ldloc.0
    IL_001d:  ret
  } // end of method PlatformDetection::get_RecognizerInstalled

  .method public hidebysig static class [Microsoft.Ink]Microsoft.Ink.Recognizer 
          GetDefaultRecognizer() cil managed noinlining
  {
    // Code size       95 (0x5f)
    .maxstack  2
    .locals init ([0] class [Microsoft.Ink]Microsoft.Ink.Recognizer recognizer,
             [1] class [Microsoft.Ink]Microsoft.Ink.Recognizers recognizers,
             [2] class [Microsoft.Ink]Microsoft.Ink.Recognizer CS$1$0000,
             [3] bool CS$4$0001)
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
    IL_0000:  nop
//000075: 			Recognizer recognizer = null;
    IL_0001:  ldnull
    IL_0002:  stloc.0
//000076: 			try 
//000077: 			{ 
    .try
    {
      IL_0003:  nop
//000078: 				Recognizers recognizers = new Recognizers();
      IL_0004:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.Recognizers::.ctor()
      IL_0009:  stloc.1
//000079: 				if (recognizers.Count > 1)
      IL_000a:  ldloc.1
      IL_000b:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Recognizers::get_Count()
      IL_0010:  ldc.i4.1
      IL_0011:  cgt
      IL_0013:  ldc.i4.0
      IL_0014:  ceq
      IL_0016:  stloc.3
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0017:  ldloc.3
      IL_0018:  brtrue.s   IL_0050

//000080: 				{
      IL_001a:  nop
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
      .try
      {
        IL_001b:  nop
        IL_001c:  ldloc.1
        IL_001d:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Recognizer [Microsoft.Ink]Microsoft.Ink.Recognizers::GetDefaultRecognizer()
        IL_0022:  stloc.0
        IL_0023:  nop
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
        IL_0024:  leave.s    IL_002b

//000083: 					catch {}
      }  // end .try
      catch [mscorlib]System.Object 
      {
        IL_0026:  pop
        IL_0027:  nop
        IL_0028:  nop
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
        IL_0029:  leave.s    IL_002b

      }  // end handler
      IL_002b:  nop
//000086: 					if (recognizer == null)
      IL_002c:  ldloc.0
      IL_002d:  ldnull
      IL_002e:  ceq
      IL_0030:  ldc.i4.0
      IL_0031:  ceq
      IL_0033:  stloc.3
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0034:  ldloc.3
      IL_0035:  brtrue.s   IL_004f

//000087: 					{
      IL_0037:  nop
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
      .try
      {
        IL_0038:  nop
        IL_0039:  ldloc.1
        IL_003a:  ldc.i4     0x409
        IL_003f:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Recognizer [Microsoft.Ink]Microsoft.Ink.Recognizers::GetDefaultRecognizer(int32)
        IL_0044:  stloc.0
        IL_0045:  nop
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
        IL_0046:  leave.s    IL_004d

//000089: 						catch {}
      }  // end .try
      catch [mscorlib]System.Object 
      {
        IL_0048:  pop
        IL_0049:  nop
        IL_004a:  nop
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
        IL_004b:  leave.s    IL_004d

      }  // end handler
      IL_004d:  nop
//000090: 					}
      IL_004e:  nop
//000091: 				}
      IL_004f:  nop
//000092: 			}
      IL_0050:  nop
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0051:  leave.s    IL_0058

//000093: 			catch {} 
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_0053:  pop
      IL_0054:  nop
      IL_0055:  nop
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0056:  leave.s    IL_0058

    }  // end handler
    IL_0058:  nop
//000094: 			return recognizer;
    IL_0059:  ldloc.0
    IL_005a:  stloc.2
    IL_005b:  br.s       IL_005d

//000095: 		}
    IL_005d:  ldloc.2
    IL_005e:  ret
  } // end of method PlatformDetection::GetDefaultRecognizer

  .method public hidebysig specialname static 
          bool  get_GestureRecognizerInstalled() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  1
    .locals init ([0] bool CS$1$0000)
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
    IL_0000:  nop
    IL_0001:  ldsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
    IL_0006:  brfalse.s  IL_000f

    IL_0008:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_GestureRecognizerInstalledInternal()
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.0
    IL_0010:  stloc.0
    IL_0011:  br.s       IL_0013

    IL_0013:  ldloc.0
    IL_0014:  ret
  } // end of method PlatformDetection::get_GestureRecognizerInstalled

  .method private hidebysig specialname static 
          bool  get_GestureRecognizerInstalledInternal() cil managed noinlining
  {
    // Code size       67 (0x43)
    .maxstack  2
    .locals init ([0] class [Microsoft.Ink]Microsoft.Ink.Recognizers recognizers,
             [1] bool CS$1$0000,
             [2] bool CS$4$0001,
             [3] class [Microsoft.Ink]Microsoft.StylusInput.GestureRecognizer CS$3$0002)
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
    IL_0000:  nop
//000110: 				try
//000111: 				{
    .try
    {
      IL_0001:  nop
//000112: 					Recognizers recognizers = new Recognizers();
      IL_0002:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.Recognizers::.ctor()
      IL_0007:  stloc.0
//000113: 					if (recognizers.Count > 0)
      IL_0008:  ldloc.0
      IL_0009:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Recognizers::get_Count()
      IL_000e:  ldc.i4.0
      IL_000f:  cgt
      IL_0011:  ldc.i4.0
      IL_0012:  ceq
      IL_0014:  stloc.2
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0015:  ldloc.2
      IL_0016:  brtrue.s   IL_0033

//000114: 					{
      IL_0018:  nop
//000115: 						using(new GestureRecognizer()) return true;
      IL_0019:  newobj     instance void [Microsoft.Ink]Microsoft.StylusInput.GestureRecognizer::.ctor()
      IL_001e:  stloc.3
      .try
      {
        IL_001f:  ldc.i4.1
        IL_0020:  stloc.1
        IL_0021:  leave.s    IL_0040

//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      }  // end .try
      finally
      {
        IL_0023:  ldloc.3
        IL_0024:  ldnull
        IL_0025:  ceq
        IL_0027:  stloc.2
        IL_0028:  ldloc.2
        IL_0029:  brtrue.s   IL_0032

        IL_002b:  ldloc.3
        IL_002c:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_0031:  nop
        IL_0032:  endfinally
//000117: 				}
      }  // end handler
      IL_0033:  nop
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0034:  leave.s    IL_003b

//000118: 				catch{}
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_0036:  pop
      IL_0037:  nop
      IL_0038:  nop
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
      IL_0039:  leave.s    IL_003b

    }  // end handler
    IL_003b:  nop
//000119: 				return false;
    IL_003c:  ldc.i4.0
    IL_003d:  stloc.1
    IL_003e:  br.s       IL_0040

//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
    IL_0040:  nop
//000120: 			}
    IL_0041:  ldloc.1
    IL_0042:  ret
  } // end of method PlatformDetection::get_GestureRecognizerInstalledInternal

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  8
//000029: 		private static bool _inkAssemblyAvailable = (LoadInkAssembly() != null);
    IL_0000:  call       class [mscorlib]System.Reflection.Assembly Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::LoadInkAssembly()
    IL_0005:  ldnull
    IL_0006:  call       bool [mscorlib]System.Reflection.Assembly::op_Inequality(class [mscorlib]System.Reflection.Assembly,
                                                                                  class [mscorlib]System.Reflection.Assembly)
    IL_000b:  stsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
//000030: 
//000031: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000032: 		/// <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
//000033: 		private static Assembly LoadInkAssembly()
//000034: 		{
//000035: 			try 
//000036: 			{ 
//000037: 				return LoadInkAssemblyInternal(); 
//000038: 			}
//000039: 			catch(TypeLoadException) {}
//000040: 			catch(IOException){}
//000041: 			catch(SecurityException){}
//000042: 			catch(BadImageFormatException){}
//000043: 			return null;
//000044: 		}
//000045: 
//000046: 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000047: 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
//000048: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000049: 		private static Assembly LoadInkAssemblyInternal()
//000050: 		{
//000051: 			return typeof(InkOverlay).Assembly;
//000052: 		}
//000053: 
//000054:         /// <summary>Gets whether this platform supports using ink.</summary>
//000055:         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
//000056: 
//000057: 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000058: 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
//000059: 
//000060: 		/// <summary>Gets whether a valid recognizer is installed.</summary>
//000061: 		public static bool RecognizerInstalled
//000062: 		{
//000063: 			get
//000064: 			{
//000065: 				if (!_inkAssemblyAvailable) return false;
//000066: 				return GetDefaultRecognizer() != null;
//000067: 			}
//000068: 		}
//000069: 
//000070: 		/// <summary>Gets the best recognizer for the current locale.</summary>
//000071: 		/// <returns>The best recognizer for the current locale.</returns>
//000072: 		[MethodImpl(MethodImplOptions.NoInlining)]
//000073: 		public static Recognizer GetDefaultRecognizer() 
//000074: 		{
//000075: 			Recognizer recognizer = null;
//000076: 			try 
//000077: 			{ 
//000078: 				Recognizers recognizers = new Recognizers();
//000079: 				if (recognizers.Count > 1)
//000080: 				{
//000081: 					// First try the current locale's recognizer
//000082: 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
//000083: 					catch {}
//000084: 					
//000085: 					// Fallback to the en-US (1033) recognizer
//000086: 					if (recognizer == null)
//000087: 					{
//000088: 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
//000089: 						catch {}
//000090: 					}
//000091: 				}
//000092: 			}
//000093: 			catch {} 
//000094: 			return recognizer;
//000095: 		}
//000096: 
//000097: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000098: 		public static bool GestureRecognizerInstalled
//000099: 		{
//000100: 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
//000101: 		}
//000102: 
//000103: 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000104: 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000105: 		private static bool GestureRecognizerInstalledInternal 
//000106: 		{
//000107: 			[MethodImpl(MethodImplOptions.NoInlining)]
//000108: 			get
//000109: 			{
//000110: 				try
//000111: 				{
//000112: 					Recognizers recognizers = new Recognizers();
//000113: 					if (recognizers.Count > 0)
//000114: 					{
//000115: 						using(new GestureRecognizer()) return true;
//000116: 					}
//000117: 				}
//000118: 				catch{}
//000119: 				return false;
//000120: 			}
//000121: 		}
//000122: 	}
//000123: }
    IL_0010:  ret
  } // end of method PlatformDetection::.cctor

  .property bool SupportsInk()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
  } // end of property PlatformDetection::SupportsInk
  .property bool InkAssemblyAvailable()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_InkAssemblyAvailable()
  } // end of property PlatformDetection::InkAssemblyAvailable
  .property bool RecognizerInstalled()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_RecognizerInstalled()
  } // end of property PlatformDetection::RecognizerInstalled
  .property bool GestureRecognizerInstalled()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_GestureRecognizerInstalled()
  } // end of property PlatformDetection::GestureRecognizerInstalled
  .property bool GestureRecognizerInstalledInternal()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_GestureRecognizerInstalledInternal()
  } // end of property PlatformDetection::GestureRecognizerInstalledInternal
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection

.class private auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Settings.Designer.cs' 
//000021:             get {
    IL_0000:  nop
//000022:                 return defaultInstance;
    IL_0001:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000023:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000018:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
    IL_000f:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::defaultInstance
//000019:         
//000020:         public static Settings Default {
//000021:             get {
//000022:                 return defaultInstance;
//000023:             }
//000024:         }
//000025:     }
//000026: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
          Default()
  {
    .get class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings

.class public auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .field private class [System]System.ComponentModel.IContainer components
  .field private class [System]System.ComponentModel.BackgroundWorker bwColorize
  .field private class [System.Windows.Forms]System.Windows.Forms.Timer tmRefresh
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer toolStripContainer
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox pbImage
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStrip toolStripMain
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton btnLoadImage
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton btnSaveImage
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator separator1
  .field private class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar tbEpsilon
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator separator2
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton btnInk
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton btnEraser
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar pbColorizing
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel lblHuesSelected
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton btnParallel
  .field private class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> _selectedPixels
  .field private int32 _lastEpsilon
  .field private valuetype [System.Drawing]System.Drawing.Size _lastPictureBoxSize
  .field private class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> _paths
  .field private class [System.Drawing]System.Drawing.Bitmap _originalImage
  .field private class [System.Drawing]System.Drawing.Bitmap _colorizedImage
  .field private class [Microsoft.Ink]Microsoft.Ink.InkOverlay _overlay
  .field private class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog _ofd
  .field private static class [mscorlib]System.Predicate`1<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo> 'CS$<>9__CachedAnonymousMethodDelegate2'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.Designer.cs' 
//000015:         {
    IL_0000:  nop
//000016:             if (disposing && (components != null))
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000f

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_000a:  ldnull
    IL_000b:  ceq
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000017:             {
//000018:                 components.Dispose();
//000019:             }
//000020:             base.Dispose(disposing);
//000021:         }
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
//000031:             this.components = new System.ComponentModel.Container();
//000032:             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
//000033:             this.bwColorize = new System.ComponentModel.BackgroundWorker();
//000034:             this.tmRefresh = new System.Windows.Forms.Timer(this.components);
//000035:             this.toolStripContainer = new System.Windows.Forms.ToolStripContainer();
//000036:             this.pbImage = new System.Windows.Forms.PictureBox();
//000037:             this.toolStripMain = new System.Windows.Forms.ToolStrip();
//000038:             this.btnLoadImage = new System.Windows.Forms.ToolStripButton();
//000039:             this.btnSaveImage = new System.Windows.Forms.ToolStripButton();
//000040:             this.separator1 = new System.Windows.Forms.ToolStripSeparator();
//000041:             this.tbEpsilon = new Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar();
//000042:             this.separator2 = new System.Windows.Forms.ToolStripSeparator();
//000043:             this.btnParallel = new System.Windows.Forms.ToolStripButton();
//000044:             this.btnInk = new System.Windows.Forms.ToolStripButton();
//000045:             this.btnEraser = new System.Windows.Forms.ToolStripButton();
//000046:             this.pbColorizing = new System.Windows.Forms.ToolStripProgressBar();
//000047:             this.lblHuesSelected = new System.Windows.Forms.ToolStripLabel();
//000048:             this.toolStripContainer.ContentPanel.SuspendLayout();
//000049:             this.toolStripContainer.TopToolStripPanel.SuspendLayout();
//000050:             this.toolStripContainer.SuspendLayout();
//000051:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
//000052:             this.toolStripMain.SuspendLayout();
//000053:             this.SuspendLayout();
//000054:             // 
//000055:             // bwColorize
//000056:             // 
//000057:             this.bwColorize.WorkerReportsProgress = true;
//000058:             this.bwColorize.DoWork += new System.ComponentModel.DoWorkEventHandler(this.bwColorize_DoWork);
//000059:             this.bwColorize.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.bwColorize_RunWorkerCompleted);
//000060:             this.bwColorize.ProgressChanged += new System.ComponentModel.ProgressChangedEventHandler(this.bwColorize_ProgressChanged);
//000061:             // 
//000062:             // tmRefresh
//000063:             // 
//000064:             this.tmRefresh.Interval = 1000;
//000065:             this.tmRefresh.Tick += new System.EventHandler(this.tmRefresh_Tick);
//000066:             // 
//000067:             // toolStripContainer
//000068:             // 
//000069:             // 
//000070:             // toolStripContainer.ContentPanel
//000071:             // 
//000072:             this.toolStripContainer.ContentPanel.Controls.Add(this.pbImage);
//000073:             this.toolStripContainer.ContentPanel.Size = new System.Drawing.Size(619, 397);
//000074:             this.toolStripContainer.Dock = System.Windows.Forms.DockStyle.Fill;
//000075:             this.toolStripContainer.Location = new System.Drawing.Point(0, 0);
//000076:             this.toolStripContainer.Name = "toolStripContainer";
//000077:             this.toolStripContainer.Size = new System.Drawing.Size(619, 422);
//000078:             this.toolStripContainer.TabIndex = 10;
//000079:             this.toolStripContainer.Text = "toolStripContainer1";
//000080:             // 
//000081:             // toolStripContainer.TopToolStripPanel
//000082:             // 
//000083:             this.toolStripContainer.TopToolStripPanel.Controls.Add(this.toolStripMain);
//000084:             // 
//000085:             // pbImage
//000086:             // 
//000087:             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
//000088:                         | System.Windows.Forms.AnchorStyles.Left)
//000089:                         | System.Windows.Forms.AnchorStyles.Right)));
//000090:             this.pbImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
//000091:             this.pbImage.Cursor = System.Windows.Forms.Cursors.Default;
//000092:             this.pbImage.Location = new System.Drawing.Point(3, 3);
//000093:             this.pbImage.Name = "pbImage";
//000094:             this.pbImage.Size = new System.Drawing.Size(613, 391);
//000095:             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
//000096:             this.pbImage.TabIndex = 10;
//000097:             this.pbImage.TabStop = false;
//000098:             this.pbImage.DragDrop += new System.Windows.Forms.DragEventHandler(this.pbImage_DragDrop);
//000099:             this.pbImage.Resize += new System.EventHandler(this.pbImage_Resize);
//000100:             this.pbImage.MouseClick += new System.Windows.Forms.MouseEventHandler(this.pbImage_MouseClick);
//000101:             this.pbImage.DragEnter += new System.Windows.Forms.DragEventHandler(this.pbImage_DragEnter);
//000102:             // 
//000103:             // toolStripMain
//000104:             // 
//000105:             this.toolStripMain.AllowItemReorder = true;
//000106:             this.toolStripMain.Dock = System.Windows.Forms.DockStyle.None;
//000107:             this.toolStripMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000108:             this.btnLoadImage,
//000109:             this.btnSaveImage,
//000110:             this.separator1,
//000111:             this.tbEpsilon,
//000112:             this.separator2,
//000113:             this.btnParallel,
//000114:             this.btnInk,
//000115:             this.btnEraser,
//000116:             this.pbColorizing,
//000117:             this.lblHuesSelected});
//000118:             this.toolStripMain.LayoutStyle = System.Windows.Forms.ToolStripLayoutStyle.HorizontalStackWithOverflow;
//000119:             this.toolStripMain.Location = new System.Drawing.Point(3, 0);
//000120:             this.toolStripMain.Name = "toolStripMain";
//000121:             this.toolStripMain.Size = new System.Drawing.Size(616, 25);
//000122:             this.toolStripMain.TabIndex = 9;
//000123:             this.toolStripMain.Text = "toolStrip1";
//000124:             // 
//000125:             // btnLoadImage
//000126:             // 
//000127:             this.btnLoadImage.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.InsertPictureHS;
//000128:             this.btnLoadImage.ImageTransparentColor = System.Drawing.Color.Magenta;
//000129:             this.btnLoadImage.Name = "btnLoadImage";
//000130:             this.btnLoadImage.Size = new System.Drawing.Size(89, 22);
//000131:             this.btnLoadImage.Text = "&Load Image";
//000132:             this.btnLoadImage.Click += new System.EventHandler(this.btnLoadImage_Click);
//000133:             // 
//000134:             // btnSaveImage
//000135:             // 
//000136:             this.btnSaveImage.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.saveHS;
//000137:             this.btnSaveImage.ImageTransparentColor = System.Drawing.Color.Magenta;
//000138:             this.btnSaveImage.Name = "btnSaveImage";
//000139:             this.btnSaveImage.Size = new System.Drawing.Size(87, 22);
//000140:             this.btnSaveImage.Text = "&Save Image";
//000141:             this.btnSaveImage.Click += new System.EventHandler(this.btnSaveImage_Click);
//000142:             // 
//000143:             // separator1
//000144:             // 
//000145:             this.separator1.Name = "separator1";
//000146:             this.separator1.Size = new System.Drawing.Size(6, 25);
//000147:             // 
//000148:             // tbEpsilon
//000149:             // 
//000150:             this.tbEpsilon.BackColor = System.Drawing.SystemColors.Control;
//000151:             this.tbEpsilon.Maximum = 180;
//000152:             this.tbEpsilon.Name = "tbEpsilon";
//000153:             this.tbEpsilon.Size = new System.Drawing.Size(150, 22);
//000154:             this.tbEpsilon.Text = "toolStripTrackBar1";
//000155:             this.tbEpsilon.Value = 15;
//000156:             this.tbEpsilon.ValueChanged += new System.EventHandler(this.tbEpsilon_ValueChanged);
//000157:             // 
//000158:             // separator2
//000159:             // 
//000160:             this.separator2.Name = "separator2";
//000161:             this.separator2.Size = new System.Drawing.Size(6, 25);
//000162:             // 
//000163:             // btnParallel
//000164:             // 
//000165:             this.btnParallel.CheckOnClick = true;
//000166:             this.btnParallel.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
//000167:             this.btnParallel.Image = ((System.Drawing.Image)(resources.GetObject("btnParallel.Image")));
//000168:             this.btnParallel.ImageTransparentColor = System.Drawing.Color.Magenta;
//000169:             this.btnParallel.Name = "btnParallel";
//000170:             this.btnParallel.Size = new System.Drawing.Size(23, 22);
//000171:             this.btnParallel.Text = "btnParallel";
//000172:             this.btnParallel.CheckedChanged += new System.EventHandler(this.btnParallel_CheckedChanged);
//000173:             // 
//000174:             // btnInk
//000175:             // 
//000176:             this.btnInk.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
//000177:             this.btnInk.Enabled = false;
//000178:             this.btnInk.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.pen;
//000179:             this.btnInk.ImageTransparentColor = System.Drawing.Color.Magenta;
//000180:             this.btnInk.Name = "btnInk";
//000181:             this.btnInk.Size = new System.Drawing.Size(23, 22);
//000182:             this.btnInk.Text = "btnInk";
//000183:             this.btnInk.Click += new System.EventHandler(this.btnInk_Click);
//000184:             // 
//000185:             // btnEraser
//000186:             // 
//000187:             this.btnEraser.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
//000188:             this.btnEraser.Enabled = false;
//000189:             this.btnEraser.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.eraser;
//000190:             this.btnEraser.ImageTransparentColor = System.Drawing.Color.Magenta;
//000191:             this.btnEraser.Name = "btnEraser";
//000192:             this.btnEraser.Size = new System.Drawing.Size(23, 22);
//000193:             this.btnEraser.Text = "btnEraser";
//000194:             this.btnEraser.Click += new System.EventHandler(this.btnEraser_Click);
//000195:             // 
//000196:             // pbColorizing
//000197:             // 
//000198:             this.pbColorizing.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
//000199:             this.pbColorizing.Name = "pbColorizing";
//000200:             this.pbColorizing.Overflow = System.Windows.Forms.ToolStripItemOverflow.Never;
//000201:             this.pbColorizing.Size = new System.Drawing.Size(140, 22);
//000202:             this.pbColorizing.Visible = false;
//000203:             // 
//000204:             // lblHuesSelected
//000205:             // 
//000206:             this.lblHuesSelected.Name = "lblHuesSelected";
//000207:             this.lblHuesSelected.Size = new System.Drawing.Size(81, 15);
//000208:             this.lblHuesSelected.Text = "Hues Selected";
//000209:             this.lblHuesSelected.Click += new System.EventHandler(this.lblHuesSelected_Click);
//000210:             // 
//000211:             // MainForm
//000212:             // 
//000213:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
//000214:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
//000215:             this.ClientSize = new System.Drawing.Size(619, 422);
//000216:             this.Controls.Add(this.toolStripContainer);
//000217:             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
//000218:             this.KeyPreview = true;
//000219:             this.Name = "MainForm";
//000220:             this.Text = "Image Colorizer";
//000221:             this.Load += new System.EventHandler(this.MainForm_Load);
//000222:             this.toolStripContainer.ContentPanel.ResumeLayout(false);
//000223:             this.toolStripContainer.TopToolStripPanel.ResumeLayout(false);
//000224:             this.toolStripContainer.TopToolStripPanel.PerformLayout();
//000225:             this.toolStripContainer.ResumeLayout(false);
//000226:             this.toolStripContainer.PerformLayout();
//000227:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
//000228:             this.toolStripMain.ResumeLayout(false);
//000229:             this.toolStripMain.PerformLayout();
//000230:             this.ResumeLayout(false);
//000231: 
//000232:         }
//000233: 
//000234:         #endregion
//000235: 
//000236:         private System.ComponentModel.BackgroundWorker bwColorize;
//000237:         private System.Windows.Forms.Timer tmRefresh;
//000238:         private System.Windows.Forms.ToolStripContainer toolStripContainer;
//000239:         private System.Windows.Forms.PictureBox pbImage;
//000240:         private System.Windows.Forms.ToolStrip toolStripMain;
//000241:         private System.Windows.Forms.ToolStripButton btnLoadImage;
//000242:         private System.Windows.Forms.ToolStripButton btnSaveImage;
//000243:         private System.Windows.Forms.ToolStripSeparator separator1;
//000244:         private ToolStripTrackBar tbEpsilon;
//000245:         private System.Windows.Forms.ToolStripSeparator separator2;
//000246:         private System.Windows.Forms.ToolStripButton btnInk;
//000247:         private System.Windows.Forms.ToolStripButton btnEraser;
//000248:         private System.Windows.Forms.ToolStripProgressBar pbColorizing;
//000249:         private System.Windows.Forms.ToolStripLabel lblHuesSelected;
//000250:         private System.Windows.Forms.ToolStripButton btnParallel;
//000251:     }
//000252: }
//000253: 
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_0022

//000017:             {
    IL_0014:  nop
//000018:                 components.Dispose();
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_001b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_0020:  nop
//000019:             }
    IL_0021:  nop
//000020:             base.Dispose(disposing);
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0029:  nop
//000021:         }
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       2372 (0x944)
    .maxstack  4
    .locals init ([0] class [System]System.ComponentModel.ComponentResourceManager resources,
             [1] class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[] CS$0$0000)
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
    IL_0000:  nop
//000031:             this.components = new System.ComponentModel.Container();
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System]System.ComponentModel.Container::.ctor()
    IL_0007:  stfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
//000032:             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
    IL_000c:  ldtoken    Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm
    IL_0011:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0016:  newobj     instance void [System]System.ComponentModel.ComponentResourceManager::.ctor(class [mscorlib]System.Type)
    IL_001b:  stloc.0
//000033:             this.bwColorize = new System.ComponentModel.BackgroundWorker();
    IL_001c:  ldarg.0
    IL_001d:  newobj     instance void [System]System.ComponentModel.BackgroundWorker::.ctor()
    IL_0022:  stfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
//000034:             this.tmRefresh = new System.Windows.Forms.Timer(this.components);
    IL_0027:  ldarg.0
    IL_0028:  ldarg.0
    IL_0029:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_002e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Timer::.ctor(class [System]System.ComponentModel.IContainer)
    IL_0033:  stfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh
//000035:             this.toolStripContainer = new System.Windows.Forms.ToolStripContainer();
    IL_0038:  ldarg.0
    IL_0039:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::.ctor()
    IL_003e:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
//000036:             this.pbImage = new System.Windows.Forms.PictureBox();
    IL_0043:  ldarg.0
    IL_0044:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_0049:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
//000037:             this.toolStripMain = new System.Windows.Forms.ToolStrip();
    IL_004e:  ldarg.0
    IL_004f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::.ctor()
    IL_0054:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
//000038:             this.btnLoadImage = new System.Windows.Forms.ToolStripButton();
    IL_0059:  ldarg.0
    IL_005a:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_005f:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
//000039:             this.btnSaveImage = new System.Windows.Forms.ToolStripButton();
    IL_0064:  ldarg.0
    IL_0065:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_006a:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
//000040:             this.separator1 = new System.Windows.Forms.ToolStripSeparator();
    IL_006f:  ldarg.0
    IL_0070:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_0075:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
//000041:             this.tbEpsilon = new Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar();
    IL_007a:  ldarg.0
    IL_007b:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::.ctor()
    IL_0080:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
//000042:             this.separator2 = new System.Windows.Forms.ToolStripSeparator();
    IL_0085:  ldarg.0
    IL_0086:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_008b:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
//000043:             this.btnParallel = new System.Windows.Forms.ToolStripButton();
    IL_0090:  ldarg.0
    IL_0091:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_0096:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
//000044:             this.btnInk = new System.Windows.Forms.ToolStripButton();
    IL_009b:  ldarg.0
    IL_009c:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_00a1:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
//000045:             this.btnEraser = new System.Windows.Forms.ToolStripButton();
    IL_00a6:  ldarg.0
    IL_00a7:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_00ac:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
//000046:             this.pbColorizing = new System.Windows.Forms.ToolStripProgressBar();
    IL_00b1:  ldarg.0
    IL_00b2:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::.ctor()
    IL_00b7:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
//000047:             this.lblHuesSelected = new System.Windows.Forms.ToolStripLabel();
    IL_00bc:  ldarg.0
    IL_00bd:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripLabel::.ctor()
    IL_00c2:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
//000048:             this.toolStripContainer.ContentPanel.SuspendLayout();
    IL_00c7:  ldarg.0
    IL_00c8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_00cd:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_00d2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00d7:  nop
//000049:             this.toolStripContainer.TopToolStripPanel.SuspendLayout();
    IL_00d8:  ldarg.0
    IL_00d9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_00de:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_00e3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00e8:  nop
//000050:             this.toolStripContainer.SuspendLayout();
    IL_00e9:  ldarg.0
    IL_00ea:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_00ef:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00f4:  nop
//000051:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
    IL_00f5:  ldarg.0
    IL_00f6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00fb:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_0100:  nop
//000052:             this.toolStripMain.SuspendLayout();
    IL_0101:  ldarg.0
    IL_0102:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0107:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_010c:  nop
//000053:             this.SuspendLayout();
    IL_010d:  ldarg.0
    IL_010e:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0113:  nop
//000054:             // 
//000055:             // bwColorize
//000056:             // 
//000057:             this.bwColorize.WorkerReportsProgress = true;
    IL_0114:  ldarg.0
    IL_0115:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_011a:  ldc.i4.1
    IL_011b:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::set_WorkerReportsProgress(bool)
    IL_0120:  nop
//000058:             this.bwColorize.DoWork += new System.ComponentModel.DoWorkEventHandler(this.bwColorize_DoWork);
    IL_0121:  ldarg.0
    IL_0122:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_0127:  ldarg.0
    IL_0128:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize_DoWork(object,
                                                                                                                                  class [System]System.ComponentModel.DoWorkEventArgs)
    IL_012e:  newobj     instance void [System]System.ComponentModel.DoWorkEventHandler::.ctor(object,
                                                                                               native int)
    IL_0133:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::add_DoWork(class [System]System.ComponentModel.DoWorkEventHandler)
    IL_0138:  nop
//000059:             this.bwColorize.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.bwColorize_RunWorkerCompleted);
    IL_0139:  ldarg.0
    IL_013a:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_013f:  ldarg.0
    IL_0140:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize_RunWorkerCompleted(object,
                                                                                                                                              class [System]System.ComponentModel.RunWorkerCompletedEventArgs)
    IL_0146:  newobj     instance void [System]System.ComponentModel.RunWorkerCompletedEventHandler::.ctor(object,
                                                                                                           native int)
    IL_014b:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::add_RunWorkerCompleted(class [System]System.ComponentModel.RunWorkerCompletedEventHandler)
    IL_0150:  nop
//000060:             this.bwColorize.ProgressChanged += new System.ComponentModel.ProgressChangedEventHandler(this.bwColorize_ProgressChanged);
    IL_0151:  ldarg.0
    IL_0152:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_0157:  ldarg.0
    IL_0158:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize_ProgressChanged(object,
                                                                                                                                           class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_015e:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventHandler::.ctor(object,
                                                                                                        native int)
    IL_0163:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    IL_0168:  nop
//000061:             // 
//000062:             // tmRefresh
//000063:             // 
//000064:             this.tmRefresh.Interval = 1000;
    IL_0169:  ldarg.0
    IL_016a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh
    IL_016f:  ldc.i4     0x3e8
    IL_0174:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::set_Interval(int32)
    IL_0179:  nop
//000065:             this.tmRefresh.Tick += new System.EventHandler(this.tmRefresh_Tick);
    IL_017a:  ldarg.0
    IL_017b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh
    IL_0180:  ldarg.0
    IL_0181:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh_Tick(object,
                                                                                                                               class [mscorlib]System.EventArgs)
    IL_0187:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_018c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::add_Tick(class [mscorlib]System.EventHandler)
    IL_0191:  nop
//000066:             // 
//000067:             // toolStripContainer
//000068:             // 
//000069:             // 
//000070:             // toolStripContainer.ContentPanel
//000071:             // 
//000072:             this.toolStripContainer.ContentPanel.Controls.Add(this.pbImage);
    IL_0192:  ldarg.0
    IL_0193:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0198:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_019d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_01a2:  ldarg.0
    IL_01a3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_01a8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_01ad:  nop
//000073:             this.toolStripContainer.ContentPanel.Size = new System.Drawing.Size(619, 397);
    IL_01ae:  ldarg.0
    IL_01af:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01b4:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_01b9:  ldc.i4     0x26b
    IL_01be:  ldc.i4     0x18d
    IL_01c3:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_01c8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_01cd:  nop
//000074:             this.toolStripContainer.Dock = System.Windows.Forms.DockStyle.Fill;
    IL_01ce:  ldarg.0
    IL_01cf:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01d4:  ldc.i4.5
    IL_01d5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_01da:  nop
//000075:             this.toolStripContainer.Location = new System.Drawing.Point(0, 0);
    IL_01db:  ldarg.0
    IL_01dc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01e1:  ldc.i4.0
    IL_01e2:  ldc.i4.0
    IL_01e3:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_01e8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_01ed:  nop
//000076:             this.toolStripContainer.Name = "toolStripContainer";
    IL_01ee:  ldarg.0
    IL_01ef:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01f4:  ldstr      "toolStripContainer"
    IL_01f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_01fe:  nop
//000077:             this.toolStripContainer.Size = new System.Drawing.Size(619, 422);
    IL_01ff:  ldarg.0
    IL_0200:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0205:  ldc.i4     0x26b
    IL_020a:  ldc.i4     0x1a6
    IL_020f:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0214:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0219:  nop
//000078:             this.toolStripContainer.TabIndex = 10;
    IL_021a:  ldarg.0
    IL_021b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0220:  ldc.i4.s   10
    IL_0222:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0227:  nop
//000079:             this.toolStripContainer.Text = "toolStripContainer1";
    IL_0228:  ldarg.0
    IL_0229:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_022e:  ldstr      "toolStripContainer1"
    IL_0233:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0238:  nop
//000080:             // 
//000081:             // toolStripContainer.TopToolStripPanel
//000082:             // 
//000083:             this.toolStripContainer.TopToolStripPanel.Controls.Add(this.toolStripMain);
    IL_0239:  ldarg.0
    IL_023a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_023f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_0244:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0249:  ldarg.0
    IL_024a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_024f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0254:  nop
//000084:             // 
//000085:             // pbImage
//000086:             // 
//000087:             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
    IL_0255:  ldarg.0
    IL_0256:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_025b:  ldc.i4.s   15
    IL_025d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0262:  nop
//000088:                         | System.Windows.Forms.AnchorStyles.Left)
//000089:                         | System.Windows.Forms.AnchorStyles.Right)));
//000090:             this.pbImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
    IL_0263:  ldarg.0
    IL_0264:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0269:  ldc.i4.2
    IL_026a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
    IL_026f:  nop
//000091:             this.pbImage.Cursor = System.Windows.Forms.Cursors.Default;
    IL_0270:  ldarg.0
    IL_0271:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0276:  call       class [System.Windows.Forms]System.Windows.Forms.Cursor [System.Windows.Forms]System.Windows.Forms.Cursors::get_Default()
    IL_027b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Cursor(class [System.Windows.Forms]System.Windows.Forms.Cursor)
    IL_0280:  nop
//000092:             this.pbImage.Location = new System.Drawing.Point(3, 3);
    IL_0281:  ldarg.0
    IL_0282:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0287:  ldc.i4.3
    IL_0288:  ldc.i4.3
    IL_0289:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_028e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0293:  nop
//000093:             this.pbImage.Name = "pbImage";
    IL_0294:  ldarg.0
    IL_0295:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_029a:  ldstr      "pbImage"
    IL_029f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_02a4:  nop
//000094:             this.pbImage.Size = new System.Drawing.Size(613, 391);
    IL_02a5:  ldarg.0
    IL_02a6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_02ab:  ldc.i4     0x265
    IL_02b0:  ldc.i4     0x187
    IL_02b5:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_02ba:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_02bf:  nop
//000095:             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
    IL_02c0:  ldarg.0
    IL_02c1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_02c6:  ldc.i4.1
    IL_02c7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_02cc:  nop
//000096:             this.pbImage.TabIndex = 10;
    IL_02cd:  ldarg.0
    IL_02ce:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_02d3:  ldc.i4.s   10
    IL_02d5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_02da:  nop
//000097:             this.pbImage.TabStop = false;
    IL_02db:  ldarg.0
    IL_02dc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_02e1:  ldc.i4.0
    IL_02e2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_02e7:  nop
//000098:             this.pbImage.DragDrop += new System.Windows.Forms.DragEventHandler(this.pbImage_DragDrop);
    IL_02e8:  ldarg.0
    IL_02e9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_02ee:  ldarg.0
    IL_02ef:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_DragDrop(object,
                                                                                                                                 class [System.Windows.Forms]System.Windows.Forms.DragEventArgs)
    IL_02f5:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.DragEventHandler::.ctor(object,
                                                                                                          native int)
    IL_02fa:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DragDrop(class [System.Windows.Forms]System.Windows.Forms.DragEventHandler)
    IL_02ff:  nop
//000099:             this.pbImage.Resize += new System.EventHandler(this.pbImage_Resize);
    IL_0300:  ldarg.0
    IL_0301:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0306:  ldarg.0
    IL_0307:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_Resize(object,
                                                                                                                               class [mscorlib]System.EventArgs)
    IL_030d:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0312:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Resize(class [mscorlib]System.EventHandler)
    IL_0317:  nop
//000100:             this.pbImage.MouseClick += new System.Windows.Forms.MouseEventHandler(this.pbImage_MouseClick);
    IL_0318:  ldarg.0
    IL_0319:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_031e:  ldarg.0
    IL_031f:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_MouseClick(object,
                                                                                                                                   class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0325:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_032a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseClick(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_032f:  nop
//000101:             this.pbImage.DragEnter += new System.Windows.Forms.DragEventHandler(this.pbImage_DragEnter);
    IL_0330:  ldarg.0
    IL_0331:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0336:  ldarg.0
    IL_0337:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_DragEnter(object,
                                                                                                                                  class [System.Windows.Forms]System.Windows.Forms.DragEventArgs)
    IL_033d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.DragEventHandler::.ctor(object,
                                                                                                          native int)
    IL_0342:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DragEnter(class [System.Windows.Forms]System.Windows.Forms.DragEventHandler)
    IL_0347:  nop
//000102:             // 
//000103:             // toolStripMain
//000104:             // 
//000105:             this.toolStripMain.AllowItemReorder = true;
    IL_0348:  ldarg.0
    IL_0349:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_034e:  ldc.i4.1
    IL_034f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::set_AllowItemReorder(bool)
    IL_0354:  nop
//000106:             this.toolStripMain.Dock = System.Windows.Forms.DockStyle.None;
    IL_0355:  ldarg.0
    IL_0356:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_035b:  ldc.i4.0
    IL_035c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_0361:  nop
//000107:             this.toolStripMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_0362:  ldarg.0
    IL_0363:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0368:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStrip::get_Items()
    IL_036d:  ldc.i4.s   10
    IL_036f:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_0374:  stloc.1
    IL_0375:  ldloc.1
    IL_0376:  ldc.i4.0
    IL_0377:  ldarg.0
    IL_0378:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_037d:  stelem.ref
    IL_037e:  ldloc.1
    IL_037f:  ldc.i4.1
    IL_0380:  ldarg.0
    IL_0381:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_0386:  stelem.ref
    IL_0387:  ldloc.1
    IL_0388:  ldc.i4.2
    IL_0389:  ldarg.0
    IL_038a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
    IL_038f:  stelem.ref
    IL_0390:  ldloc.1
    IL_0391:  ldc.i4.3
    IL_0392:  ldarg.0
    IL_0393:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_0398:  stelem.ref
    IL_0399:  ldloc.1
    IL_039a:  ldc.i4.4
    IL_039b:  ldarg.0
    IL_039c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
    IL_03a1:  stelem.ref
    IL_03a2:  ldloc.1
    IL_03a3:  ldc.i4.5
    IL_03a4:  ldarg.0
    IL_03a5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_03aa:  stelem.ref
    IL_03ab:  ldloc.1
    IL_03ac:  ldc.i4.6
    IL_03ad:  ldarg.0
    IL_03ae:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_03b3:  stelem.ref
    IL_03b4:  ldloc.1
    IL_03b5:  ldc.i4.7
    IL_03b6:  ldarg.0
    IL_03b7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_03bc:  stelem.ref
    IL_03bd:  ldloc.1
    IL_03be:  ldc.i4.8
    IL_03bf:  ldarg.0
    IL_03c0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_03c5:  stelem.ref
    IL_03c6:  ldloc.1
    IL_03c7:  ldc.i4.s   9
    IL_03c9:  ldarg.0
    IL_03ca:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_03cf:  stelem.ref
    IL_03d0:  ldloc.1
    IL_03d1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_03d6:  nop
//000108:             this.btnLoadImage,
//000109:             this.btnSaveImage,
//000110:             this.separator1,
//000111:             this.tbEpsilon,
//000112:             this.separator2,
//000113:             this.btnParallel,
//000114:             this.btnInk,
//000115:             this.btnEraser,
//000116:             this.pbColorizing,
//000117:             this.lblHuesSelected});
//000118:             this.toolStripMain.LayoutStyle = System.Windows.Forms.ToolStripLayoutStyle.HorizontalStackWithOverflow;
    IL_03d7:  ldarg.0
    IL_03d8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_03dd:  ldc.i4.1
    IL_03de:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::set_LayoutStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripLayoutStyle)
    IL_03e3:  nop
//000119:             this.toolStripMain.Location = new System.Drawing.Point(3, 0);
    IL_03e4:  ldarg.0
    IL_03e5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_03ea:  ldc.i4.3
    IL_03eb:  ldc.i4.0
    IL_03ec:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_03f1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_03f6:  nop
//000120:             this.toolStripMain.Name = "toolStripMain";
    IL_03f7:  ldarg.0
    IL_03f8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_03fd:  ldstr      "toolStripMain"
    IL_0402:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0407:  nop
//000121:             this.toolStripMain.Size = new System.Drawing.Size(616, 25);
    IL_0408:  ldarg.0
    IL_0409:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_040e:  ldc.i4     0x268
    IL_0413:  ldc.i4.s   25
    IL_0415:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_041a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_041f:  nop
//000122:             this.toolStripMain.TabIndex = 9;
    IL_0420:  ldarg.0
    IL_0421:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0426:  ldc.i4.s   9
    IL_0428:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_042d:  nop
//000123:             this.toolStripMain.Text = "toolStrip1";
    IL_042e:  ldarg.0
    IL_042f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0434:  ldstr      "toolStrip1"
    IL_0439:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_043e:  nop
//000124:             // 
//000125:             // btnLoadImage
//000126:             // 
//000127:             this.btnLoadImage.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.InsertPictureHS;
    IL_043f:  ldarg.0
    IL_0440:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_0445:  call       class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_InsertPictureHS()
    IL_044a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_044f:  nop
//000128:             this.btnLoadImage.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_0450:  ldarg.0
    IL_0451:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_0456:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_045b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0460:  nop
//000129:             this.btnLoadImage.Name = "btnLoadImage";
    IL_0461:  ldarg.0
    IL_0462:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_0467:  ldstr      "btnLoadImage"
    IL_046c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0471:  nop
//000130:             this.btnLoadImage.Size = new System.Drawing.Size(89, 22);
    IL_0472:  ldarg.0
    IL_0473:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_0478:  ldc.i4.s   89
    IL_047a:  ldc.i4.s   22
    IL_047c:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0481:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0486:  nop
//000131:             this.btnLoadImage.Text = "&Load Image";
    IL_0487:  ldarg.0
    IL_0488:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_048d:  ldstr      "&Load Image"
    IL_0492:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0497:  nop
//000132:             this.btnLoadImage.Click += new System.EventHandler(this.btnLoadImage_Click);
    IL_0498:  ldarg.0
    IL_0499:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_049e:  ldarg.0
    IL_049f:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage_Click(object,
                                                                                                                                   class [mscorlib]System.EventArgs)
    IL_04a5:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_04aa:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_04af:  nop
//000133:             // 
//000134:             // btnSaveImage
//000135:             // 
//000136:             this.btnSaveImage.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.saveHS;
    IL_04b0:  ldarg.0
    IL_04b1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_04b6:  call       class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_saveHS()
    IL_04bb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_04c0:  nop
//000137:             this.btnSaveImage.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_04c1:  ldarg.0
    IL_04c2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_04c7:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_04cc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_04d1:  nop
//000138:             this.btnSaveImage.Name = "btnSaveImage";
    IL_04d2:  ldarg.0
    IL_04d3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_04d8:  ldstr      "btnSaveImage"
    IL_04dd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_04e2:  nop
//000139:             this.btnSaveImage.Size = new System.Drawing.Size(87, 22);
    IL_04e3:  ldarg.0
    IL_04e4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_04e9:  ldc.i4.s   87
    IL_04eb:  ldc.i4.s   22
    IL_04ed:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_04f2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_04f7:  nop
//000140:             this.btnSaveImage.Text = "&Save Image";
    IL_04f8:  ldarg.0
    IL_04f9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_04fe:  ldstr      "&Save Image"
    IL_0503:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0508:  nop
//000141:             this.btnSaveImage.Click += new System.EventHandler(this.btnSaveImage_Click);
    IL_0509:  ldarg.0
    IL_050a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_050f:  ldarg.0
    IL_0510:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage_Click(object,
                                                                                                                                   class [mscorlib]System.EventArgs)
    IL_0516:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_051b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0520:  nop
//000142:             // 
//000143:             // separator1
//000144:             // 
//000145:             this.separator1.Name = "separator1";
    IL_0521:  ldarg.0
    IL_0522:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
    IL_0527:  ldstr      "separator1"
    IL_052c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0531:  nop
//000146:             this.separator1.Size = new System.Drawing.Size(6, 25);
    IL_0532:  ldarg.0
    IL_0533:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
    IL_0538:  ldc.i4.6
    IL_0539:  ldc.i4.s   25
    IL_053b:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0540:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0545:  nop
//000147:             // 
//000148:             // tbEpsilon
//000149:             // 
//000150:             this.tbEpsilon.BackColor = System.Drawing.SystemColors.Control;
    IL_0546:  ldarg.0
    IL_0547:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_054c:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.SystemColors::get_Control()
    IL_0551:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0556:  nop
//000151:             this.tbEpsilon.Maximum = 180;
    IL_0557:  ldarg.0
    IL_0558:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_055d:  ldc.i4     0xb4
    IL_0562:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Maximum(int32)
    IL_0567:  nop
//000152:             this.tbEpsilon.Name = "tbEpsilon";
    IL_0568:  ldarg.0
    IL_0569:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_056e:  ldstr      "tbEpsilon"
    IL_0573:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0578:  nop
//000153:             this.tbEpsilon.Size = new System.Drawing.Size(150, 22);
    IL_0579:  ldarg.0
    IL_057a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_057f:  ldc.i4     0x96
    IL_0584:  ldc.i4.s   22
    IL_0586:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_058b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0590:  nop
//000154:             this.tbEpsilon.Text = "toolStripTrackBar1";
    IL_0591:  ldarg.0
    IL_0592:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_0597:  ldstr      "toolStripTrackBar1"
    IL_059c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_05a1:  nop
//000155:             this.tbEpsilon.Value = 15;
    IL_05a2:  ldarg.0
    IL_05a3:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_05a8:  ldc.i4.s   15
    IL_05aa:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Value(int32)
    IL_05af:  nop
//000156:             this.tbEpsilon.ValueChanged += new System.EventHandler(this.tbEpsilon_ValueChanged);
    IL_05b0:  ldarg.0
    IL_05b1:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_05b6:  ldarg.0
    IL_05b7:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon_ValueChanged(object,
                                                                                                                                       class [mscorlib]System.EventArgs)
    IL_05bd:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_05c2:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    IL_05c7:  nop
//000157:             // 
//000158:             // separator2
//000159:             // 
//000160:             this.separator2.Name = "separator2";
    IL_05c8:  ldarg.0
    IL_05c9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
    IL_05ce:  ldstr      "separator2"
    IL_05d3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_05d8:  nop
//000161:             this.separator2.Size = new System.Drawing.Size(6, 25);
    IL_05d9:  ldarg.0
    IL_05da:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
    IL_05df:  ldc.i4.6
    IL_05e0:  ldc.i4.s   25
    IL_05e2:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_05e7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_05ec:  nop
//000162:             // 
//000163:             // btnParallel
//000164:             // 
//000165:             this.btnParallel.CheckOnClick = true;
    IL_05ed:  ldarg.0
    IL_05ee:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_05f3:  ldc.i4.1
    IL_05f4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::set_CheckOnClick(bool)
    IL_05f9:  nop
//000166:             this.btnParallel.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
    IL_05fa:  ldarg.0
    IL_05fb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_0600:  ldc.i4.2
    IL_0601:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_DisplayStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemDisplayStyle)
    IL_0606:  nop
//000167:             this.btnParallel.Image = ((System.Drawing.Image)(resources.GetObject("btnParallel.Image")));
    IL_0607:  ldarg.0
    IL_0608:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_060d:  ldloc.0
    IL_060e:  ldstr      "btnParallel.Image"
    IL_0613:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_0618:  castclass  [System.Drawing]System.Drawing.Image
    IL_061d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_0622:  nop
//000168:             this.btnParallel.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_0623:  ldarg.0
    IL_0624:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_0629:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_062e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0633:  nop
//000169:             this.btnParallel.Name = "btnParallel";
    IL_0634:  ldarg.0
    IL_0635:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_063a:  ldstr      "btnParallel"
    IL_063f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0644:  nop
//000170:             this.btnParallel.Size = new System.Drawing.Size(23, 22);
    IL_0645:  ldarg.0
    IL_0646:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_064b:  ldc.i4.s   23
    IL_064d:  ldc.i4.s   22
    IL_064f:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0654:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0659:  nop
//000171:             this.btnParallel.Text = "btnParallel";
    IL_065a:  ldarg.0
    IL_065b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_0660:  ldstr      "btnParallel"
    IL_0665:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_066a:  nop
//000172:             this.btnParallel.CheckedChanged += new System.EventHandler(this.btnParallel_CheckedChanged);
    IL_066b:  ldarg.0
    IL_066c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
    IL_0671:  ldarg.0
    IL_0672:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel_CheckedChanged(object,
                                                                                                                                           class [mscorlib]System.EventArgs)
    IL_0678:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_067d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::add_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_0682:  nop
//000173:             // 
//000174:             // btnInk
//000175:             // 
//000176:             this.btnInk.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
    IL_0683:  ldarg.0
    IL_0684:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_0689:  ldc.i4.2
    IL_068a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_DisplayStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemDisplayStyle)
    IL_068f:  nop
//000177:             this.btnInk.Enabled = false;
    IL_0690:  ldarg.0
    IL_0691:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_0696:  ldc.i4.0
    IL_0697:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_069c:  nop
//000178:             this.btnInk.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.pen;
    IL_069d:  ldarg.0
    IL_069e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_06a3:  call       class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_pen()
    IL_06a8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_06ad:  nop
//000179:             this.btnInk.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_06ae:  ldarg.0
    IL_06af:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_06b4:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_06b9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_06be:  nop
//000180:             this.btnInk.Name = "btnInk";
    IL_06bf:  ldarg.0
    IL_06c0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_06c5:  ldstr      "btnInk"
    IL_06ca:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_06cf:  nop
//000181:             this.btnInk.Size = new System.Drawing.Size(23, 22);
    IL_06d0:  ldarg.0
    IL_06d1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_06d6:  ldc.i4.s   23
    IL_06d8:  ldc.i4.s   22
    IL_06da:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_06df:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_06e4:  nop
//000182:             this.btnInk.Text = "btnInk";
    IL_06e5:  ldarg.0
    IL_06e6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_06eb:  ldstr      "btnInk"
    IL_06f0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_06f5:  nop
//000183:             this.btnInk.Click += new System.EventHandler(this.btnInk_Click);
    IL_06f6:  ldarg.0
    IL_06f7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_06fc:  ldarg.0
    IL_06fd:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk_Click(object,
                                                                                                                             class [mscorlib]System.EventArgs)
    IL_0703:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0708:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_070d:  nop
//000184:             // 
//000185:             // btnEraser
//000186:             // 
//000187:             this.btnEraser.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
    IL_070e:  ldarg.0
    IL_070f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0714:  ldc.i4.2
    IL_0715:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_DisplayStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemDisplayStyle)
    IL_071a:  nop
//000188:             this.btnEraser.Enabled = false;
    IL_071b:  ldarg.0
    IL_071c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0721:  ldc.i4.0
    IL_0722:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0727:  nop
//000189:             this.btnEraser.Image = global::Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.eraser;
    IL_0728:  ldarg.0
    IL_0729:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_072e:  call       class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_eraser()
    IL_0733:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_0738:  nop
//000190:             this.btnEraser.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_0739:  ldarg.0
    IL_073a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_073f:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_0744:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0749:  nop
//000191:             this.btnEraser.Name = "btnEraser";
    IL_074a:  ldarg.0
    IL_074b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0750:  ldstr      "btnEraser"
    IL_0755:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_075a:  nop
//000192:             this.btnEraser.Size = new System.Drawing.Size(23, 22);
    IL_075b:  ldarg.0
    IL_075c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0761:  ldc.i4.s   23
    IL_0763:  ldc.i4.s   22
    IL_0765:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_076a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_076f:  nop
//000193:             this.btnEraser.Text = "btnEraser";
    IL_0770:  ldarg.0
    IL_0771:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0776:  ldstr      "btnEraser"
    IL_077b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0780:  nop
//000194:             this.btnEraser.Click += new System.EventHandler(this.btnEraser_Click);
    IL_0781:  ldarg.0
    IL_0782:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0787:  ldarg.0
    IL_0788:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser_Click(object,
                                                                                                                                class [mscorlib]System.EventArgs)
    IL_078e:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0793:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0798:  nop
//000195:             // 
//000196:             // pbColorizing
//000197:             // 
//000198:             this.pbColorizing.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
    IL_0799:  ldarg.0
    IL_079a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_079f:  ldc.i4.1
    IL_07a0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Alignment(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemAlignment)
    IL_07a5:  nop
//000199:             this.pbColorizing.Name = "pbColorizing";
    IL_07a6:  ldarg.0
    IL_07a7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_07ac:  ldstr      "pbColorizing"
    IL_07b1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_07b6:  nop
//000200:             this.pbColorizing.Overflow = System.Windows.Forms.ToolStripItemOverflow.Never;
    IL_07b7:  ldarg.0
    IL_07b8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_07bd:  ldc.i4.0
    IL_07be:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Overflow(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemOverflow)
    IL_07c3:  nop
//000201:             this.pbColorizing.Size = new System.Drawing.Size(140, 22);
    IL_07c4:  ldarg.0
    IL_07c5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_07ca:  ldc.i4     0x8c
    IL_07cf:  ldc.i4.s   22
    IL_07d1:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_07d6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_07db:  nop
//000202:             this.pbColorizing.Visible = false;
    IL_07dc:  ldarg.0
    IL_07dd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_07e2:  ldc.i4.0
    IL_07e3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Visible(bool)
    IL_07e8:  nop
//000203:             // 
//000204:             // lblHuesSelected
//000205:             // 
//000206:             this.lblHuesSelected.Name = "lblHuesSelected";
    IL_07e9:  ldarg.0
    IL_07ea:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_07ef:  ldstr      "lblHuesSelected"
    IL_07f4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_07f9:  nop
//000207:             this.lblHuesSelected.Size = new System.Drawing.Size(81, 15);
    IL_07fa:  ldarg.0
    IL_07fb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_0800:  ldc.i4.s   81
    IL_0802:  ldc.i4.s   15
    IL_0804:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0809:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_080e:  nop
//000208:             this.lblHuesSelected.Text = "Hues Selected";
    IL_080f:  ldarg.0
    IL_0810:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_0815:  ldstr      "Hues Selected"
    IL_081a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_081f:  nop
//000209:             this.lblHuesSelected.Click += new System.EventHandler(this.lblHuesSelected_Click);
    IL_0820:  ldarg.0
    IL_0821:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_0826:  ldarg.0
    IL_0827:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected_Click(object,
                                                                                                                                      class [mscorlib]System.EventArgs)
    IL_082d:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0832:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0837:  nop
//000210:             // 
//000211:             // MainForm
//000212:             // 
//000213:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
    IL_0838:  ldarg.0
    IL_0839:  ldc.r4     6.
    IL_083e:  ldc.r4     13.
    IL_0843:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_0848:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_084d:  nop
//000214:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    IL_084e:  ldarg.0
    IL_084f:  ldc.i4.1
    IL_0850:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_0855:  nop
//000215:             this.ClientSize = new System.Drawing.Size(619, 422);
    IL_0856:  ldarg.0
    IL_0857:  ldc.i4     0x26b
    IL_085c:  ldc.i4     0x1a6
    IL_0861:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0866:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_086b:  nop
//000216:             this.Controls.Add(this.toolStripContainer);
    IL_086c:  ldarg.0
    IL_086d:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0872:  ldarg.0
    IL_0873:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0878:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_087d:  nop
//000217:             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
    IL_087e:  ldarg.0
    IL_087f:  ldloc.0
    IL_0880:  ldstr      "$this.Icon"
    IL_0885:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_088a:  castclass  [System.Drawing]System.Drawing.Icon
    IL_088f:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_Icon(class [System.Drawing]System.Drawing.Icon)
    IL_0894:  nop
//000218:             this.KeyPreview = true;
    IL_0895:  ldarg.0
    IL_0896:  ldc.i4.1
    IL_0897:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_KeyPreview(bool)
    IL_089c:  nop
//000219:             this.Name = "MainForm";
    IL_089d:  ldarg.0
    IL_089e:  ldstr      "MainForm"
    IL_08a3:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_08a8:  nop
//000220:             this.Text = "Image Colorizer";
    IL_08a9:  ldarg.0
    IL_08aa:  ldstr      "Image Colorizer"
    IL_08af:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_08b4:  nop
//000221:             this.Load += new System.EventHandler(this.MainForm_Load);
    IL_08b5:  ldarg.0
    IL_08b6:  ldarg.0
    IL_08b7:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::MainForm_Load(object,
                                                                                                                              class [mscorlib]System.EventArgs)
    IL_08bd:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_08c2:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::add_Load(class [mscorlib]System.EventHandler)
    IL_08c7:  nop
//000222:             this.toolStripContainer.ContentPanel.ResumeLayout(false);
    IL_08c8:  ldarg.0
    IL_08c9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_08ce:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_08d3:  ldc.i4.0
    IL_08d4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_08d9:  nop
//000223:             this.toolStripContainer.TopToolStripPanel.ResumeLayout(false);
    IL_08da:  ldarg.0
    IL_08db:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_08e0:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_08e5:  ldc.i4.0
    IL_08e6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_08eb:  nop
//000224:             this.toolStripContainer.TopToolStripPanel.PerformLayout();
    IL_08ec:  ldarg.0
    IL_08ed:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_08f2:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_08f7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_08fc:  nop
//000225:             this.toolStripContainer.ResumeLayout(false);
    IL_08fd:  ldarg.0
    IL_08fe:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0903:  ldc.i4.0
    IL_0904:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0909:  nop
//000226:             this.toolStripContainer.PerformLayout();
    IL_090a:  ldarg.0
    IL_090b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0910:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_0915:  nop
//000227:             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
    IL_0916:  ldarg.0
    IL_0917:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_091c:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_0921:  nop
//000228:             this.toolStripMain.ResumeLayout(false);
    IL_0922:  ldarg.0
    IL_0923:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0928:  ldc.i4.0
    IL_0929:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_092e:  nop
//000229:             this.toolStripMain.PerformLayout();
    IL_092f:  ldarg.0
    IL_0930:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0935:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_093a:  nop
//000230:             this.ResumeLayout(false);
    IL_093b:  ldarg.0
    IL_093c:  ldc.i4.0
    IL_093d:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0942:  nop
//000231: 
//000232:         }
    IL_0943:  ret
  } // end of method MainForm::InitializeComponent

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       55 (0x37)
    .maxstack  8
//000008:         private System.ComponentModel.IContainer components = null;
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  stfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs' 
//000033:         private List<Point> _selectedPixels = new List<Point>();
    IL_0007:  ldarg.0
    IL_0008:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::.ctor()
    IL_000d:  stfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
//000034:         /// <summary>The last hue epsilon selected by the user.</summary>
//000035:         private int _lastEpsilon = -1;
    IL_0012:  ldarg.0
    IL_0013:  ldc.i4.m1
    IL_0014:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
//000036:         /// <summary>The last size of the image picture box before a resize.</summary>
//000037:         private Size _lastPictureBoxSize = new Size(-1, -1);
    IL_0019:  ldarg.0
    IL_001a:  ldc.i4.m1
    IL_001b:  ldc.i4.m1
    IL_001c:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0021:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
//000027:         public MainForm()
    IL_0026:  ldarg.0
    IL_0027:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_002c:  nop
//000028:         {
    IL_002d:  nop
//000029:             InitializeComponent();
    IL_002e:  ldarg.0
    IL_002f:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InitializeComponent()
    IL_0034:  nop
//000030:         }
    IL_0035:  nop
    IL_0036:  ret
  } // end of method MainForm::.ctor

  .method private hidebysig instance void 
          MainForm_Load(object sender,
                        class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       127 (0x7f)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000031: 
//000032:         /// <summary>A list of all selected points from which colors will be extracted from the image.</summary>
//000033:         private List<Point> _selectedPixels = new List<Point>();
//000034:         /// <summary>The last hue epsilon selected by the user.</summary>
//000035:         private int _lastEpsilon = -1;
//000036:         /// <summary>The last size of the image picture box before a resize.</summary>
//000037:         private Size _lastPictureBoxSize = new Size(-1, -1);
//000038:         /// <summary>A list of GraphicsPaths currently translated from Strokes.</summary>
//000039:         private List<GraphicsPath> _paths;
//000040:         /// <summary>The image as originally loaded.</summary>
//000041:         private Bitmap _originalImage;
//000042:         /// <summary>The current image after all color transformations.</summary>
//000043:         private Bitmap _colorizedImage;
//000044:         /// <summary>The InkOverlay used for accepting strokes to be translated into GraphicsPaths.</summary>
//000045:         private InkOverlay _overlay;
//000046: 
//000047:         /// <summary>Loads the form.</summary>
//000048:         private void MainForm_Load(object sender, EventArgs e)
//000049:         {
    IL_0000:  nop
//000050:             // Store the current size of the picture box.  When the picture box is
//000051:             // resized (due to the form being resized), we need to scale any ink
//000052:             // that may exist on the form so that it sizes in accordance with the picture box.
//000053:             _lastPictureBoxSize = pbImage.Size;
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0008:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_000d:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
//000054:             pbImage.AllowDrop = true;
    IL_0012:  ldarg.0
    IL_0013:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0018:  ldc.i4.1
    IL_0019:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AllowDrop(bool)
    IL_001e:  nop
//000055: 
//000056:             // If the current platform supports ink, initialize the InkOverlay
//000057:             if (PlatformDetection.SupportsInk) InitializeInk();
    IL_001f:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
    IL_0024:  ldc.i4.0
    IL_0025:  ceq
    IL_0027:  stloc.0
//000058: 
//000059:             // Setup the help text for the toolstrip
//000060:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000061:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay,  tbEpsilon.Value);
//000062:         }
//000063: 
//000064:         OpenFileDialog _ofd;
//000065: 
//000066:         /// <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
//000067:         private void btnLoadImage_Click(object sender, EventArgs e)
//000068:         {
//000069:             // Show a dialog to select JPG files
//000070:             if (_ofd == null)
//000071:             {
//000072:                 _ofd = new OpenFileDialog();
//000073:                 _ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif";
//000074:                 _ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
//000075:             }
//000076:             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
//000077:         }
//000078: 
//000079:         private void LoadImage(string path)
//000080:         {
//000081:             try
//000082:             {
//000083:                 _originalImage = new Bitmap(path);
//000084:                 pbImage.Image = _originalImage;
//000085: 
//000086:                 // Disable saving of the image.  We only allow saving once changes have been made.
//000087:                 btnSaveImage.Enabled = false;
//000088: 
//000089:                 // Change the cursor on the picture box to let the user know they
//000090:                 // can click on the image to select a hue.
//000091:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
//000092: 
//000093:                 // If ink is available on the current machine, enable the button that
//000094:                 // turns on the overlay, and clear any existing ink from previous images
//000095:                 // that may have existed in the app
//000096:                 if (PlatformDetection.SupportsInk)
//000097:                 {
//000098:                     btnInk.Enabled = true;
//000099:                     ClearInk();
//000100:                 }
//000101:             }
//000102:             catch (ArgumentException) { }
//000103:         }
//000104: 
//000105:         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
//000106:         private void pbImage_MouseClick(object sender, MouseEventArgs e)
//000107:         {
//000108:             // Only run if an image has been loaded and if ink isn't being drawn
//000109:             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
//000110:             {
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0028:  ldloc.0
    IL_0029:  brtrue.s   IL_0032

//000057:             if (PlatformDetection.SupportsInk) InitializeInk();
    IL_002b:  ldarg.0
    IL_002c:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InitializeInk()
    IL_0031:  nop
//000058: 
//000059:             // Setup the help text for the toolstrip
//000060:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
    IL_0032:  ldarg.0
    IL_0033:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_0038:  call       string Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_HuesSelectedDisplay()
    IL_003d:  ldarg.0
    IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_0043:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0048:  box        [mscorlib]System.Int32
    IL_004d:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0052:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0057:  nop
//000061:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay,  tbEpsilon.Value);
    IL_0058:  ldarg.0
    IL_0059:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_005e:  call       string Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_EpsilonDisplay()
    IL_0063:  ldarg.0
    IL_0064:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_0069:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
    IL_006e:  box        [mscorlib]System.Int32
    IL_0073:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0078:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ToolTipText(string)
    IL_007d:  nop
//000062:         }
    IL_007e:  ret
  } // end of method MainForm::MainForm_Load

  .method private hidebysig instance void 
          btnLoadImage_Click(object sender,
                             class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       106 (0x6a)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000063: 
//000064:         OpenFileDialog _ofd;
//000065: 
//000066:         /// <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
//000067:         private void btnLoadImage_Click(object sender, EventArgs e)
//000068:         {
    IL_0000:  nop
//000069:             // Show a dialog to select JPG files
//000070:             if (_ofd == null)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.0
//000071:             {
//000072:                 _ofd = new OpenFileDialog();
//000073:                 _ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif";
//000074:                 _ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
//000075:             }
//000076:             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
//000077:         }
//000078: 
//000079:         private void LoadImage(string path)
//000080:         {
//000081:             try
//000082:             {
//000083:                 _originalImage = new Bitmap(path);
//000084:                 pbImage.Image = _originalImage;
//000085: 
//000086:                 // Disable saving of the image.  We only allow saving once changes have been made.
//000087:                 btnSaveImage.Enabled = false;
//000088: 
//000089:                 // Change the cursor on the picture box to let the user know they
//000090:                 // can click on the image to select a hue.
//000091:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
//000092: 
//000093:                 // If ink is available on the current machine, enable the button that
//000094:                 // turns on the overlay, and clear any existing ink from previous images
//000095:                 // that may have existed in the app
//000096:                 if (PlatformDetection.SupportsInk)
//000097:                 {
//000098:                     btnInk.Enabled = true;
//000099:                     ClearInk();
//000100:                 }
//000101:             }
//000102:             catch (ArgumentException) { }
//000103:         }
//000104: 
//000105:         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
//000106:         private void pbImage_MouseClick(object sender, MouseEventArgs e)
//000107:         {
//000108:             // Only run if an image has been loaded and if ink isn't being drawn
//000109:             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
//000110:             {
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_000e:  ldloc.0
    IL_000f:  brtrue.s   IL_0042

//000071:             {
    IL_0011:  nop
//000072:                 _ofd = new OpenFileDialog();
    IL_0012:  ldarg.0
    IL_0013:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.OpenFileDialog::.ctor()
    IL_0018:  stfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
//000073:                 _ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif";
    IL_001d:  ldarg.0
    IL_001e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0023:  ldstr      "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.b"
    + "mp;*.png;*.gif"
    IL_0028:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
    IL_002d:  nop
//000074:                 _ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
    IL_002e:  ldarg.0
    IL_002f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0034:  ldc.i4.s   39
    IL_0036:  call       string [mscorlib]System.Environment::GetFolderPath(valuetype [mscorlib]System.Environment/SpecialFolder)
    IL_003b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_InitialDirectory(string)
    IL_0040:  nop
//000075:             }
    IL_0041:  nop
//000076:             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
    IL_0042:  ldarg.0
    IL_0043:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0048:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog()
    IL_004d:  ldc.i4.1
    IL_004e:  ceq
    IL_0050:  ldc.i4.0
    IL_0051:  ceq
    IL_0053:  stloc.0
//000077:         }
//000078: 
//000079:         private void LoadImage(string path)
//000080:         {
//000081:             try
//000082:             {
//000083:                 _originalImage = new Bitmap(path);
//000084:                 pbImage.Image = _originalImage;
//000085: 
//000086:                 // Disable saving of the image.  We only allow saving once changes have been made.
//000087:                 btnSaveImage.Enabled = false;
//000088: 
//000089:                 // Change the cursor on the picture box to let the user know they
//000090:                 // can click on the image to select a hue.
//000091:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
//000092: 
//000093:                 // If ink is available on the current machine, enable the button that
//000094:                 // turns on the overlay, and clear any existing ink from previous images
//000095:                 // that may have existed in the app
//000096:                 if (PlatformDetection.SupportsInk)
//000097:                 {
//000098:                     btnInk.Enabled = true;
//000099:                     ClearInk();
//000100:                 }
//000101:             }
//000102:             catch (ArgumentException) { }
//000103:         }
//000104: 
//000105:         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
//000106:         private void pbImage_MouseClick(object sender, MouseEventArgs e)
//000107:         {
//000108:             // Only run if an image has been loaded and if ink isn't being drawn
//000109:             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
//000110:             {
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0054:  ldloc.0
    IL_0055:  brtrue.s   IL_0069

//000076:             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
    IL_0057:  ldarg.0
    IL_0058:  ldarg.0
    IL_0059:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_005e:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.FileDialog::get_FileName()
    IL_0063:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::LoadImage(string)
    IL_0068:  nop
//000077:         }
    IL_0069:  ret
  } // end of method MainForm::btnLoadImage_Click

  .method private hidebysig instance void 
          LoadImage(string path) cil managed
  {
    // Code size       106 (0x6a)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000078: 
//000079:         private void LoadImage(string path)
//000080:         {
    IL_0000:  nop
//000081:             try
//000082:             {
    .try
    {
      IL_0001:  nop
//000083:                 _originalImage = new Bitmap(path);
      IL_0002:  ldarg.0
      IL_0003:  ldarg.1
      IL_0004:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(string)
      IL_0009:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
//000084:                 pbImage.Image = _originalImage;
      IL_000e:  ldarg.0
      IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
      IL_0014:  ldarg.0
      IL_0015:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
      IL_001a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
      IL_001f:  nop
//000085: 
//000086:                 // Disable saving of the image.  We only allow saving once changes have been made.
//000087:                 btnSaveImage.Enabled = false;
      IL_0020:  ldarg.0
      IL_0021:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
      IL_0026:  ldc.i4.0
      IL_0027:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
      IL_002c:  nop
//000088: 
//000089:                 // Change the cursor on the picture box to let the user know they
//000090:                 // can click on the image to select a hue.
//000091:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
      IL_002d:  ldarg.0
      IL_002e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
      IL_0033:  call       class [System.Windows.Forms]System.Windows.Forms.Cursor [System.Windows.Forms]System.Windows.Forms.Cursors::get_Hand()
      IL_0038:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Cursor(class [System.Windows.Forms]System.Windows.Forms.Cursor)
      IL_003d:  nop
//000092: 
//000093:                 // If ink is available on the current machine, enable the button that
//000094:                 // turns on the overlay, and clear any existing ink from previous images
//000095:                 // that may have existed in the app
//000096:                 if (PlatformDetection.SupportsInk)
      IL_003e:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
      IL_0043:  ldc.i4.0
      IL_0044:  ceq
      IL_0046:  stloc.0
//000097:                 {
//000098:                     btnInk.Enabled = true;
//000099:                     ClearInk();
//000100:                 }
//000101:             }
//000102:             catch (ArgumentException) { }
//000103:         }
//000104: 
//000105:         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
//000106:         private void pbImage_MouseClick(object sender, MouseEventArgs e)
//000107:         {
//000108:             // Only run if an image has been loaded and if ink isn't being drawn
//000109:             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
//000110:             {
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
      IL_0047:  ldloc.0
      IL_0048:  brtrue.s   IL_0060

//000097:                 {
      IL_004a:  nop
//000098:                     btnInk.Enabled = true;
      IL_004b:  ldarg.0
      IL_004c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
      IL_0051:  ldc.i4.1
      IL_0052:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
      IL_0057:  nop
//000099:                     ClearInk();
      IL_0058:  ldarg.0
      IL_0059:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::ClearInk()
      IL_005e:  nop
//000100:                 }
      IL_005f:  nop
//000101:             }
      IL_0060:  nop
//000102:             catch (ArgumentException) { }
//000103:         }
//000104: 
//000105:         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
//000106:         private void pbImage_MouseClick(object sender, MouseEventArgs e)
//000107:         {
//000108:             // Only run if an image has been loaded and if ink isn't being drawn
//000109:             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
//000110:             {
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
      IL_0061:  leave.s    IL_0068

//000102:             catch (ArgumentException) { }
    }  // end .try
    catch [mscorlib]System.ArgumentException 
    {
      IL_0063:  pop
      IL_0064:  nop
      IL_0065:  nop
//000103:         }
//000104: 
//000105:         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
//000106:         private void pbImage_MouseClick(object sender, MouseEventArgs e)
//000107:         {
//000108:             // Only run if an image has been loaded and if ink isn't being drawn
//000109:             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
//000110:             {
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
      IL_0066:  leave.s    IL_0068

    }  // end handler
    IL_0068:  nop
//000103:         }
    IL_0069:  ret
  } // end of method MainForm::LoadImage

  .method private hidebysig instance void 
          pbImage_MouseClick(object sender,
                             class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       209 (0xd1)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Point p,
             [1] bool CS$4$0000)
//000104: 
//000105:         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
//000106:         private void pbImage_MouseClick(object sender, MouseEventArgs e)
//000107:         {
    IL_0000:  nop
//000108:             // Only run if an image has been loaded and if ink isn't being drawn
//000109:             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0007:  brfalse.s  IL_0026

    IL_0009:  ldarg.0
    IL_000a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_000f:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripItem::get_Enabled()
    IL_0014:  brfalse.s  IL_0023

    IL_0016:  ldarg.0
    IL_0017:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_001c:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripButton::get_Checked()
    IL_0021:  br.s       IL_0024

    IL_0023:  ldc.i4.0
    IL_0024:  br.s       IL_0027

    IL_0026:  ldc.i4.1
    IL_0027:  stloc.1
//000110:             {
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0028:  ldloc.1
    IL_0029:  brtrue     IL_00d0

//000110:             {
    IL_002e:  nop
//000111:                 // Get the point in the original image.  To get this we need
//000112:                 // to scale the selected point based on how much the image
//000113:                 // is being resized for display.
//000114:                 Point p = new Point(
    IL_002f:  ldloca.s   p
    IL_0031:  ldarg.2
    IL_0032:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_X()
    IL_0037:  ldarg.0
    IL_0038:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_003d:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0042:  mul
    IL_0043:  conv.r8
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_004a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_004f:  conv.r8
    IL_0050:  div
    IL_0051:  conv.i4
    IL_0052:  ldarg.2
    IL_0053:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Y()
    IL_0058:  ldarg.0
    IL_0059:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_005e:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0063:  mul
    IL_0064:  conv.r8
    IL_0065:  ldarg.0
    IL_0066:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_006b:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0070:  conv.r8
    IL_0071:  div
    IL_0072:  conv.i4
    IL_0073:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0078:  nop
//000115:                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
//000116:                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
//000117: 
//000118:                 // Add the selected point to the list or make it the only
//000119:                 // point in the list, based on whether the shift key is being held down
//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
    IL_0079:  call       valuetype [System.Windows.Forms]System.Windows.Forms.Keys [System.Windows.Forms]System.Windows.Forms.Control::get_ModifierKeys()
    IL_007e:  ldc.i4     0x10000
    IL_0083:  ceq
    IL_0085:  stloc.1
//000121:                 _selectedPixels.Add(p);
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
//000129:             }
//000130:         }
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
//000137:             _lastEpsilon = tbEpsilon.Value;
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0086:  ldloc.1
    IL_0087:  brtrue.s   IL_0095

//000120:                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
    IL_0089:  ldarg.0
    IL_008a:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_008f:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::Clear()
    IL_0094:  nop
//000121:                 _selectedPixels.Add(p);
    IL_0095:  ldarg.0
    IL_0096:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_009b:  ldloc.0
    IL_009c:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::Add(!0)
    IL_00a1:  nop
//000122: 
//000123:                 // With our updated list of selected pixels in hand, update
//000124:                 // the toolstrip help text
//000125:                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
    IL_00a2:  ldarg.0
    IL_00a3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_00a8:  call       string Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_HuesSelectedDisplay()
    IL_00ad:  ldarg.0
    IL_00ae:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_00b3:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_00b8:  box        [mscorlib]System.Int32
    IL_00bd:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_00c2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_00c7:  nop
//000126: 
//000127:                 // Start recomputing the image based on the new parameters
//000128:                 StartColorizeImage();
    IL_00c8:  ldarg.0
    IL_00c9:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartColorizeImage()
    IL_00ce:  nop
//000129:             }
    IL_00cf:  nop
//000130:         }
    IL_00d0:  ret
  } // end of method MainForm::pbImage_MouseClick

  .method private hidebysig instance void 
          StartColorizeImage() cil managed
  {
    // Code size       241 (0xf1)
    .maxstack  3
    .locals init ([0] class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath path,
             [1] bool CS$4$0000,
             [2] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> CS$5$0001)
//000131: 
//000132:         private void StartColorizeImage()
//000133:         {
    IL_0000:  nop
//000134:             // Stop the timer if it's running, since the timer's purpose
//000135:             // is to cause this method to be called when the timer expires
//000136:             tmRefresh.Stop();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh
    IL_0007:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Stop()
    IL_000c:  nop
//000137:             _lastEpsilon = tbEpsilon.Value;
    IL_000d:  ldarg.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_0014:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
    IL_0019:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
//000138: 
//000139:             // If we have an image and if a pixel has been selected
//000140:             // and if we're not currently recomputing the image...
//000141:             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0024:  brfalse.s  IL_0041

    IL_0026:  ldarg.0
    IL_0027:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_002c:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0031:  ldc.i4.0
    IL_0032:  ble.s      IL_0041

    IL_0034:  ldarg.0
    IL_0035:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_003a:  callvirt   instance bool [System]System.ComponentModel.BackgroundWorker::get_IsBusy()
    IL_003f:  br.s       IL_0042

    IL_0041:  ldc.i4.1
    IL_0042:  stloc.1
//000142:             {
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0043:  ldloc.1
    IL_0044:  brtrue     IL_00f0

//000142:             {
    IL_0049:  nop
//000143:                 // If there are any strokes, turn them into GraphicsPaths
//000144:                 if (PlatformDetection.SupportsInk)
    IL_004a:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
    IL_004f:  ldc.i4.0
    IL_0050:  ceq
    IL_0052:  stloc.1
//000145:                 {
//000146:                     if (_paths != null)
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0053:  ldloc.1
    IL_0054:  brtrue.s   IL_00af

//000145:                 {
    IL_0056:  nop
//000146:                     if (_paths != null)
    IL_0057:  ldarg.0
    IL_0058:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
    IL_005d:  ldnull
    IL_005e:  ceq
    IL_0060:  stloc.1
//000147:                     {
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0061:  ldloc.1
    IL_0062:  brtrue.s   IL_00a1

//000147:                     {
    IL_0064:  nop
//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
    IL_0065:  nop
    IL_0066:  ldarg.0
    IL_0067:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
    IL_006c:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::GetEnumerator()
    IL_0071:  stloc.2
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    .try
    {
      IL_0072:  br.s       IL_0083

//000148:                         foreach (GraphicsPath path in _paths) path.Dispose();
      IL_0074:  ldloca.s   CS$5$0001
      IL_0076:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Current()
      IL_007b:  stloc.0
      IL_007c:  ldloc.0
      IL_007d:  callvirt   instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::Dispose()
      IL_0082:  nop
      IL_0083:  ldloca.s   CS$5$0001
      IL_0085:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::MoveNext()
      IL_008a:  stloc.1
//000149:                     }
//000150:                     _paths = InkToGraphicsPaths(true);
//000151:                 }
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
//000155:                 pbImage.Enabled = false;
//000156:                 pbColorizing.Value = 0;
//000157:                 pbColorizing.Visible = true;
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
//000161:             }
//000162:         }
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
      IL_008b:  ldloc.1
      IL_008c:  brtrue.s   IL_0074

      IL_008e:  leave.s    IL_009f

    }  // end .try
    finally
    {
      IL_0090:  ldloca.s   CS$5$0001
      IL_0092:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>
      IL_0098:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_009d:  nop
      IL_009e:  endfinally
    }  // end handler
    IL_009f:  nop
//000149:                     }
    IL_00a0:  nop
//000150:                     _paths = InkToGraphicsPaths(true);
    IL_00a1:  ldarg.0
    IL_00a2:  ldarg.0
    IL_00a3:  ldc.i4.1
    IL_00a4:  call       instance class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InkToGraphicsPaths(bool)
    IL_00a9:  stfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
//000151:                 }
    IL_00ae:  nop
//000152: 
//000153:                 // Modify the UI for progress
//000154:                 toolStripMain.Enabled = false;
    IL_00af:  ldarg.0
    IL_00b0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_00b5:  ldc.i4.0
    IL_00b6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00bb:  nop
//000155:                 pbImage.Enabled = false;
    IL_00bc:  ldarg.0
    IL_00bd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00c2:  ldc.i4.0
    IL_00c3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00c8:  nop
//000156:                 pbColorizing.Value = 0;
    IL_00c9:  ldarg.0
    IL_00ca:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_00cf:  ldc.i4.0
    IL_00d0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::set_Value(int32)
    IL_00d5:  nop
//000157:                 pbColorizing.Visible = true;
    IL_00d6:  ldarg.0
    IL_00d7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_00dc:  ldc.i4.1
    IL_00dd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Visible(bool)
    IL_00e2:  nop
//000158: 
//000159:                 // Recompute the image!
//000160:                 bwColorize.RunWorkerAsync();
    IL_00e3:  ldarg.0
    IL_00e4:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_00e9:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::RunWorkerAsync()
    IL_00ee:  nop
//000161:             }
    IL_00ef:  nop
//000162:         }
    IL_00f0:  ret
  } // end of method MainForm::StartColorizeImage

  .method private hidebysig instance void 
          bwColorize_DoWork(object sender,
                            class [System]System.ComponentModel.DoWorkEventArgs e) cil managed
  {
    // Code size       137 (0x89)
    .maxstack  7
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation colorizer,
             [1] class [System.Drawing]System.Drawing.Bitmap workImage,
             [2] bool CS$4$0000)
//000163: 
//000164:         /// <summary>Colorizes the image on a background thread.</summary>
//000165:         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
//000166:         {
    IL_0000:  nop
//000167:             // Create the colorizer instance.  Any progress updates
//000168:             // will in turn update the progress through the BackgroundWorker.
//000169:             ImageManipulation colorizer = new ImageManipulation();
    IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::.ctor()
    IL_0006:  stloc.0
//000170:             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
    IL_0007:  ldloc.0
    IL_0008:  ldarg.0
    IL_0009:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<bwColorize_DoWork>b__0'(object,
                                                                                                                                          class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_000f:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventHandler::.ctor(object,
                                                                                                        native int)
    IL_0014:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    IL_0019:  nop
//000171:             {
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
    IL_001a:  ldarg.0
    IL_001b:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0020:  ldc.i4.0
    IL_0021:  ldc.i4.0
    IL_0022:  ldarg.0
    IL_0023:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0028:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_002d:  ldarg.0
    IL_002e:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0033:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0038:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                       int32,
                                                                                       int32,
                                                                                       int32)
    IL_003d:  ldc.i4     0x21808
    IL_0042:  callvirt   instance class [System.Drawing]System.Drawing.Bitmap [System.Drawing]System.Drawing.Bitmap::Clone(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                           valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
    IL_0047:  stloc.1
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
    .try
    {
      IL_0048:  nop
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
      IL_0049:  ldarg.2
      IL_004a:  ldloc.0
      IL_004b:  ldloc.1
      IL_004c:  ldarg.0
      IL_004d:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
      IL_0052:  ldarg.0
      IL_0053:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
      IL_0058:  ldarg.0
      IL_0059:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
      IL_005e:  ldarg.0
      IL_005f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel
      IL_0064:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripButton::get_Checked()
      IL_0069:  callvirt   instance class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::Colorize(class [System.Drawing]System.Drawing.Bitmap,
                                                                                                                                                                           class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>,
                                                                                                                                                                           int32,
                                                                                                                                                                           class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>,
                                                                                                                                                                           bool)
      IL_006e:  callvirt   instance void [System]System.ComponentModel.DoWorkEventArgs::set_Result(object)
      IL_0073:  nop
//000182:             }
      IL_0074:  nop
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
      IL_0075:  leave.s    IL_0087

    }  // end .try
    finally
    {
      IL_0077:  ldloc.1
      IL_0078:  ldnull
      IL_0079:  ceq
      IL_007b:  stloc.2
      IL_007c:  ldloc.2
      IL_007d:  brtrue.s   IL_0086

      IL_007f:  ldloc.1
      IL_0080:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0085:  nop
      IL_0086:  endfinally
    }  // end handler
    IL_0087:  nop
//000183:         }
    IL_0088:  ret
  } // end of method MainForm::bwColorize_DoWork

  .method private hidebysig instance void 
          bwColorize_RunWorkerCompleted(object sender,
                                        class [System]System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed
  {
    // Code size       222 (0xde)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
    IL_0000:  nop
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_0007:  ldc.i4.0
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Visible(bool)
    IL_000d:  nop
//000190:             toolStripMain.Enabled = true;
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0014:  ldc.i4.1
    IL_0015:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_001a:  nop
//000191:             pbImage.Enabled = true;
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0021:  ldc.i4.1
    IL_0022:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0027:  nop
//000192:             btnLoadImage.Enabled = true;
    IL_0028:  ldarg.0
    IL_0029:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_002e:  ldc.i4.1
    IL_002f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0034:  nop
//000193:             btnSaveImage.Enabled = true;
    IL_0035:  ldarg.0
    IL_0036:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage
    IL_003b:  ldc.i4.1
    IL_003c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0041:  nop
//000194:             tbEpsilon.Focus();
    IL_0042:  ldarg.0
    IL_0043:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_0048:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::Focus()
    IL_004d:  nop
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
    IL_004e:  ldarg.2
    IL_004f:  callvirt   instance class [mscorlib]System.Exception [System]System.ComponentModel.AsyncCompletedEventArgs::get_Error()
    IL_0054:  ldnull
    IL_0055:  ceq
    IL_0057:  stloc.0
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0058:  ldloc.0
    IL_0059:  brtrue.s   IL_0067

//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
    IL_005b:  ldarg.2
    IL_005c:  callvirt   instance class [mscorlib]System.Exception [System]System.ComponentModel.AsyncCompletedEventArgs::get_Error()
    IL_0061:  newobj     instance void [mscorlib]System.Reflection.TargetInvocationException::.ctor(class [mscorlib]System.Exception)
    IL_0066:  throw

//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
    IL_0067:  ldarg.0
    IL_0068:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_006d:  ldnull
    IL_006e:  ceq
    IL_0070:  stloc.0
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0071:  ldloc.0
    IL_0072:  brtrue.s   IL_0080

//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
    IL_0074:  ldarg.0
    IL_0075:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_007a:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_007f:  nop
//000201:             _colorizedImage = (Bitmap)e.Result;
    IL_0080:  ldarg.0
    IL_0081:  ldarg.2
    IL_0082:  callvirt   instance object [System]System.ComponentModel.RunWorkerCompletedEventArgs::get_Result()
    IL_0087:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_008c:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
    IL_0091:  ldarg.0
    IL_0092:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0097:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_009c:  brfalse.s  IL_00b3

    IL_009e:  ldarg.0
    IL_009f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00a4:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00a9:  ldarg.0
    IL_00aa:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_00af:  ceq
    IL_00b1:  br.s       IL_00b4

    IL_00b3:  ldc.i4.1
    IL_00b4:  stloc.0
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_00b5:  ldloc.0
    IL_00b6:  brtrue.s   IL_00cb

//000205:             {
    IL_00b8:  nop
//000206:                 pbImage.Image.Dispose();
    IL_00b9:  ldarg.0
    IL_00ba:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00bf:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00c4:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_00c9:  nop
//000207:             }
    IL_00ca:  nop
//000208:             pbImage.Image = _colorizedImage;
    IL_00cb:  ldarg.0
    IL_00cc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_00d1:  ldarg.0
    IL_00d2:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_00d7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_00dc:  nop
//000209:         }
    IL_00dd:  ret
  } // end of method MainForm::bwColorize_RunWorkerCompleted

  .method private hidebysig instance void 
          bwColorize_ProgressChanged(object sender,
                                     class [System]System.ComponentModel.ProgressChangedEventArgs e) cil managed
  {
    // Code size       46 (0x2e)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
    IL_0000:  nop
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance int32 [System]System.ComponentModel.ProgressChangedEventArgs::get_ProgressPercentage()
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_000d:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::get_Value()
    IL_0012:  cgt
    IL_0014:  ldc.i4.0
    IL_0015:  ceq
    IL_0017:  stloc.0
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0018:  ldloc.0
    IL_0019:  brtrue.s   IL_002d

//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_0021:  ldarg.2
    IL_0022:  callvirt   instance int32 [System]System.ComponentModel.ProgressChangedEventArgs::get_ProgressPercentage()
    IL_0027:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::set_Value(int32)
    IL_002c:  nop
//000215:         }
    IL_002d:  ret
  } // end of method MainForm::bwColorize_ProgressChanged

  .method private hidebysig instance void 
          btnSaveImage_Click(object sender,
                             class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       87 (0x57)
    .maxstack  3
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.SaveFileDialog sfd,
             [1] bool CS$4$0000)
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
    IL_0000:  nop
//000220:             if (_colorizedImage != null)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  stloc.1
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_000b:  ldloc.1
    IL_000c:  brtrue.s   IL_0056

//000221:             {
    IL_000e:  nop
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
    IL_000f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.SaveFileDialog::.ctor()
    IL_0014:  stloc.0
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
    IL_0015:  ldloc.0
    IL_0016:  ldstr      "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.b"
    + "mp;*.png;*.gif|All files (*.*)|*.*"
    IL_001b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
    IL_0020:  nop
//000224:                 sfd.DefaultExt = ".jpg";
    IL_0021:  ldloc.0
    IL_0022:  ldstr      ".jpg"
    IL_0027:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_DefaultExt(string)
    IL_002c:  nop
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
    IL_002d:  ldloc.0
    IL_002e:  ldarg.0
    IL_002f:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
    IL_0034:  ldc.i4.1
    IL_0035:  ceq
    IL_0037:  ldc.i4.0
    IL_0038:  ceq
    IL_003a:  stloc.1
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_003b:  ldloc.1
    IL_003c:  brtrue.s   IL_0055

//000226:                 {
    IL_003e:  nop
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
    IL_003f:  ldarg.0
    IL_0040:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0045:  ldloc.0
    IL_0046:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.FileDialog::get_FileName()
    IL_004b:  ldc.i4.s   100
    IL_004d:  conv.i8
    IL_004e:  call       void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::SaveImage(class [System.Drawing]System.Drawing.Bitmap,
                                                                                                                 string,
                                                                                                                 int64)
    IL_0053:  nop
//000228:                 }
    IL_0054:  nop
//000229:             }
    IL_0055:  nop
//000230:         }
    IL_0056:  ret
  } // end of method MainForm::btnSaveImage_Click

  .method private hidebysig static void  SaveImage(class [System.Drawing]System.Drawing.Bitmap bmp,
                                                   string path,
                                                   int64 quality) cil managed
  {
    // Code size       445 (0x1bd)
    .maxstack  4
    .locals init ([0] class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo jpegCodec,
             [1] class [System.Drawing]System.Drawing.Imaging.EncoderParameters codecParams,
             [2] class [System.Drawing]System.Drawing.Imaging.EncoderParameter ratio,
             [3] bool CS$4$0000,
             [4] string CS$4$0001,
             [5] int32 CS$0$0002)
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
    IL_0000:  nop
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
    IL_0001:  ldarg.0
    IL_0002:  ldnull
    IL_0003:  ceq
    IL_0005:  ldc.i4.0
    IL_0006:  ceq
    IL_0008:  stloc.3
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0009:  ldloc.3
    IL_000a:  brtrue.s   IL_0017

//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
    IL_000c:  ldstr      "bmp"
    IL_0011:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0016:  throw

//000240:             if (path == null) throw new ArgumentNullException("path");
    IL_0017:  ldarg.1
    IL_0018:  ldnull
    IL_0019:  ceq
    IL_001b:  ldc.i4.0
    IL_001c:  ceq
    IL_001e:  stloc.3
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_001f:  ldloc.3
    IL_0020:  brtrue.s   IL_002d

//000240:             if (path == null) throw new ArgumentNullException("path");
    IL_0022:  ldstr      "path"
    IL_0027:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_002c:  throw

//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
    IL_002d:  ldarg.2
    IL_002e:  ldc.i4.1
    IL_002f:  conv.i8
    IL_0030:  blt.s      IL_003d

    IL_0032:  ldarg.2
    IL_0033:  ldc.i4.s   100
    IL_0035:  conv.i8
    IL_0036:  cgt
    IL_0038:  ldc.i4.0
    IL_0039:  ceq
    IL_003b:  br.s       IL_003e

    IL_003d:  ldc.i4.0
    IL_003e:  stloc.3
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_003f:  ldloc.3
    IL_0040:  brtrue.s   IL_0058

//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
    IL_0042:  ldstr      "quality"
    IL_0047:  ldarg.2
    IL_0048:  box        [mscorlib]System.Int64
    IL_004d:  ldstr      "Quality out of range."
    IL_0052:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0057:  throw

//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
    IL_0058:  ldarg.1
    IL_0059:  call       string [mscorlib]System.IO.Path::GetExtension(string)
    IL_005e:  callvirt   instance string [mscorlib]System.String::ToLowerInvariant()
    IL_0063:  stloc.s    CS$4$0001
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0065:  ldloc.s    CS$4$0001
    IL_0067:  brfalse    IL_00fd

    IL_006c:  volatile.
    IL_006e:  ldsfld     class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32> '<PrivateImplementationDetails>{2BE498C6-20DC-4C09-97C0-6532881E7B83}'::'$$method0x6000018-1'
    IL_0073:  brtrue.s   IL_00ca

    IL_0075:  ldc.i4.6
    IL_0076:  newobj     instance void class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::.ctor(int32)
    IL_007b:  dup
    IL_007c:  ldstr      ".bmp"
    IL_0081:  ldc.i4.0
    IL_0082:  call       instance void class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::Add(!0,
                                                                                                                  !1)
    IL_0087:  dup
    IL_0088:  ldstr      ".png"
    IL_008d:  ldc.i4.1
    IL_008e:  call       instance void class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::Add(!0,
                                                                                                                  !1)
    IL_0093:  dup
    IL_0094:  ldstr      ".gif"
    IL_0099:  ldc.i4.2
    IL_009a:  call       instance void class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::Add(!0,
                                                                                                                  !1)
    IL_009f:  dup
    IL_00a0:  ldstr      ".tif"
    IL_00a5:  ldc.i4.3
    IL_00a6:  call       instance void class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::Add(!0,
                                                                                                                  !1)
    IL_00ab:  dup
    IL_00ac:  ldstr      ".tiff"
    IL_00b1:  ldc.i4.4
    IL_00b2:  call       instance void class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::Add(!0,
                                                                                                                  !1)
    IL_00b7:  dup
    IL_00b8:  ldstr      ".jpg"
    IL_00bd:  ldc.i4.5
    IL_00be:  call       instance void class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::Add(!0,
                                                                                                                  !1)
    IL_00c3:  volatile.
    IL_00c5:  stsfld     class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32> '<PrivateImplementationDetails>{2BE498C6-20DC-4C09-97C0-6532881E7B83}'::'$$method0x6000018-1'
    IL_00ca:  volatile.
    IL_00cc:  ldsfld     class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32> '<PrivateImplementationDetails>{2BE498C6-20DC-4C09-97C0-6532881E7B83}'::'$$method0x6000018-1'
    IL_00d1:  ldloc.s    CS$4$0001
    IL_00d3:  ldloca.s   CS$0$0002
    IL_00d5:  call       instance bool class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32>::TryGetValue(!0,
                                                                                                                          !1&)
    IL_00da:  brfalse.s  IL_00fd

    IL_00dc:  ldloc.s    CS$0$0002
    IL_00de:  switch     ( 
                          IL_00fd,
                          IL_010f,
                          IL_0121,
                          IL_0133,
                          IL_0133,
                          IL_0142)
    IL_00fb:  br.s       IL_00fd

//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
    IL_00fd:  ldarg.0
    IL_00fe:  ldarg.1
    IL_00ff:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Bmp()
    IL_0104:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_0109:  nop
    IL_010a:  br         IL_01bc

//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
    IL_010f:  ldarg.0
    IL_0110:  ldarg.1
    IL_0111:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Png()
    IL_0116:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_011b:  nop
    IL_011c:  br         IL_01bc

//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
    IL_0121:  ldarg.0
    IL_0122:  ldarg.1
    IL_0123:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Gif()
    IL_0128:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_012d:  nop
    IL_012e:  br         IL_01bc

//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
    IL_0133:  ldarg.0
    IL_0134:  ldarg.1
    IL_0135:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Tiff()
    IL_013a:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_013f:  nop
    IL_0140:  br.s       IL_01bc

//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
    IL_0142:  call       class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo[] [System.Drawing]System.Drawing.Imaging.ImageCodecInfo::GetImageEncoders()
    IL_0147:  ldsfld     class [mscorlib]System.Predicate`1<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_014c:  brtrue.s   IL_0161

    IL_014e:  ldnull
    IL_014f:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<SaveImage>b__1'(class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo)
    IL_0155:  newobj     instance void class [mscorlib]System.Predicate`1<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo>::.ctor(object,
                                                                                                                                              native int)
    IL_015a:  stsfld     class [mscorlib]System.Predicate`1<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_015f:  br.s       IL_0161

    IL_0161:  ldsfld     class [mscorlib]System.Predicate`1<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_0166:  call       !!0 [mscorlib]System.Array::Find<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo>(!!0[],
                                                                                                                       class [mscorlib]System.Predicate`1<!!0>)
    IL_016b:  stloc.0
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
    IL_016c:  ldc.i4.1
    IL_016d:  newobj     instance void [System.Drawing]System.Drawing.Imaging.EncoderParameters::.ctor(int32)
    IL_0172:  stloc.1
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
    .try
    {
      IL_0173:  ldsfld     class [System.Drawing]System.Drawing.Imaging.Encoder [System.Drawing]System.Drawing.Imaging.Encoder::Quality
      IL_0178:  ldarg.2
      IL_0179:  newobj     instance void [System.Drawing]System.Drawing.Imaging.EncoderParameter::.ctor(class [System.Drawing]System.Drawing.Imaging.Encoder,
                                                                                                        int64)
      IL_017e:  stloc.2
//000257:                     {
      .try
      {
        IL_017f:  nop
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
        IL_0180:  ldloc.1
        IL_0181:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.EncoderParameter[] [System.Drawing]System.Drawing.Imaging.EncoderParameters::get_Param()
        IL_0186:  ldc.i4.0
        IL_0187:  ldloc.2
        IL_0188:  stelem.ref
//000260:                         bmp.Save(path, jpegCodec, codecParams);
        IL_0189:  ldarg.0
        IL_018a:  ldarg.1
        IL_018b:  ldloc.0
        IL_018c:  ldloc.1
        IL_018d:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                      class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo,
                                                                                      class [System.Drawing]System.Drawing.Imaging.EncoderParameters)
        IL_0192:  nop
//000261:                     }
        IL_0193:  nop
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
        IL_0194:  leave.s    IL_01a6

      }  // end .try
      finally
      {
        IL_0196:  ldloc.2
        IL_0197:  ldnull
        IL_0198:  ceq
        IL_019a:  stloc.3
        IL_019b:  ldloc.3
        IL_019c:  brtrue.s   IL_01a5

        IL_019e:  ldloc.2
        IL_019f:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_01a4:  nop
        IL_01a5:  endfinally
      }  // end handler
      IL_01a6:  nop
      IL_01a7:  leave.s    IL_01b9

    }  // end .try
    finally
    {
      IL_01a9:  ldloc.1
      IL_01aa:  ldnull
      IL_01ab:  ceq
      IL_01ad:  stloc.3
      IL_01ae:  ldloc.3
      IL_01af:  brtrue.s   IL_01b8

      IL_01b1:  ldloc.1
      IL_01b2:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_01b7:  nop
      IL_01b8:  endfinally
    }  // end handler
    IL_01b9:  nop
//000262:                     break;
    IL_01ba:  br.s       IL_01bc

//000263:             }
//000264:         }
    IL_01bc:  ret
  } // end of method MainForm::SaveImage

  .method private hidebysig instance void 
          tmRefresh_Tick(object sender,
                         class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
    IL_0000:  nop
//000269:             StartColorizeImage();
    IL_0001:  ldarg.0
    IL_0002:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartColorizeImage()
    IL_0007:  nop
//000270:         }
    IL_0008:  ret
  } // end of method MainForm::tmRefresh_Tick

  .method private hidebysig instance void 
          tbEpsilon_ValueChanged(object sender,
                                 class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       47 (0x2f)
    .maxstack  8
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
    IL_0000:  nop
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_0007:  call       string Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_EpsilonDisplay()
    IL_000c:  ldarg.0
    IL_000d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon
    IL_0012:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
    IL_0017:  box        [mscorlib]System.Int32
    IL_001c:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0021:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ToolTipText(string)
    IL_0026:  nop
//000276:             StartRefreshTimer();
    IL_0027:  ldarg.0
    IL_0028:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartRefreshTimer()
    IL_002d:  nop
//000277:         }
    IL_002e:  ret
  } // end of method MainForm::tbEpsilon_ValueChanged

  .method private hidebysig instance void 
          StartRefreshTimer() cil managed
  {
    // Code size       90 (0x5a)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
    IL_0000:  nop
//000282:             if (_originalImage != null &&
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0007:  brfalse.s  IL_002d

    IL_0009:  ldarg.0
    IL_000a:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_000f:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0014:  ldc.i4.0
    IL_0015:  ble.s      IL_002d

    IL_0017:  ldarg.0
    IL_0018:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
    IL_001d:  ldc.i4.0
    IL_001e:  blt.s      IL_002d

    IL_0020:  ldarg.0
    IL_0021:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_0026:  callvirt   instance bool [System]System.ComponentModel.BackgroundWorker::get_IsBusy()
    IL_002b:  br.s       IL_002e

    IL_002d:  ldc.i4.1
    IL_002e:  stloc.0
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_002f:  ldloc.0
    IL_0030:  brtrue.s   IL_0059

//000285:             {
    IL_0032:  nop
//000286:                 btnLoadImage.Enabled = false;
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage
    IL_0039:  ldc.i4.0
    IL_003a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_003f:  nop
//000287:                 tmRefresh.Stop();
    IL_0040:  ldarg.0
    IL_0041:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh
    IL_0046:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Stop()
    IL_004b:  nop
//000288:                 tmRefresh.Start();
    IL_004c:  ldarg.0
    IL_004d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh
    IL_0052:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Start()
    IL_0057:  nop
//000289:             }
    IL_0058:  nop
//000290:         }
    IL_0059:  ret
  } // end of method MainForm::StartRefreshTimer

  .method private hidebysig instance void 
          pbImage_Resize(object sender,
                         class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       71 (0x47)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
    IL_0000:  nop
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
    IL_0001:  ldarg.0
    IL_0002:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0007:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_000c:  ldc.i4.0
    IL_000d:  ble.s      IL_0027

    IL_000f:  ldarg.0
    IL_0010:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0015:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_001a:  ldc.i4.0
    IL_001b:  ble.s      IL_0027

    IL_001d:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
    IL_0022:  ldc.i4.0
    IL_0023:  ceq
    IL_0025:  br.s       IL_0028

    IL_0027:  ldc.i4.1
    IL_0028:  stloc.0
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0029:  ldloc.0
    IL_002a:  brtrue.s   IL_0035

//000297:             {
    IL_002c:  nop
//000298:                 ScaleInk();
    IL_002d:  ldarg.0
    IL_002e:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::ScaleInk()
    IL_0033:  nop
//000299:             }
    IL_0034:  nop
//000300:             _lastPictureBoxSize = pbImage.Size;
    IL_0035:  ldarg.0
    IL_0036:  ldarg.0
    IL_0037:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_003c:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0041:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
//000301:         }
    IL_0046:  ret
  } // end of method MainForm::pbImage_Resize

  .method private hidebysig instance void 
          InitializeInk() cil managed noinlining
  {
    // Code size       130 (0x82)
    .maxstack  4
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
    IL_0000:  nop
//000307:             _overlay = new InkOverlay(pbImage, true);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0008:  ldc.i4.1
    IL_0009:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::.ctor(class [System.Windows.Forms_5]System.Windows.Forms.Control,
                                                                                      bool)
    IL_000e:  stfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
    IL_0013:  ldarg.0
    IL_0014:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0019:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.DrawingAttributes [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_DefaultDrawingAttributes()
    IL_001e:  ldc.r4     1.
    IL_0023:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.DrawingAttributes::set_Width(float32)
    IL_0028:  nop
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
    IL_0029:  ldarg.0
    IL_002a:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_002f:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.DrawingAttributes [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_DefaultDrawingAttributes()
    IL_0034:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Red()
    IL_0039:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.DrawingAttributes::set_Color(valuetype [System.Drawing_6]System.Drawing.Color)
    IL_003e:  nop
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
    IL_003f:  ldarg.0
    IL_0040:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0045:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.DrawingAttributes [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_DefaultDrawingAttributes()
    IL_004a:  ldc.i4.1
    IL_004b:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.DrawingAttributes::set_IgnorePressure(bool)
    IL_0050:  nop
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
    IL_0051:  ldarg.0
    IL_0052:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0057:  ldarg.0
    IL_0058:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<InitializeInk>b__3'(object,
                                                                                                                                      class [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventArgs)
    IL_005e:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventHandler::.ctor(object,
                                                                                                          native int)
    IL_0063:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::add_Stroke(class [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventHandler)
    IL_0068:  nop
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
    IL_0069:  ldarg.0
    IL_006a:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_006f:  ldarg.0
    IL_0070:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<InitializeInk>b__4'(object,
                                                                                                                                      class [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventArgs)
    IL_0076:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventHandler::.ctor(object,
                                                                                                              native int)
    IL_007b:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::add_NewPackets(class [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventHandler)
    IL_0080:  nop
//000325:         }
    IL_0081:  ret
  } // end of method MainForm::InitializeInk

  .method private hidebysig instance void 
          ClearInk() cil managed noinlining
  {
    // Code size       19 (0x13)
    .maxstack  8
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Ink [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Ink()
    IL_000c:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.Ink::DeleteStrokes()
    IL_0011:  nop
    IL_0012:  ret
  } // end of method MainForm::ClearInk

  .method private hidebysig instance void 
          ScaleInk() cil managed noinlining
  {
    // Code size       180 (0xb4)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Size CS$0$0000,
             [1] bool CS$4$0001)
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
    IL_0000:  nop
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0007:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_000c:  stloc.0
    IL_000d:  ldloca.s   CS$0$0000
    IL_000f:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0014:  ldc.i4.0
    IL_0015:  ble.s      IL_0054

    IL_0017:  ldarg.0
    IL_0018:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_001d:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0022:  stloc.0
    IL_0023:  ldloca.s   CS$0$0000
    IL_0025:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_002a:  ldc.i4.0
    IL_002b:  ble.s      IL_0054

    IL_002d:  ldarg.0
    IL_002e:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0033:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0038:  ldc.i4.0
    IL_0039:  ble.s      IL_0054

    IL_003b:  ldarg.0
    IL_003c:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0041:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_0046:  ldc.i4.0
    IL_0047:  ble.s      IL_0054

    IL_0049:  ldarg.0
    IL_004a:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_004f:  ldnull
    IL_0050:  ceq
    IL_0052:  br.s       IL_0055

    IL_0054:  ldc.i4.1
    IL_0055:  stloc.1
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0056:  ldloc.1
    IL_0057:  brtrue.s   IL_00b3

//000338:             {
    IL_0059:  nop
//000339:                 _overlay.Ink.Strokes.Scale(
    IL_005a:  ldarg.0
    IL_005b:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0060:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Ink [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Ink()
    IL_0065:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Strokes [Microsoft.Ink]Microsoft.Ink.Ink::get_Strokes()
    IL_006a:  ldarg.0
    IL_006b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0070:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0075:  stloc.0
    IL_0076:  ldloca.s   CS$0$0000
    IL_0078:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_007d:  conv.r4
    IL_007e:  ldarg.0
    IL_007f:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0084:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0089:  conv.r4
    IL_008a:  div
    IL_008b:  ldarg.0
    IL_008c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0091:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0096:  stloc.0
    IL_0097:  ldloca.s   CS$0$0000
    IL_0099:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_009e:  conv.r4
    IL_009f:  ldarg.0
    IL_00a0:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_00a5:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_00aa:  conv.r4
    IL_00ab:  div
    IL_00ac:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.Strokes::Scale(float32,
                                                                                   float32)
    IL_00b1:  nop
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
    IL_00b2:  nop
//000343:         }
    IL_00b3:  ret
  } // end of method MainForm::ScaleInk

  .method private hidebysig instance class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> 
          InkToGraphicsPaths(bool scalePath) cil managed noinlining
  {
    // Code size       408 (0x198)
    .maxstack  5
    .locals init ([0] class [Microsoft.Ink]Microsoft.Ink.Renderer renderer,
             [1] class [Microsoft.Ink]Microsoft.Ink.Strokes strokes,
             [2] float32 scaleX,
             [3] float32 scaleY,
             [4] class [System.Drawing]System.Drawing.Graphics g,
             [5] class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> paths,
             [6] class [Microsoft.Ink]Microsoft.Ink.Stroke stroke,
             [7] valuetype [System.Drawing]System.Drawing.Point[] points,
             [8] int32 i,
             [9] class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath path,
             [10] class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> CS$1$0000,
             [11] bool CS$4$0001,
             [12] class [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator CS$5$0002,
             [13] class [mscorlib]System.IDisposable CS$0$0003)
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
    IL_0000:  nop
//000351:             Renderer renderer = _overlay.Renderer;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Renderer [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Renderer()
    IL_000c:  stloc.0
//000352:             Strokes strokes = _overlay.Ink.Strokes;
    IL_000d:  ldarg.0
    IL_000e:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0013:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Ink [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Ink()
    IL_0018:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Strokes [Microsoft.Ink]Microsoft.Ink.Ink::get_Strokes()
    IL_001d:  stloc.1
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0024:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0029:  conv.r4
    IL_002a:  ldarg.0
    IL_002b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0030:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_0035:  conv.r4
    IL_0036:  div
    IL_0037:  stloc.2
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_003e:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0043:  conv.r4
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_004a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_004f:  conv.r4
    IL_0050:  div
    IL_0051:  stloc.3
//000356: 
//000357:             if (strokes.Count > 0)
    IL_0052:  ldloc.1
    IL_0053:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Strokes::get_Count()
    IL_0058:  ldc.i4.0
    IL_0059:  cgt
    IL_005b:  ldc.i4.0
    IL_005c:  ceq
    IL_005e:  stloc.s    CS$4$0001
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0060:  ldloc.s    CS$4$0001
    IL_0062:  brtrue     IL_018f

//000358:             {
    IL_0067:  nop
//000359:                 using (Graphics g = CreateGraphics())
    IL_0068:  ldarg.0
    IL_0069:  call       instance class [System.Drawing]System.Drawing.Graphics [System.Windows.Forms]System.Windows.Forms.Control::CreateGraphics()
    IL_006e:  stloc.s    g
//000360:                 {
    .try
    {
      IL_0070:  nop
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
      IL_0071:  ldloc.1
      IL_0072:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Strokes::get_Count()
      IL_0077:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::.ctor(int32)
      IL_007c:  stloc.s    paths
//000362:                     foreach (Stroke stroke in strokes)
      IL_007e:  nop
      IL_007f:  ldloc.1
      IL_0080:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator [Microsoft.Ink]Microsoft.Ink.Strokes::GetEnumerator()
      IL_0085:  stloc.s    CS$5$0002
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
      .try
      {
        IL_0087:  br         IL_0145

//000362:                     foreach (Stroke stroke in strokes)
        IL_008c:  ldloc.s    CS$5$0002
        IL_008e:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Stroke [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator::get_Current()
        IL_0093:  stloc.s    stroke
//000363:                     {
        IL_0095:  nop
//000364:                         Point[] points = stroke.GetPoints();
        IL_0096:  ldloc.s    stroke
        IL_0098:  callvirt   instance valuetype [System.Drawing_6]System.Drawing.Point[] [Microsoft.Ink]Microsoft.Ink.Stroke::GetPoints()
        IL_009d:  stloc.s    points
//000365:                         if (points.Length >= 3)
        IL_009f:  ldloc.s    points
        IL_00a1:  ldlen
        IL_00a2:  conv.i4
        IL_00a3:  ldc.i4.3
        IL_00a4:  clt
        IL_00a6:  stloc.s    CS$4$0001
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
        IL_00a8:  ldloc.s    CS$4$0001
        IL_00aa:  brtrue     IL_0144

//000366:                         {
        IL_00af:  nop
//000367:                             for (int i = 0; i < points.Length; i++)
        IL_00b0:  ldc.i4.0
        IL_00b1:  stloc.s    i
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
        IL_00b3:  br.s       IL_0112

//000368:                             {
        IL_00b5:  nop
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
        IL_00b6:  ldloc.0
        IL_00b7:  ldloc.s    g
        IL_00b9:  ldloc.s    points
        IL_00bb:  ldloc.s    i
        IL_00bd:  ldelema    [System.Drawing]System.Drawing.Point
        IL_00c2:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.Renderer::InkSpaceToPixel(class [System.Drawing_6]System.Drawing.Graphics,
                                                                                                  valuetype [System.Drawing_6]System.Drawing.Point&)
        IL_00c7:  nop
//000370:                                 if (scalePath)
        IL_00c8:  ldarg.1
        IL_00c9:  ldc.i4.0
        IL_00ca:  ceq
        IL_00cc:  stloc.s    CS$4$0001
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
        IL_00ce:  ldloc.s    CS$4$0001
        IL_00d0:  brtrue.s   IL_010b

//000371:                                 {
        IL_00d2:  nop
//000372:                                     points[i] = new Point(
        IL_00d3:  ldloc.s    points
        IL_00d5:  ldloc.s    i
        IL_00d7:  ldelema    [System.Drawing]System.Drawing.Point
        IL_00dc:  ldloc.2
        IL_00dd:  ldloc.s    points
        IL_00df:  ldloc.s    i
        IL_00e1:  ldelema    [System.Drawing]System.Drawing.Point
        IL_00e6:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
        IL_00eb:  conv.r4
        IL_00ec:  mul
        IL_00ed:  conv.i4
        IL_00ee:  ldloc.3
        IL_00ef:  ldloc.s    points
        IL_00f1:  ldloc.s    i
        IL_00f3:  ldelema    [System.Drawing]System.Drawing.Point
        IL_00f8:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
        IL_00fd:  conv.r4
        IL_00fe:  mul
        IL_00ff:  conv.i4
        IL_0100:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                       int32)
        IL_0105:  stobj      [System.Drawing]System.Drawing.Point
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
        IL_010a:  nop
//000376:                             }
        IL_010b:  nop
//000367:                             for (int i = 0; i < points.Length; i++)
        IL_010c:  ldloc.s    i
        IL_010e:  ldc.i4.1
        IL_010f:  add
        IL_0110:  stloc.s    i
        IL_0112:  ldloc.s    i
        IL_0114:  ldloc.s    points
        IL_0116:  ldlen
        IL_0117:  conv.i4
        IL_0118:  clt
        IL_011a:  stloc.s    CS$4$0001
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
        IL_011c:  ldloc.s    CS$4$0001
        IL_011e:  brtrue.s   IL_00b5

//000377:                             GraphicsPath path = new GraphicsPath();
        IL_0120:  newobj     instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::.ctor()
        IL_0125:  stloc.s    path
//000378:                             path.AddPolygon(points);
        IL_0127:  ldloc.s    path
        IL_0129:  ldloc.s    points
        IL_012b:  callvirt   instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::AddPolygon(valuetype [System.Drawing]System.Drawing.Point[])
        IL_0130:  nop
//000379:                             path.CloseFigure();
        IL_0131:  ldloc.s    path
        IL_0133:  callvirt   instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::CloseFigure()
        IL_0138:  nop
//000380:                             paths.Add(path);
        IL_0139:  ldloc.s    paths
        IL_013b:  ldloc.s    path
        IL_013d:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::Add(!0)
        IL_0142:  nop
//000381:                         }
        IL_0143:  nop
//000382:                     }
        IL_0144:  nop
//000362:                     foreach (Stroke stroke in strokes)
        IL_0145:  ldloc.s    CS$5$0002
        IL_0147:  callvirt   instance bool [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator::MoveNext()
        IL_014c:  stloc.s    CS$4$0001
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
        IL_014e:  ldloc.s    CS$4$0001
        IL_0150:  brtrue     IL_008c

        IL_0155:  leave.s    IL_0174

      }  // end .try
      finally
      {
        IL_0157:  ldloc.s    CS$5$0002
        IL_0159:  isinst     [mscorlib]System.IDisposable
        IL_015e:  stloc.s    CS$0$0003
        IL_0160:  ldloc.s    CS$0$0003
        IL_0162:  ldnull
        IL_0163:  ceq
        IL_0165:  stloc.s    CS$4$0001
        IL_0167:  ldloc.s    CS$4$0001
        IL_0169:  brtrue.s   IL_0173

        IL_016b:  ldloc.s    CS$0$0003
        IL_016d:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_0172:  nop
        IL_0173:  endfinally
      }  // end handler
      IL_0174:  nop
//000383:                     return paths;
      IL_0175:  ldloc.s    paths
      IL_0177:  stloc.s    CS$1$0000
      IL_0179:  leave.s    IL_0194

//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    }  // end .try
    finally
    {
      IL_017b:  ldloc.s    g
      IL_017d:  ldnull
      IL_017e:  ceq
      IL_0180:  stloc.s    CS$4$0001
      IL_0182:  ldloc.s    CS$4$0001
      IL_0184:  brtrue.s   IL_018e

      IL_0186:  ldloc.s    g
      IL_0188:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_018d:  nop
      IL_018e:  endfinally
//000386:             return null;
    }  // end handler
    IL_018f:  ldnull
    IL_0190:  stloc.s    CS$1$0000
    IL_0192:  br.s       IL_0194

//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0194:  nop
//000387:         }
    IL_0195:  ldloc.s    CS$1$0000
    IL_0197:  ret
  } // end of method MainForm::InkToGraphicsPaths

  .method private hidebysig instance void 
          btnInk_Click(object sender,
                       class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       74 (0x4a)
    .maxstack  3
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
    IL_0000:  nop
//000392:             _overlay.Enabled = !_overlay.Enabled;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_000d:  callvirt   instance bool [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Enabled()
    IL_0012:  ldc.i4.0
    IL_0013:  ceq
    IL_0015:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::set_Enabled(bool)
    IL_001a:  nop
//000393:             btnInk.Checked = _overlay.Enabled;
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_0021:  ldarg.0
    IL_0022:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0027:  callvirt   instance bool [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Enabled()
    IL_002c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::set_Checked(bool)
    IL_0031:  nop
//000394:             btnEraser.Enabled = btnInk.Checked;
    IL_0032:  ldarg.0
    IL_0033:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk
    IL_003e:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripButton::get_Checked()
    IL_0043:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0048:  nop
//000395:         }
    IL_0049:  ret
  } // end of method MainForm::btnInk_Click

  .method private hidebysig instance void 
          btnEraser_Click(object sender,
                          class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       58 (0x3a)
    .maxstack  8
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
    IL_0000:  nop
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_000d:  callvirt   instance valuetype [Microsoft.Ink]Microsoft.Ink.InkOverlayEditingMode [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_EditingMode()
    IL_0012:  ldc.i4.1
    IL_0013:  beq.s      IL_0018

    IL_0015:  ldc.i4.1
    IL_0016:  br.s       IL_0019

    IL_0018:  ldc.i4.0
    IL_0019:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::set_EditingMode(valuetype [Microsoft.Ink]Microsoft.Ink.InkOverlayEditingMode)
    IL_001e:  nop
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
    IL_001f:  ldarg.0
    IL_0020:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser
    IL_0025:  ldarg.0
    IL_0026:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_002b:  callvirt   instance valuetype [Microsoft.Ink]Microsoft.Ink.InkOverlayEditingMode [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_EditingMode()
    IL_0030:  ldc.i4.1
    IL_0031:  ceq
    IL_0033:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::set_Checked(bool)
    IL_0038:  nop
//000403:         }
    IL_0039:  ret
  } // end of method MainForm::btnEraser_Click

  .method private hidebysig instance void 
          lblHuesSelected_Click(object sender,
                                class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       117 (0x75)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
    IL_0000:  nop
//000408:             _selectedPixels.Clear();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_0007:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::Clear()
    IL_000c:  nop
//000409:             pbImage.Image = _originalImage;
    IL_000d:  ldarg.0
    IL_000e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage
    IL_0013:  ldarg.0
    IL_0014:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0019:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_001e:  nop
//000410:             if (_colorizedImage != null)
    IL_001f:  ldarg.0
    IL_0020:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0025:  ldnull
    IL_0026:  ceq
    IL_0028:  stloc.0
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0029:  ldloc.0
    IL_002a:  brtrue.s   IL_0041

//000411:             {
    IL_002c:  nop
//000412:                 _colorizedImage.Dispose();
    IL_002d:  ldarg.0
    IL_002e:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0033:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_0038:  nop
//000413:                 _colorizedImage = null;
    IL_0039:  ldarg.0
    IL_003a:  ldnull
    IL_003b:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
//000414:             }
    IL_0040:  nop
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
    IL_0041:  ldarg.0
    IL_0042:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_0047:  call       string Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_HuesSelectedDisplay()
    IL_004c:  ldarg.0
    IL_004d:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_0052:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0057:  box        [mscorlib]System.Int32
    IL_005c:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0061:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0066:  nop
//000417:             lblHuesSelected.ToolTipText = null;
    IL_0067:  ldarg.0
    IL_0068:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected
    IL_006d:  ldnull
    IL_006e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ToolTipText(string)
    IL_0073:  nop
//000418:         }
    IL_0074:  ret
  } // end of method MainForm::lblHuesSelected_Click

  .method private hidebysig instance void 
          pbImage_DragEnter(object sender,
                            class [System.Windows.Forms]System.Windows.Forms.DragEventArgs e) cil managed
  {
    // Code size       66 (0x42)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
    IL_0000:  nop
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_0007:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_000c:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.IDataObject::GetDataPresent(string)
    IL_0011:  brfalse.s  IL_0032

    IL_0013:  ldarg.2
    IL_0014:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_0019:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_001e:  callvirt   instance object [System.Windows.Forms]System.Windows.Forms.IDataObject::GetData(string)
    IL_0023:  castclass  string[]
    IL_0028:  ldlen
    IL_0029:  conv.i4
    IL_002a:  ldc.i4.1
    IL_002b:  ceq
    IL_002d:  ldc.i4.0
    IL_002e:  ceq
    IL_0030:  br.s       IL_0033

    IL_0032:  ldc.i4.1
    IL_0033:  stloc.0
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0034:  ldloc.0
    IL_0035:  brtrue.s   IL_0041

//000425:             {
    IL_0037:  nop
//000426:                 e.Effect = DragDropEffects.Copy;
    IL_0038:  ldarg.2
    IL_0039:  ldc.i4.1
    IL_003a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.DragEventArgs::set_Effect(valuetype [System.Windows.Forms]System.Windows.Forms.DragDropEffects)
    IL_003f:  nop
//000427:             }
    IL_0040:  nop
//000428:         }
    IL_0041:  ret
  } // end of method MainForm::pbImage_DragEnter

  .method private hidebysig instance void 
          pbImage_DragDrop(object sender,
                           class [System.Windows.Forms]System.Windows.Forms.DragEventArgs e) cil managed
  {
    // Code size       88 (0x58)
    .maxstack  3
    .locals init ([0] string[] paths,
             [1] bool CS$4$0000)
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
    IL_0000:  nop
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_0007:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_000c:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.IDataObject::GetDataPresent(string)
    IL_0011:  brfalse.s  IL_0021

    IL_0013:  ldarg.2
    IL_0014:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DragDropEffects [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Effect()
    IL_0019:  ldc.i4.1
    IL_001a:  ceq
    IL_001c:  ldc.i4.0
    IL_001d:  ceq
    IL_001f:  br.s       IL_0022

    IL_0021:  ldc.i4.1
    IL_0022:  stloc.1
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0023:  ldloc.1
    IL_0024:  brtrue.s   IL_0057

//000435:             {
    IL_0026:  nop
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
    IL_0027:  ldarg.2
    IL_0028:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_002d:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_0032:  callvirt   instance object [System.Windows.Forms]System.Windows.Forms.IDataObject::GetData(string)
    IL_0037:  castclass  string[]
    IL_003c:  stloc.0
//000437:                 if (paths.Length == 1)
    IL_003d:  ldloc.0
    IL_003e:  ldlen
    IL_003f:  conv.i4
    IL_0040:  ldc.i4.1
    IL_0041:  ceq
    IL_0043:  ldc.i4.0
    IL_0044:  ceq
    IL_0046:  stloc.1
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0047:  ldloc.1
    IL_0048:  brtrue.s   IL_0056

//000438:                 {
    IL_004a:  nop
//000439:                     LoadImage(paths[0]);
    IL_004b:  ldarg.0
    IL_004c:  ldloc.0
    IL_004d:  ldc.i4.0
    IL_004e:  ldelem.ref
    IL_004f:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::LoadImage(string)
    IL_0054:  nop
//000440:                 }
    IL_0055:  nop
//000441:             }
    IL_0056:  nop
//000442:         }
    IL_0057:  ret
  } // end of method MainForm::pbImage_DragDrop

  .method private hidebysig instance void 
          btnParallel_CheckedChanged(object sender,
                                     class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
    IL_0000:  nop
//000446:             StartColorizeImage();
    IL_0001:  ldarg.0
    IL_0002:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartColorizeImage()
    IL_0007:  nop
//000447:         }
    IL_0008:  ret
  } // end of method MainForm::btnParallel_CheckedChanged

  .method private hidebysig instance void 
          '<bwColorize_DoWork>b__0'(object s,
                                    class [System]System.ComponentModel.ProgressChangedEventArgs pcea) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       20 (0x14)
    .maxstack  8
//000171:             {
    IL_0000:  nop
//000172:                 bwColorize.ReportProgress(pcea.ProgressPercentage);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize
    IL_0007:  ldarg.2
    IL_0008:  callvirt   instance int32 [System]System.ComponentModel.ProgressChangedEventArgs::get_ProgressPercentage()
    IL_000d:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::ReportProgress(int32)
    IL_0012:  nop
//000173:             };
//000174: 
//000175:             // Create a clone of the original image, so that we can lock its bits
//000176:             // while still allowing the UI to refresh and resize appropriately
//000177:             using(Bitmap workImage = _originalImage.Clone(
//000178:                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
//000179:             {
//000180:                 // Colorize the image and store the resulting Bitmap
//000181:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
//000182:             }
//000183:         }
//000184: 
//000185:         /// <summary>Configures the MainForm after colorization is complete.</summary>
//000186:         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//000187:         {
//000188:             // Reenable the UI
//000189:             pbColorizing.Visible = false;
//000190:             toolStripMain.Enabled = true;
//000191:             pbImage.Enabled = true;
//000192:             btnLoadImage.Enabled = true;
//000193:             btnSaveImage.Enabled = true;
//000194:             tbEpsilon.Focus();
//000195: 
//000196:             // Rethrow any exceptions
//000197:             if (e.Error != null) throw new TargetInvocationException(e.Error);
//000198: 
//000199:             // Get the newly computed image
//000200:             if (_colorizedImage != null) _colorizedImage.Dispose();
//000201:             _colorizedImage = (Bitmap)e.Result;
//000202: 
//000203:             // Set the newly computed image into the PictureBox
//000204:             if (pbImage.Image != null && pbImage.Image != _originalImage)
//000205:             {
//000206:                 pbImage.Image.Dispose();
//000207:             }
//000208:             pbImage.Image = _colorizedImage;
//000209:         }
//000210: 
//000211:         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000212:         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
//000213:         {
//000214:             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
//000215:         }
//000216: 
//000217:         /// <summary>Saves the colorized image to a file.</summary>
//000218:         private void btnSaveImage_Click(object sender, EventArgs e)
//000219:         {
//000220:             if (_colorizedImage != null)
//000221:             {
//000222:                 SaveFileDialog sfd = new SaveFileDialog();
//000223:                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
//000224:                 sfd.DefaultExt = ".jpg";
//000225:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000226:                 {
//000227:                     SaveImage(_colorizedImage, sfd.FileName, 100);
//000228:                 }
//000229:             }
//000230:         }
//000231: 
//000232:         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000233:         /// <param name="bmp">The image to be saved.</param>
//000234:         /// <param name="path">The path where to save the image.</param>
//000235:         /// <param name="quality">The quality of the image to save.</param>
//000236:         private static void SaveImage(Bitmap bmp, string path, long quality)
//000237:         {
//000238:             // Validate parameters
//000239:             if (bmp == null) throw new ArgumentNullException("bmp");
//000240:             if (path == null) throw new ArgumentNullException("path");
//000241:             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
//000242: 
//000243:             // Save it to a file format based on the path's extension
//000244:             switch (Path.GetExtension(path).ToLowerInvariant())
//000245:             {
//000246:                 default:
//000247:                 case ".bmp": bmp.Save(path, ImageFormat.Bmp); break;
//000248:                 case ".png": bmp.Save(path, ImageFormat.Png); break;
//000249:                 case ".gif": bmp.Save(path, ImageFormat.Gif); break;
//000250:                 case ".tif":
//000251:                 case ".tiff": bmp.Save(path, ImageFormat.Tiff); break;
//000252:                 case ".jpg":
//000253:                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0013:  ret
  } // end of method MainForm::'<bwColorize_DoWork>b__0'

  .method private hidebysig static bool  '<SaveImage>b__1'(class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo ici) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       22 (0x16)
    .maxstack  2
    .locals init ([0] bool CS$1$0000)
//000254:                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance string [System.Drawing]System.Drawing.Imaging.ImageCodecInfo::get_MimeType()
    IL_0007:  ldstr      "image/jpeg"
    IL_000c:  call       bool [mscorlib]System.String::op_Equality(string,
                                                                   string)
    IL_0011:  stloc.0
    IL_0012:  br.s       IL_0014

//000255:                     using (EncoderParameters codecParams = new EncoderParameters(1))
//000256:                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
//000257:                     {
//000258:                         // Set the JPEG quality value and save the image
//000259:                         codecParams.Param[0] = ratio;
//000260:                         bmp.Save(path, jpegCodec, codecParams);
//000261:                     }
//000262:                     break;
//000263:             }
//000264:         }
//000265: 
//000266:         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
//000267:         private void tmRefresh_Tick(object sender, EventArgs e)
//000268:         {
//000269:             StartColorizeImage();
//000270:         }
//000271: 
//000272:         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000273:         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
//000274:         {
//000275:             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
//000276:             StartRefreshTimer();
//000277:         }
//000278: 
//000279:         /// <summary>Starts/restarts the refresh timer.</summary>
//000280:         private void StartRefreshTimer()
//000281:         {
//000282:             if (_originalImage != null &&
//000283:                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
//000284:                 !bwColorize.IsBusy)
//000285:             {
//000286:                 btnLoadImage.Enabled = false;
//000287:                 tmRefresh.Stop();
//000288:                 tmRefresh.Start();
//000289:             }
//000290:         }
//000291: 
//000292:         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
//000293:         private void pbImage_Resize(object sender, EventArgs e)
//000294:         {
//000295:             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000296:                 PlatformDetection.SupportsInk)
//000297:             {
//000298:                 ScaleInk();
//000299:             }
//000300:             _lastPictureBoxSize = pbImage.Size;
//000301:         }
//000302: 
//000303:         /// <summary>Initializes the InkOverlay.</summary>
//000304:         [MethodImpl(MethodImplOptions.NoInlining)]
//000305:         private void InitializeInk()
//000306:         {
//000307:             _overlay = new InkOverlay(pbImage, true);
//000308:             _overlay.DefaultDrawingAttributes.Width = 1;
//000309:             _overlay.DefaultDrawingAttributes.Color = Color.Red;
//000310:             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
//000311: 
//000312:             // When a stroke is received, we start a timer that, when expiring,
//000313:             // will cause the image to be redrawn.  This timer allows the user
//000314:             // to draw multiple strokes without the image having to be redrawn
//000315:             // after each.
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0014:  ldloc.0
    IL_0015:  ret
  } // end of method MainForm::'<SaveImage>b__1'

  .method private hidebysig instance void 
          '<InitializeInk>b__3'(object A_1,
                                class [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventArgs A_2) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       9 (0x9)
    .maxstack  8
//000316:             _overlay.Stroke += delegate { StartRefreshTimer(); };
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartRefreshTimer()
    IL_0007:  nop
//000317: 
//000318:             // We also don't want the image to be redrawn midstroke (which
//000319:             // could happen if the user drew a stroke, causing the timer
//000320:             // to start, and then took longer than a second to draw the
//000321:             // second stroke), so when new packets are received, the timer
//000322:             // is stopped; it'll be restarted by the above when the Stroke
//000323:             // is completed.
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_0008:  ret
  } // end of method MainForm::'<InitializeInk>b__3'

  .method private hidebysig instance void 
          '<InitializeInk>b__4'(object A_1,
                                class [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventArgs A_2) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       14 (0xe)
    .maxstack  8
//000324:             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh
    IL_0007:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Stop()
    IL_000c:  nop
//000325:         }
//000326: 
//000327:         /// <summary>Clears all ink from the overlay.</summary>
//000328:         [MethodImpl(MethodImplOptions.NoInlining)]
//000329:         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
//000330: 
//000331:         /// <summary>Scales the ink in the overlay.</summary>
//000332:         [MethodImpl(MethodImplOptions.NoInlining)]
//000333:         private void ScaleInk()
//000334:         {
//000335:             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
//000336:                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
//000337:                 _overlay != null)
//000338:             {
//000339:                 _overlay.Ink.Strokes.Scale(
//000340:                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
//000341:                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
//000342:             }
//000343:         }
//000344: 
//000345:         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000346:         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000347:         /// <returns>The list of converted GraphicsPath instances.</returns>
//000348:         [MethodImpl(MethodImplOptions.NoInlining)]
//000349:         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
//000350:         {
//000351:             Renderer renderer = _overlay.Renderer;
//000352:             Strokes strokes = _overlay.Ink.Strokes;
//000353: 
//000354:             float scaleX = _originalImage.Width / (float)pbImage.Width;
//000355:             float scaleY = _originalImage.Height / (float)pbImage.Height;
//000356: 
//000357:             if (strokes.Count > 0)
//000358:             {
//000359:                 using (Graphics g = CreateGraphics())
//000360:                 {
//000361:                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
//000362:                     foreach (Stroke stroke in strokes)
//000363:                     {
//000364:                         Point[] points = stroke.GetPoints();
//000365:                         if (points.Length >= 3)
//000366:                         {
//000367:                             for (int i = 0; i < points.Length; i++)
//000368:                             {
//000369:                                 renderer.InkSpaceToPixel(g, ref points[i]);
//000370:                                 if (scalePath)
//000371:                                 {
//000372:                                     points[i] = new Point(
//000373:                                         (int)(scaleX * points[i].X),
//000374:                                         (int)(scaleY * points[i].Y));
//000375:                                 }
//000376:                             }
//000377:                             GraphicsPath path = new GraphicsPath();
//000378:                             path.AddPolygon(points);
//000379:                             path.CloseFigure();
//000380:                             paths.Add(path);
//000381:                         }
//000382:                     }
//000383:                     return paths;
//000384:                 }
//000385:             }
//000386:             return null;
//000387:         }
//000388: 
//000389:         /// <summary>Enables or disables the InkOverlay.</summary>
//000390:         private void btnInk_Click(object sender, EventArgs e)
//000391:         {
//000392:             _overlay.Enabled = !_overlay.Enabled;
//000393:             btnInk.Checked = _overlay.Enabled;
//000394:             btnEraser.Enabled = btnInk.Checked;
//000395:         }
//000396: 
//000397:         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000398:         private void btnEraser_Click(object sender, EventArgs e)
//000399:         {
//000400:             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
//000401:                 InkOverlayEditingMode.Ink : InkOverlayEditingMode.Delete;
//000402:             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
//000403:         }
//000404: 
//000405:         /// <summary>Resets back to the original image.</summary>
//000406:         private void lblHuesSelected_Click(object sender, EventArgs e)
//000407:         {
//000408:             _selectedPixels.Clear();
//000409:             pbImage.Image = _originalImage;
//000410:             if (_colorizedImage != null)
//000411:             {
//000412:                 _colorizedImage.Dispose();
//000413:                 _colorizedImage = null;
//000414:             }
//000415: 
//000416:             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
//000417:             lblHuesSelected.ToolTipText = null;
//000418:         }
//000419: 
//000420:         /// <summary>Sets up a drag & drop affect.</summary>
//000421:         private void pbImage_DragEnter(object sender, DragEventArgs e)
//000422:         {
//000423:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000424:                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
//000425:             {
//000426:                 e.Effect = DragDropEffects.Copy;
//000427:             }
//000428:         }
//000429: 
//000430:         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000431:         private void pbImage_DragDrop(object sender, DragEventArgs e)
//000432:         {
//000433:             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
//000434:                 e.Effect == DragDropEffects.Copy)
//000435:             {
//000436:                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
//000437:                 if (paths.Length == 1)
//000438:                 {
//000439:                     LoadImage(paths[0]);
//000440:                 }
//000441:             }
//000442:         }
//000443: 
//000444:         private void btnParallel_CheckedChanged(object sender, EventArgs e)
//000445:         {
//000446:             StartColorizeImage();
//000447:         }
//000448:     }
//000449: }
    IL_000d:  ret
  } // end of method MainForm::'<InitializeInk>b__4'

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm

.class private abstract auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       26 (0x1a)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Program.cs' 
//000024:         {
    IL_0000:  nop
//000025:             Application.EnableVisualStyles();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
    IL_0006:  nop
//000026:             Application.SetCompatibleTextRenderingDefault(false);
    IL_0007:  ldc.i4.0
    IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
    IL_000d:  nop
//000027:             Application.Run(new MainForm());
    IL_000e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::.ctor()
    IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_0018:  nop
//000028:         }
    IL_0019:  ret
  } // end of method Program::Main

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Program

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs' 
//000031:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000032:         internal Resources() {
    IL_0007:  nop
//000033:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000034:         
//000035:         /// <summary>
//000036:         ///   Returns the cached ResourceManager instance used by this class.
//000037:         /// </summary>
//000038:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000039:         internal static global::System.Resources.ResourceManager ResourceManager {
//000040:             get {
    IL_0000:  nop
//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  call       bool [mscorlib]System.Object::ReferenceEquals(object,
                                                                       object)
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.2
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resourc" +
//000043:                             "es", typeof(Resources).Assembly);
//000044:                     resourceMan = temp;
//000045:                 }
//000046:                 return resourceMan;
//000047:             }
//000048:         }
//000049:         
//000050:         /// <summary>
//000051:         ///   Overrides the current thread's CurrentUICulture property for all
//000052:         ///   resource lookups using this strongly typed resource class.
//000053:         /// </summary>
//000054:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000055:         internal static global::System.Globalization.CultureInfo Culture {
//000056:             get {
//000057:                 return resourceCulture;
//000058:             }
//000059:             set {
//000060:                 resourceCulture = value;
//000061:             }
//000062:         }
//000063:         
//000064:         /// <summary>
//000065:         ///   Looks up a localized string similar to Hue variation: {0}.
//000066:         /// </summary>
//000067:         internal static string EpsilonDisplay {
//000068:             get {
//000069:                 return ResourceManager.GetString("EpsilonDisplay", resourceCulture);
//000070:             }
//000071:         }
//000072:         
//000073:         internal static System.Drawing.Bitmap eraser {
//000074:             get {
//000075:                 object obj = ResourceManager.GetObject("eraser", resourceCulture);
//000076:                 return ((System.Drawing.Bitmap)(obj));
//000077:             }
//000078:         }
//000079:         
//000080:         /// <summary>
//000081:         ///   Looks up a localized string similar to Hues selected: {0}.
//000082:         /// </summary>
//000083:         internal static string HuesSelectedDisplay {
//000084:             get {
//000085:                 return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture);
//000086:             }
//000087:         }
//000088:         
//000089:         internal static System.Drawing.Bitmap InsertPictureHS {
//000090:             get {
//000091:                 object obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture);
//000092:                 return ((System.Drawing.Bitmap)(obj));
//000093:             }
//000094:         }
//000095:         
//000096:         internal static System.Drawing.Bitmap pen {
//000097:             get {
//000098:                 object obj = ResourceManager.GetObject("pen", resourceCulture);
//000099:                 return ((System.Drawing.Bitmap)(obj));
//000100:             }
//000101:         }
//000102:         
//000103:         internal static System.Drawing.Bitmap saveHS {
//000104:             get {
//000105:                 object obj = ResourceManager.GetObject("saveHS", resourceCulture);
//000106:                 return ((System.Drawing.Bitmap)(obj));
//000107:             }
//000108:         }
//000109:     }
//000110: }
    IL_0010:  ldloc.2
    IL_0011:  brtrue.s   IL_0035

//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0013:  nop
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resourc" +
    IL_0014:  ldstr      "Microsoft.ParallelComputingPlatform.ParallelExtens"
    + "ions.Samples.Properties.Resources"
    IL_0019:  ldtoken    Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources
    IL_001e:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0023:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0028:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002d:  stloc.0
//000043:                             "es", typeof(Resources).Assembly);
//000044:                     resourceMan = temp;
    IL_002e:  ldloc.0
    IL_002f:  stsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
//000045:                 }
    IL_0034:  nop
//000046:                 return resourceMan;
    IL_0035:  ldsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
    IL_003a:  stloc.1
    IL_003b:  br.s       IL_003d

//000047:             }
    IL_003d:  ldloc.1
    IL_003e:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000048:         }
//000049:         
//000050:         /// <summary>
//000051:         ///   Overrides the current thread's CurrentUICulture property for all
//000052:         ///   resource lookups using this strongly typed resource class.
//000053:         /// </summary>
//000054:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000055:         internal static global::System.Globalization.CultureInfo Culture {
//000056:             get {
    IL_0000:  nop
//000057:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000058:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000059:             set {
    IL_0000:  nop
//000060:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
//000061:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .method assembly hidebysig specialname static 
          string  get_EpsilonDisplay() cil managed
  {
    // Code size       26 (0x1a)
    .maxstack  3
    .locals init ([0] string CS$1$0000)
//000062:         }
//000063:         
//000064:         /// <summary>
//000065:         ///   Looks up a localized string similar to Hue variation: {0}.
//000066:         /// </summary>
//000067:         internal static string EpsilonDisplay {
//000068:             get {
    IL_0000:  nop
//000069:                 return ResourceManager.GetString("EpsilonDisplay", resourceCulture);
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
    IL_0006:  ldstr      "EpsilonDisplay"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0010:  callvirt   instance string [mscorlib]System.Resources.ResourceManager::GetString(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
    IL_0016:  br.s       IL_0018

//000070:             }
    IL_0018:  ldloc.0
    IL_0019:  ret
  } // end of method Resources::get_EpsilonDisplay

  .method assembly hidebysig specialname static 
          class [System.Drawing]System.Drawing.Bitmap 
          get_eraser() cil managed
  {
    // Code size       33 (0x21)
    .maxstack  3
    .locals init ([0] object obj,
             [1] class [System.Drawing]System.Drawing.Bitmap CS$1$0000)
//000071:         }
//000072:         
//000073:         internal static System.Drawing.Bitmap eraser {
//000074:             get {
    IL_0000:  nop
//000075:                 object obj = ResourceManager.GetObject("eraser", resourceCulture);
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
    IL_0006:  ldstr      "eraser"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
//000076:                 return ((System.Drawing.Bitmap)(obj));
    IL_0016:  ldloc.0
    IL_0017:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_001c:  stloc.1
    IL_001d:  br.s       IL_001f

//000077:             }
    IL_001f:  ldloc.1
    IL_0020:  ret
  } // end of method Resources::get_eraser

  .method assembly hidebysig specialname static 
          string  get_HuesSelectedDisplay() cil managed
  {
    // Code size       26 (0x1a)
    .maxstack  3
    .locals init ([0] string CS$1$0000)
//000078:         }
//000079:         
//000080:         /// <summary>
//000081:         ///   Looks up a localized string similar to Hues selected: {0}.
//000082:         /// </summary>
//000083:         internal static string HuesSelectedDisplay {
//000084:             get {
    IL_0000:  nop
//000085:                 return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture);
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
    IL_0006:  ldstr      "HuesSelectedDisplay"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0010:  callvirt   instance string [mscorlib]System.Resources.ResourceManager::GetString(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
    IL_0016:  br.s       IL_0018

//000086:             }
    IL_0018:  ldloc.0
    IL_0019:  ret
  } // end of method Resources::get_HuesSelectedDisplay

  .method assembly hidebysig specialname static 
          class [System.Drawing]System.Drawing.Bitmap 
          get_InsertPictureHS() cil managed
  {
    // Code size       33 (0x21)
    .maxstack  3
    .locals init ([0] object obj,
             [1] class [System.Drawing]System.Drawing.Bitmap CS$1$0000)
//000087:         }
//000088:         
//000089:         internal static System.Drawing.Bitmap InsertPictureHS {
//000090:             get {
    IL_0000:  nop
//000091:                 object obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture);
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
    IL_0006:  ldstr      "InsertPictureHS"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
//000092:                 return ((System.Drawing.Bitmap)(obj));
    IL_0016:  ldloc.0
    IL_0017:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_001c:  stloc.1
    IL_001d:  br.s       IL_001f

//000093:             }
    IL_001f:  ldloc.1
    IL_0020:  ret
  } // end of method Resources::get_InsertPictureHS

  .method assembly hidebysig specialname static 
          class [System.Drawing]System.Drawing.Bitmap 
          get_pen() cil managed
  {
    // Code size       33 (0x21)
    .maxstack  3
    .locals init ([0] object obj,
             [1] class [System.Drawing]System.Drawing.Bitmap CS$1$0000)
//000094:         }
//000095:         
//000096:         internal static System.Drawing.Bitmap pen {
//000097:             get {
    IL_0000:  nop
//000098:                 object obj = ResourceManager.GetObject("pen", resourceCulture);
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
    IL_0006:  ldstr      "pen"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
//000099:                 return ((System.Drawing.Bitmap)(obj));
    IL_0016:  ldloc.0
    IL_0017:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_001c:  stloc.1
    IL_001d:  br.s       IL_001f

//000100:             }
    IL_001f:  ldloc.1
    IL_0020:  ret
  } // end of method Resources::get_pen

  .method assembly hidebysig specialname static 
          class [System.Drawing]System.Drawing.Bitmap 
          get_saveHS() cil managed
  {
    // Code size       33 (0x21)
    .maxstack  3
    .locals init ([0] object obj,
             [1] class [System.Drawing]System.Drawing.Bitmap CS$1$0000)
//000101:         }
//000102:         
//000103:         internal static System.Drawing.Bitmap saveHS {
//000104:             get {
    IL_0000:  nop
//000105:                 object obj = ResourceManager.GetObject("saveHS", resourceCulture);
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
    IL_0006:  ldstr      "saveHS"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
//000106:                 return ((System.Drawing.Bitmap)(obj));
    IL_0016:  ldloc.0
    IL_0017:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_001c:  stloc.1
    IL_001d:  br.s       IL_001f

//000107:             }
    IL_001f:  ldloc.1
    IL_0020:  ret
  } // end of method Resources::get_saveHS

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .set void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
    .get class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_Culture()
  } // end of property Resources::Culture
  .property string EpsilonDisplay()
  {
    .get string Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_EpsilonDisplay()
  } // end of property Resources::EpsilonDisplay
  .property class [System.Drawing]System.Drawing.Bitmap
          eraser()
  {
    .get class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_eraser()
  } // end of property Resources::eraser
  .property string HuesSelectedDisplay()
  {
    .get string Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_HuesSelectedDisplay()
  } // end of property Resources::HuesSelectedDisplay
  .property class [System.Drawing]System.Drawing.Bitmap
          InsertPictureHS()
  {
    .get class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_InsertPictureHS()
  } // end of property Resources::InsertPictureHS
  .property class [System.Drawing]System.Drawing.Bitmap
          pen()
  {
    .get class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_pen()
  } // end of property Resources::pen
  .property class [System.Drawing]System.Drawing.Bitmap
          saveHS()
  {
    .get class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_saveHS()
  } // end of property Resources::saveHS
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar
       extends [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost
{
  .custom instance void [System]System.ComponentModel.DesignerCategoryAttribute::.ctor(string) = ( 01 00 04 63 6F 64 65 00 00 )                      // ...code..
  .custom instance void [System.Windows.Forms]System.Windows.Forms.Design.ToolStripItemDesignerAvailabilityAttribute::.ctor(valuetype [System.Windows.Forms]System.Windows.Forms.Design.ToolStripItemDesignerAvailability) = ( 01 00 09 00 00 00 00 00 ) 
  .field private class [mscorlib]System.EventHandler ValueChanged
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       15 (0xf)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs' 
//000024:         public ToolStripTrackBar() : base(CreateControlInstance()) { }
    IL_0000:  ldarg.0
    IL_0001:  call       class [System.Windows.Forms]System.Windows.Forms.Control Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::CreateControlInstance()
    IL_0006:  call       instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::.ctor(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_000b:  nop
    IL_000c:  nop
    IL_000d:  nop
    IL_000e:  ret
  } // end of method ToolStripTrackBar::.ctor

  .method public hidebysig specialname instance class [System.Windows.Forms]System.Windows.Forms.TrackBar 
          get_TrackBar() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.TrackBar CS$1$0000)
//000025: 
//000026:         /// <summary>Gets the actual TrackBar instance.</summary>
//000027:         public TrackBar TrackBar { get { return Control as TrackBar; } }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::get_Control()
    IL_0007:  isinst     [System.Windows.Forms]System.Windows.Forms.TrackBar
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_TrackBar

  .method private hidebysig static class [System.Windows.Forms]System.Windows.Forms.Control 
          CreateControlInstance() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  2
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.TrackBar t,
             [1] class [System.Windows.Forms]System.Windows.Forms.Control CS$1$0000)
//000028: 
//000029:         /// <summary>Create the actual TrackBar control.</summary>
//000030:         private static Control CreateControlInstance()
//000031:         {
    IL_0000:  nop
//000032:             TrackBar t = new TrackBar();
    IL_0001:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::.ctor()
    IL_0006:  stloc.0
//000033:             t.AutoSize = false;
    IL_0007:  ldloc.0
    IL_0008:  ldc.i4.0
    IL_0009:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_000e:  nop
//000034:             t.Height = 16;
    IL_000f:  ldloc.0
    IL_0010:  ldc.i4.s   16
    IL_0012:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Height(int32)
    IL_0017:  nop
//000035:             t.TickStyle = TickStyle.None;
    IL_0018:  ldloc.0
    IL_0019:  ldc.i4.0
    IL_001a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_TickStyle(valuetype [System.Windows.Forms]System.Windows.Forms.TickStyle)
    IL_001f:  nop
//000036:             t.Minimum = 0;
    IL_0020:  ldloc.0
    IL_0021:  ldc.i4.0
    IL_0022:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_0027:  nop
//000037:             t.Maximum = 100;
    IL_0028:  ldloc.0
    IL_0029:  ldc.i4.s   100
    IL_002b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_0030:  nop
//000038:             t.Value = 0;
    IL_0031:  ldloc.0
    IL_0032:  ldc.i4.0
    IL_0033:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_0038:  nop
//000039:             return t;
    IL_0039:  ldloc.0
    IL_003a:  stloc.1
    IL_003b:  br.s       IL_003d

//000040:         }
    IL_003d:  ldloc.1
    IL_003e:  ret
  } // end of method ToolStripTrackBar::CreateControlInstance

  .method public hidebysig specialname instance int32 
          get_Value() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] int32 CS$1$0000)
//000041: 
//000042:         /// <summary>Gets the current TrackBar value.</summary>
//000043:         [DefaultValue(0)]
//000044:         public int Value { get { return TrackBar.Value; } set { TrackBar.Value = value; } }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_Value

  .method public hidebysig specialname instance void 
          set_Value(int32 'value') cil managed
  {
    // Code size       15 (0xf)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  ldarg.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_000d:  nop
    IL_000e:  ret
  } // end of method ToolStripTrackBar::set_Value

  .method public hidebysig specialname instance int32 
          get_Minimum() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] int32 CS$1$0000)
//000045: 
//000046:         /// <summary>Gets the minimum TrackBar value.</summary>
//000047:         [DefaultValue(0)]
//000048:         public int Minimum { get { return TrackBar.Minimum; } set { TrackBar.Minimum = value; } }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Minimum()
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_Minimum

  .method public hidebysig specialname instance void 
          set_Minimum(int32 'value') cil managed
  {
    // Code size       15 (0xf)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  ldarg.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_000d:  nop
    IL_000e:  ret
  } // end of method ToolStripTrackBar::set_Minimum

  .method public hidebysig specialname instance int32 
          get_Maximum() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] int32 CS$1$0000)
//000049: 
//000050:         /// <summary>Gets the maximum TrackBar value.</summary>
//000051:         [DefaultValue(100)]
//000052:         public int Maximum { get { return TrackBar.Maximum; } set { TrackBar.Maximum = value; } }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Maximum()
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_Maximum

  .method public hidebysig specialname instance void 
          set_Maximum(int32 'value') cil managed
  {
    // Code size       15 (0xf)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  ldarg.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_000d:  nop
    IL_000e:  ret
  } // end of method ToolStripTrackBar::set_Maximum

  .method family hidebysig virtual instance void 
          OnSubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control control) cil managed
  {
    // Code size       34 (0x22)
    .maxstack  8
//000053: 
//000054:         /// <summary>Attach to events that need to be wrapped.</summary>
//000055:         protected override void OnSubscribeControlEvents(Control control)
//000056:         {
    IL_0000:  nop
//000057:             base.OnSubscribeControlEvents(control);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  call       instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::OnSubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0008:  nop
//000058:             ((TrackBar)control).ValueChanged += trackBar_ValueChanged;
    IL_0009:  ldarg.1
    IL_000a:  castclass  [System.Windows.Forms]System.Windows.Forms.TrackBar
    IL_000f:  ldarg.0
    IL_0010:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::trackBar_ValueChanged(object,
                                                                                                                                               class [mscorlib]System.EventArgs)
    IL_0016:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_001b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    IL_0020:  nop
//000059:         }
    IL_0021:  ret
  } // end of method ToolStripTrackBar::OnSubscribeControlEvents

  .method family hidebysig virtual instance void 
          OnUnsubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control control) cil managed
  {
    // Code size       34 (0x22)
    .maxstack  8
//000060: 
//000061:         /// <summary>Detach from events that were wrapped.</summary>
//000062:         protected override void OnUnsubscribeControlEvents(Control control)
//000063:         {
    IL_0000:  nop
//000064:             base.OnUnsubscribeControlEvents(control);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  call       instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::OnUnsubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0008:  nop
//000065:             ((TrackBar)control).ValueChanged -= trackBar_ValueChanged;
    IL_0009:  ldarg.1
    IL_000a:  castclass  [System.Windows.Forms]System.Windows.Forms.TrackBar
    IL_000f:  ldarg.0
    IL_0010:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::trackBar_ValueChanged(object,
                                                                                                                                               class [mscorlib]System.EventArgs)
    IL_0016:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_001b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::remove_ValueChanged(class [mscorlib]System.EventHandler)
    IL_0020:  nop
//000066:         }
    IL_0021:  ret
  } // end of method ToolStripTrackBar::OnUnsubscribeControlEvents

  .method private hidebysig instance void 
          trackBar_ValueChanged(object sender,
                                class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000067: 
//000068:         /// <summary>Raise the ValueChanged event.</summary>
//000069:         void trackBar_ValueChanged(object sender, EventArgs e)
//000070:         {
    IL_0000:  nop
//000071:             if (ValueChanged != null) ValueChanged(sender, e);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChanged
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  stloc.0
//000072:         }
//000073: 
//000074:         /// <summary>Event used to notify when the TrackBar's value changes.</summary>
//000075:         public event EventHandler ValueChanged;
//000076: 
//000077:         /// <summary>Gets the default size for the control.</summary>
//000078:         protected override Size DefaultSize { get { return new Size(200, 16); } }
//000079:     }
//000080: }
    IL_000b:  ldloc.0
    IL_000c:  brtrue.s   IL_001c

//000071:             if (ValueChanged != null) ValueChanged(sender, e);
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChanged
    IL_0014:  ldarg.1
    IL_0015:  ldarg.2
    IL_0016:  callvirt   instance void [mscorlib]System.EventHandler::Invoke(object,
                                                                             class [mscorlib]System.EventArgs)
    IL_001b:  nop
//000072:         }
    IL_001c:  ret
  } // end of method ToolStripTrackBar::trackBar_ValueChanged

  .method public hidebysig specialname instance void 
          add_ValueChanged(class [mscorlib]System.EventHandler 'value') cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init (class [mscorlib]System.EventHandler V_0,
             class [mscorlib]System.EventHandler V_1,
             class [mscorlib]System.EventHandler V_2,
             bool V_3)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChanged
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldarg.1
    IL_000b:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate,
                                                                                            class [mscorlib]System.Delegate)
    IL_0010:  castclass  [mscorlib]System.EventHandler
    IL_0015:  stloc.2
    IL_0016:  ldarg.0
    IL_0017:  ldflda     class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChanged
    IL_001c:  ldloc.2
    IL_001d:  ldloc.1
    IL_001e:  call       !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [mscorlib]System.EventHandler>(!!0&,
                                                                                                                          !!0,
                                                                                                                          !!0)
    IL_0023:  stloc.0
    IL_0024:  ldloc.0
    IL_0025:  ldloc.1
    IL_0026:  ceq
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.3
    IL_002c:  ldloc.3
    IL_002d:  brtrue.s   IL_0007

    IL_002f:  ret
  } // end of method ToolStripTrackBar::add_ValueChanged

  .method public hidebysig specialname instance void 
          remove_ValueChanged(class [mscorlib]System.EventHandler 'value') cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init (class [mscorlib]System.EventHandler V_0,
             class [mscorlib]System.EventHandler V_1,
             class [mscorlib]System.EventHandler V_2,
             bool V_3)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChanged
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldarg.1
    IL_000b:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Remove(class [mscorlib]System.Delegate,
                                                                                           class [mscorlib]System.Delegate)
    IL_0010:  castclass  [mscorlib]System.EventHandler
    IL_0015:  stloc.2
    IL_0016:  ldarg.0
    IL_0017:  ldflda     class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChanged
    IL_001c:  ldloc.2
    IL_001d:  ldloc.1
    IL_001e:  call       !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [mscorlib]System.EventHandler>(!!0&,
                                                                                                                          !!0,
                                                                                                                          !!0)
    IL_0023:  stloc.0
    IL_0024:  ldloc.0
    IL_0025:  ldloc.1
    IL_0026:  ceq
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.3
    IL_002c:  ldloc.3
    IL_002d:  brtrue.s   IL_0007

    IL_002f:  ret
  } // end of method ToolStripTrackBar::remove_ValueChanged

  .method family hidebysig specialname virtual 
          instance valuetype [System.Drawing]System.Drawing.Size 
          get_DefaultSize() cil managed
  {
    // Code size       18 (0x12)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Size CS$1$0000)
//000073: 
//000074:         /// <summary>Event used to notify when the TrackBar's value changes.</summary>
//000075:         public event EventHandler ValueChanged;
//000076: 
//000077:         /// <summary>Gets the default size for the control.</summary>
//000078:         protected override Size DefaultSize { get { return new Size(200, 16); } }
    IL_0000:  nop
    IL_0001:  ldc.i4     0xc8
    IL_0006:  ldc.i4.s   16
    IL_0008:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_000d:  stloc.0
    IL_000e:  br.s       IL_0010

    IL_0010:  ldloc.0
    IL_0011:  ret
  } // end of method ToolStripTrackBar::get_DefaultSize

  .event [mscorlib]System.EventHandler ValueChanged
  {
    .addon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    .removeon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::remove_ValueChanged(class [mscorlib]System.EventHandler)
  } // end of event ToolStripTrackBar::ValueChanged
  .property instance class [System.Windows.Forms]System.Windows.Forms.TrackBar
          TrackBar()
  {
    .get instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
  } // end of property ToolStripTrackBar::TrackBar
  .property instance int32 Value()
  {
    .custom instance void [System]System.ComponentModel.DefaultValueAttribute::.ctor(int32) = ( 01 00 00 00 00 00 00 00 ) 
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Value(int32)
    .get instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
  } // end of property ToolStripTrackBar::Value
  .property instance int32 Minimum()
  {
    .custom instance void [System]System.ComponentModel.DefaultValueAttribute::.ctor(int32) = ( 01 00 00 00 00 00 00 00 ) 
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Minimum(int32)
    .get instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Minimum()
  } // end of property ToolStripTrackBar::Minimum
  .property instance int32 Maximum()
  {
    .custom instance void [System]System.ComponentModel.DefaultValueAttribute::.ctor(int32) = ( 01 00 64 00 00 00 00 00 )                         // ..d.....
    .get instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Maximum()
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Maximum(int32)
  } // end of property ToolStripTrackBar::Maximum
  .property instance valuetype [System.Drawing]System.Drawing.Size
          DefaultSize()
  {
    .get instance valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_DefaultSize()
  } // end of property ToolStripTrackBar::DefaultSize
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation
       extends [mscorlib]System.Object
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass1'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 width
    .field public valuetype [System.Drawing]System.Drawing.Rectangle[] pathsBounds
    .field public class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> compositions
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation '<>4__this'
    .field public int32 epsilon
    .field public class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> paths
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass1'::.ctor

  } // end of class '<>c__DisplayClass1'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass3'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap fastColorizedImage
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass3'::.ctor

  } // end of class '<>c__DisplayClass3'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass5'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap fastOriginalImage
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass5'::.ctor

  } // end of class '<>c__DisplayClass5'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass7'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5' 'CS$<>8__locals6'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3' 'CS$<>8__locals4'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' 'CS$<>8__locals2'
    .field public class [mscorlib]System.Collections.Generic.List`1<float32> selectedHues
    .field public int64 totalPixels
    .field public int64 pixelsProcessed
    .field public int32 saturationWindow
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass7'::.ctor

    .method public hidebysig instance void 
            '<Colorize>b__0'(int32 y) cil managed
    {
      // Code size       647 (0x287)
      .maxstack  5
      .locals init ([0] int32 x,
               [1] valuetype [System.Drawing]System.Drawing.Color c,
               [2] float32 pixelHue,
               [3] bool pixelInSelectedRegion,
               [4] valuetype [System.Drawing]System.Drawing.Point p,
               [5] int32 i,
               [6] valuetype [System.Drawing]System.Drawing.RectangleF bound,
               [7] bool useGrayscale,
               [8] float32 selectedHue,
               [9] float32 distance,
               [10] bool CS$4$0000,
               [11] valuetype [System.Drawing]System.Drawing.RectangleF[] CS$6$0001,
               [12] int32 CS$7$0002,
               [13] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32> CS$5$0003)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs' 
//000099:                 {
      IL_0000:  nop
//000100:                     for (int x = 0; x < width; x++)
      IL_0001:  ldc.i4.0
      IL_0002:  stloc.0
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_0003:  br         IL_0232

//000101:                     {
      IL_0008:  nop
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
      IL_0009:  ldarg.0
      IL_000a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals6'
      IL_000f:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5'::fastOriginalImage
      IL_0014:  ldloc.0
      IL_0015:  ldarg.1
      IL_0016:  callvirt   instance valuetype [System.Drawing]System.Drawing.Color [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::GetColor(int32,
                                                                                                                                                    int32)
      IL_001b:  stloc.1
//000104:                         float pixelHue = c.GetHue();
      IL_001c:  ldloca.s   c
      IL_001e:  call       instance float32 [System.Drawing]System.Drawing.Color::GetHue()
      IL_0023:  stloc.2
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
      IL_0024:  ldc.i4.0
      IL_0025:  stloc.3
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
      IL_0026:  ldarg.0
      IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_002c:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
      IL_0031:  brfalse.s  IL_004b

      IL_0033:  ldarg.0
      IL_0034:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_0039:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
      IL_003e:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
      IL_0043:  ldc.i4.0
      IL_0044:  ceq
      IL_0046:  ldc.i4.0
      IL_0047:  ceq
      IL_0049:  br.s       IL_004c

      IL_004b:  ldc.i4.0
      IL_004c:  stloc.s    CS$4$0000
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_004e:  ldloc.s    CS$4$0000
      IL_0050:  brtrue.s   IL_0059

//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
      IL_0052:  ldc.i4.1
      IL_0053:  stloc.3
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_0054:  br         IL_0113

//000113:                         {
      IL_0059:  nop
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
      IL_005a:  ldloca.s   p
      IL_005c:  ldloc.0
      IL_005d:  ldarg.1
      IL_005e:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_0063:  nop
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
      IL_0064:  ldc.i4.0
      IL_0065:  stloc.s    i
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_0067:  br         IL_00f1

//000118:                             {
      IL_006c:  nop
//000119:                                 if (pathsBounds[i].Contains(p))
      IL_006d:  ldarg.0
      IL_006e:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_0073:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::pathsBounds
      IL_0078:  ldloc.s    i
      IL_007a:  ldelema    [System.Drawing]System.Drawing.Rectangle
      IL_007f:  ldloc.s    p
      IL_0081:  call       instance bool [System.Drawing]System.Drawing.Rectangle::Contains(valuetype [System.Drawing]System.Drawing.Point)
      IL_0086:  ldc.i4.0
      IL_0087:  ceq
      IL_0089:  stloc.s    CS$4$0000
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_008b:  ldloc.s    CS$4$0000
      IL_008d:  brtrue.s   IL_00ea

//000120:                                 {
      IL_008f:  nop
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
      IL_0090:  nop
      IL_0091:  ldarg.0
      IL_0092:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_0097:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::compositions
      IL_009c:  ldloc.s    i
      IL_009e:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]>::get_Item(int32)
      IL_00a3:  stloc.s    CS$6$0001
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_00a5:  ldc.i4.0
      IL_00a6:  stloc.s    CS$7$0002
      IL_00a8:  br.s       IL_00db

//000124:                                     foreach (RectangleF bound in compositions[i])
      IL_00aa:  ldloc.s    CS$6$0001
      IL_00ac:  ldloc.s    CS$7$0002
      IL_00ae:  ldelema    [System.Drawing]System.Drawing.RectangleF
      IL_00b3:  ldobj      [System.Drawing]System.Drawing.RectangleF
      IL_00b8:  stloc.s    bound
//000125:                                     {
      IL_00ba:  nop
//000126:                                         if (bound.Contains(x, y))
      IL_00bb:  ldloca.s   bound
      IL_00bd:  ldloc.0
      IL_00be:  conv.r4
      IL_00bf:  ldarg.1
      IL_00c0:  conv.r4
      IL_00c1:  call       instance bool [System.Drawing]System.Drawing.RectangleF::Contains(float32,
                                                                                             float32)
      IL_00c6:  ldc.i4.0
      IL_00c7:  ceq
      IL_00c9:  stloc.s    CS$4$0000
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_00cb:  ldloc.s    CS$4$0000
      IL_00cd:  brtrue.s   IL_00d4

//000127:                                         {
      IL_00cf:  nop
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
      IL_00d0:  ldc.i4.1
      IL_00d1:  stloc.3
//000130:                                             break;
      IL_00d2:  br.s       IL_00e9

//000131:                                         }
//000132:                                     }
      IL_00d4:  nop
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_00d5:  ldloc.s    CS$7$0002
      IL_00d7:  ldc.i4.1
      IL_00d8:  add
      IL_00d9:  stloc.s    CS$7$0002
//000124:                                     foreach (RectangleF bound in compositions[i])
      IL_00db:  ldloc.s    CS$7$0002
      IL_00dd:  ldloc.s    CS$6$0001
      IL_00df:  ldlen
      IL_00e0:  conv.i4
      IL_00e1:  clt
      IL_00e3:  stloc.s    CS$4$0000
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_00e5:  ldloc.s    CS$4$0000
      IL_00e7:  brtrue.s   IL_00aa

//000133:                                 }
      IL_00e9:  nop
//000134:                             }
      IL_00ea:  nop
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
      IL_00eb:  ldloc.s    i
      IL_00ed:  ldc.i4.1
      IL_00ee:  add
      IL_00ef:  stloc.s    i
      IL_00f1:  ldloc.s    i
      IL_00f3:  ldarg.0
      IL_00f4:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_00f9:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::pathsBounds
      IL_00fe:  ldlen
      IL_00ff:  conv.i4
      IL_0100:  bge.s      IL_0108

      IL_0102:  ldloc.3
      IL_0103:  ldc.i4.0
      IL_0104:  ceq
      IL_0106:  br.s       IL_0109

      IL_0108:  ldc.i4.0
      IL_0109:  stloc.s    CS$4$0000
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_010b:  ldloc.s    CS$4$0000
      IL_010d:  brtrue     IL_006c

//000135:                         }
      IL_0112:  nop
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
      IL_0113:  ldc.i4.1
      IL_0114:  stloc.s    useGrayscale
//000142:                         if (pixelInSelectedRegion)
      IL_0116:  ldloc.3
      IL_0117:  ldc.i4.0
      IL_0118:  ceq
      IL_011a:  stloc.s    CS$4$0000
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_011c:  ldloc.s    CS$4$0000
      IL_011e:  brtrue     IL_0207

//000143:                         {
      IL_0123:  nop
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
      IL_0124:  nop
      IL_0125:  ldarg.0
      IL_0126:  ldfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::selectedHues
      IL_012b:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<float32>::GetEnumerator()
      IL_0130:  stloc.s    CS$5$0003
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      .try
      {
        IL_0132:  br         IL_01e4

//000149:                             foreach (float selectedHue in selectedHues)
        IL_0137:  ldloca.s   CS$5$0003
        IL_0139:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32>::get_Current()
        IL_013e:  conv.r4
        IL_013f:  stloc.s    selectedHue
//000150:                             {
        IL_0141:  nop
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
        IL_0142:  ldloc.2
        IL_0143:  ldloc.s    selectedHue
        IL_0145:  sub
        IL_0146:  call       float32 [mscorlib]System.Math::Abs(float32)
        IL_014b:  stloc.s    distance
//000164:                                 if (distance > 180) distance = 360 - distance;
        IL_014d:  ldloc.s    distance
        IL_014f:  ldc.r4     180.
        IL_0154:  cgt
        IL_0156:  ldc.i4.0
        IL_0157:  ceq
        IL_0159:  stloc.s    CS$4$0000
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_015b:  ldloc.s    CS$4$0000
        IL_015d:  brtrue.s   IL_0169

//000164:                                 if (distance > 180) distance = 360 - distance;
        IL_015f:  ldc.r4     360.
        IL_0164:  ldloc.s    distance
        IL_0166:  sub
        IL_0167:  stloc.s    distance
//000165: 
//000166:                                 if (distance <= epsilon)
        IL_0169:  ldloc.s    distance
        IL_016b:  ldarg.0
        IL_016c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
        IL_0171:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::epsilon
        IL_0176:  conv.r4
        IL_0177:  cgt.un
        IL_0179:  stloc.s    CS$4$0000
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_017b:  ldloc.s    CS$4$0000
        IL_017d:  brtrue.s   IL_0185

//000167:                                 {
        IL_017f:  nop
//000168:                                     useGrayscale = false;
        IL_0180:  ldc.i4.0
        IL_0181:  stloc.s    useGrayscale
//000169:                                     break;
        IL_0183:  br.s       IL_01f4

//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
        IL_0185:  ldloc.s    distance
        IL_0187:  ldarg.0
        IL_0188:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
        IL_018d:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::epsilon
        IL_0192:  conv.r4
        IL_0193:  sub
        IL_0194:  ldarg.0
        IL_0195:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::saturationWindow
        IL_019a:  conv.r4
        IL_019b:  div
        IL_019c:  ldc.r4     1.
        IL_01a1:  clt
        IL_01a3:  ldc.i4.0
        IL_01a4:  ceq
        IL_01a6:  stloc.s    CS$4$0000
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_01a8:  ldloc.s    CS$4$0000
        IL_01aa:  brtrue.s   IL_01e3

//000172:                                 {
        IL_01ac:  nop
//000173:                                     useGrayscale = false;
        IL_01ad:  ldc.i4.0
        IL_01ae:  stloc.s    useGrayscale
//000174:                                     c = ColorFromHsb(
        IL_01b0:  ldloc.2
        IL_01b1:  ldloca.s   c
        IL_01b3:  call       instance float32 [System.Drawing]System.Drawing.Color::GetSaturation()
        IL_01b8:  ldc.r4     1.
        IL_01bd:  ldloc.s    distance
        IL_01bf:  ldarg.0
        IL_01c0:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
        IL_01c5:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::epsilon
        IL_01ca:  conv.r4
        IL_01cb:  sub
        IL_01cc:  ldc.r4     10.
        IL_01d1:  div
        IL_01d2:  sub
        IL_01d3:  mul
        IL_01d4:  ldloca.s   c
        IL_01d6:  call       instance float32 [System.Drawing]System.Drawing.Color::GetBrightness()
        IL_01db:  call       valuetype [System.Drawing]System.Drawing.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ColorFromHsb(float32,
                                                                                                                                                                           float32,
                                                                                                                                                                           float32)
        IL_01e0:  stloc.1
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
        IL_01e1:  br.s       IL_01f4

//000179:                                 }
//000180:                             }
        IL_01e3:  nop
//000149:                             foreach (float selectedHue in selectedHues)
        IL_01e4:  ldloca.s   CS$5$0003
        IL_01e6:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32>::MoveNext()
        IL_01eb:  stloc.s    CS$4$0000
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_01ed:  ldloc.s    CS$4$0000
        IL_01ef:  brtrue     IL_0137

        IL_01f4:  leave.s    IL_0205

      }  // end .try
      finally
      {
        IL_01f6:  ldloca.s   CS$5$0003
        IL_01f8:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32>
        IL_01fe:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_0203:  nop
        IL_0204:  endfinally
      }  // end handler
      IL_0205:  nop
//000181:                         }
      IL_0206:  nop
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
      IL_0207:  ldloc.s    useGrayscale
      IL_0209:  ldc.i4.0
      IL_020a:  ceq
      IL_020c:  stloc.s    CS$4$0000
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_020e:  ldloc.s    CS$4$0000
      IL_0210:  brtrue.s   IL_0219

//000184:                         if (useGrayscale) c = ToGrayscale(c);
      IL_0212:  ldloc.1
      IL_0213:  call       valuetype [System.Drawing]System.Drawing.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ToGrayscale(valuetype [System.Drawing]System.Drawing.Color)
      IL_0218:  stloc.1
//000185:                         fastColorizedImage.SetColor(x, y, c);
      IL_0219:  ldarg.0
      IL_021a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals4'
      IL_021f:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3'::fastColorizedImage
      IL_0224:  ldloc.0
      IL_0225:  ldarg.1
      IL_0226:  ldloc.1
      IL_0227:  callvirt   instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::SetColor(int32,
                                                                                                          int32,
                                                                                                          valuetype [System.Drawing]System.Drawing.Color)
      IL_022c:  nop
//000186:                     }
      IL_022d:  nop
//000100:                     for (int x = 0; x < width; x++)
      IL_022e:  ldloc.0
      IL_022f:  ldc.i4.1
      IL_0230:  add
      IL_0231:  stloc.0
      IL_0232:  ldloc.0
      IL_0233:  ldarg.0
      IL_0234:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_0239:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::width
      IL_023e:  clt
      IL_0240:  stloc.s    CS$4$0000
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_0242:  ldloc.s    CS$4$0000
      IL_0244:  brtrue     IL_0008

//000189:                     Interlocked.Add(ref pixelsProcessed, width);
      IL_0249:  ldarg.0
      IL_024a:  ldflda     int64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::pixelsProcessed
      IL_024f:  ldarg.0
      IL_0250:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_0255:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::width
      IL_025a:  conv.i8
      IL_025b:  call       int64 [mscorlib]System.Threading.Interlocked::Add(int64&,
                                                                             int64)
      IL_0260:  pop
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
      IL_0261:  ldarg.0
      IL_0262:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
      IL_0267:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::'<>4__this'
      IL_026c:  ldc.i4.s   100
      IL_026e:  conv.i8
      IL_026f:  ldarg.0
      IL_0270:  ldfld      int64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::pixelsProcessed
      IL_0275:  mul
      IL_0276:  conv.r8
      IL_0277:  ldarg.0
      IL_0278:  ldfld      int64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::totalPixels
      IL_027d:  conv.r8
      IL_027e:  div
      IL_027f:  conv.i4
      IL_0280:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::OnProgressChanged(int32)
      IL_0285:  nop
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_0286:  ret
    } // end of method '<>c__DisplayClass7'::'<Colorize>b__0'

  } // end of class '<>c__DisplayClass7'

  .field private class [System]System.ComponentModel.ProgressChangedEventHandler ProgressChanged
  .method public hidebysig specialname instance void 
          add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler 'value') cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init (class [System]System.ComponentModel.ProgressChangedEventHandler V_0,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_1,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_2,
             bool V_3)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChanged
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldarg.1
    IL_000b:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate,
                                                                                            class [mscorlib]System.Delegate)
    IL_0010:  castclass  [System]System.ComponentModel.ProgressChangedEventHandler
    IL_0015:  stloc.2
    IL_0016:  ldarg.0
    IL_0017:  ldflda     class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChanged
    IL_001c:  ldloc.2
    IL_001d:  ldloc.1
    IL_001e:  call       !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [System]System.ComponentModel.ProgressChangedEventHandler>(!!0&,
                                                                                                                                                      !!0,
                                                                                                                                                      !!0)
    IL_0023:  stloc.0
    IL_0024:  ldloc.0
    IL_0025:  ldloc.1
    IL_0026:  ceq
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.3
    IL_002c:  ldloc.3
    IL_002d:  brtrue.s   IL_0007

    IL_002f:  ret
  } // end of method ImageManipulation::add_ProgressChanged

  .method public hidebysig specialname instance void 
          remove_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler 'value') cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init (class [System]System.ComponentModel.ProgressChangedEventHandler V_0,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_1,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_2,
             bool V_3)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChanged
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldarg.1
    IL_000b:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Remove(class [mscorlib]System.Delegate,
                                                                                           class [mscorlib]System.Delegate)
    IL_0010:  castclass  [System]System.ComponentModel.ProgressChangedEventHandler
    IL_0015:  stloc.2
    IL_0016:  ldarg.0
    IL_0017:  ldflda     class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChanged
    IL_001c:  ldloc.2
    IL_001d:  ldloc.1
    IL_001e:  call       !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [System]System.ComponentModel.ProgressChangedEventHandler>(!!0&,
                                                                                                                                                      !!0,
                                                                                                                                                      !!0)
    IL_0023:  stloc.0
    IL_0024:  ldloc.0
    IL_0025:  ldloc.1
    IL_0026:  ceq
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.3
    IL_002c:  ldloc.3
    IL_002d:  brtrue.s   IL_0007

    IL_002f:  ret
  } // end of method ImageManipulation::remove_ProgressChanged

  .method public hidebysig instance class [System.Drawing]System.Drawing.Bitmap 
          Colorize(class [System.Drawing]System.Drawing.Bitmap original,
                   class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> selectedPixels,
                   int32 epsilon,
                   class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> paths,
                   bool parallel) cil managed
  {
    // Code size       825 (0x339)
    .maxstack  4
    .locals init ([0] int32 height,
             [1] class [System.Drawing]System.Drawing.Bitmap colorizedImage,
             [2] int32 i,
             [3] class [System.Drawing]System.Drawing.Drawing2D.Matrix m,
             [4] class [System.Drawing]System.Drawing.Region r,
             [5] valuetype [System.Drawing]System.Drawing.Point p,
             [6] int64 pixelsPerProgressUpdate,
             [7] class [mscorlib]System.Action`1<int32> processRow,
             [8] int32 y,
             [9] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7' 'CS$<>8__locals8',
             [10] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5' 'CS$<>8__locals6',
             [11] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3' 'CS$<>8__locals4',
             [12] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' 'CS$<>8__locals2',
             [13] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [14] bool CS$4$0001,
             [15] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point> CS$5$0002,
             [16] valuetype [System.Drawing]System.Drawing.Color CS$0$0003)
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::.ctor()
    IL_0005:  stloc.s    'CS$<>8__locals2'
    IL_0007:  ldloc.s    'CS$<>8__locals2'
    IL_0009:  ldarg.3
    IL_000a:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::epsilon
    IL_000f:  ldloc.s    'CS$<>8__locals2'
    IL_0011:  ldarg.s    paths
    IL_0013:  stfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_0018:  ldloc.s    'CS$<>8__locals2'
    IL_001a:  ldarg.0
    IL_001b:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::'<>4__this'
//000036:         {
    IL_0020:  nop
//000037:             // Create a new bitmap with the same size as the original
//000038:             int width = original.Width, height = original.Height;
    IL_0021:  ldloc.s    'CS$<>8__locals2'
    IL_0023:  ldarg.1
    IL_0024:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0029:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::width
    IL_002e:  ldarg.1
    IL_002f:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0034:  stloc.0
//000039:             Bitmap colorizedImage = new Bitmap(width, height);
    IL_0035:  ldloc.s    'CS$<>8__locals2'
    IL_0037:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::width
    IL_003c:  ldloc.0
    IL_003d:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32)
    IL_0042:  stloc.1
//000040: 
//000041:             // Optimization: For every GraphicsPath, get a bounding rectangle.  This allows for quickly
//000042:             // ruling out pixels that are definitely not containing within the selected region.
//000043:             Rectangle [] pathsBounds = null;
    IL_0043:  ldloc.s    'CS$<>8__locals2'
    IL_0045:  ldnull
    IL_0046:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::pathsBounds
//000044:             if (paths != null && paths.Count > 0) 
    IL_004b:  ldloc.s    'CS$<>8__locals2'
    IL_004d:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_0052:  brfalse.s  IL_0068

    IL_0054:  ldloc.s    'CS$<>8__locals2'
    IL_0056:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_005b:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_0060:  ldc.i4.0
    IL_0061:  cgt
    IL_0063:  ldc.i4.0
    IL_0064:  ceq
    IL_0066:  br.s       IL_0069

    IL_0068:  ldc.i4.1
    IL_0069:  stloc.s    CS$4$0001
//000045:             {
//000046:                 pathsBounds = new Rectangle[paths.Count];
//000047:                 for(int i=0; i<pathsBounds.Length; i++)
//000048:                 {
//000049:                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
//000050:                 }
//000051:             }
//000052: 
//000053:             // Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000054:             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000055:             // with rectangles which can be hit tested against instead of the paths.  Not quite
//000056:             // as accurate, but much faster.
//000057:             List<RectangleF[]> compositions = null;
//000058:             if (paths != null && paths.Count > 0)
//000059:             {
//000060:                 compositions = new List<RectangleF[]>(paths.Count);
//000061:                 using (Matrix m = new Matrix())
//000062:                 {
//000063:                     for(int i=0; i<paths.Count; i++)
//000064:                     {
//000065:                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
//000066:                     }
//000067:                 }
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_006b:  ldloc.s    CS$4$0001
    IL_006d:  brtrue.s   IL_00ce

//000045:             {
    IL_006f:  nop
//000046:                 pathsBounds = new Rectangle[paths.Count];
    IL_0070:  ldloc.s    'CS$<>8__locals2'
    IL_0072:  ldloc.s    'CS$<>8__locals2'
    IL_0074:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_0079:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_007e:  newarr     [System.Drawing]System.Drawing.Rectangle
    IL_0083:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::pathsBounds
//000047:                 for(int i=0; i<pathsBounds.Length; i++)
    IL_0088:  ldc.i4.0
    IL_0089:  stloc.2
//000048:                 {
//000049:                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
//000050:                 }
//000051:             }
//000052: 
//000053:             // Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000054:             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000055:             // with rectangles which can be hit tested against instead of the paths.  Not quite
//000056:             // as accurate, but much faster.
//000057:             List<RectangleF[]> compositions = null;
//000058:             if (paths != null && paths.Count > 0)
//000059:             {
//000060:                 compositions = new List<RectangleF[]>(paths.Count);
//000061:                 using (Matrix m = new Matrix())
//000062:                 {
//000063:                     for(int i=0; i<paths.Count; i++)
//000064:                     {
//000065:                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
//000066:                     }
//000067:                 }
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_008a:  br.s       IL_00bb

//000048:                 {
    IL_008c:  nop
//000049:                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
    IL_008d:  ldloc.s    'CS$<>8__locals2'
    IL_008f:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::pathsBounds
    IL_0094:  ldloc.2
    IL_0095:  ldelema    [System.Drawing]System.Drawing.Rectangle
    IL_009a:  ldloc.s    'CS$<>8__locals2'
    IL_009c:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_00a1:  ldloc.2
    IL_00a2:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Item(int32)
    IL_00a7:  callvirt   instance valuetype [System.Drawing]System.Drawing.RectangleF [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::GetBounds()
    IL_00ac:  call       valuetype [System.Drawing]System.Drawing.Rectangle [System.Drawing]System.Drawing.Rectangle::Ceiling(valuetype [System.Drawing]System.Drawing.RectangleF)
    IL_00b1:  stobj      [System.Drawing]System.Drawing.Rectangle
//000050:                 }
    IL_00b6:  nop
//000047:                 for(int i=0; i<pathsBounds.Length; i++)
    IL_00b7:  ldloc.2
    IL_00b8:  ldc.i4.1
    IL_00b9:  add
    IL_00ba:  stloc.2
    IL_00bb:  ldloc.2
    IL_00bc:  ldloc.s    'CS$<>8__locals2'
    IL_00be:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::pathsBounds
    IL_00c3:  ldlen
    IL_00c4:  conv.i4
    IL_00c5:  clt
    IL_00c7:  stloc.s    CS$4$0001
//000048:                 {
//000049:                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
//000050:                 }
//000051:             }
//000052: 
//000053:             // Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000054:             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000055:             // with rectangles which can be hit tested against instead of the paths.  Not quite
//000056:             // as accurate, but much faster.
//000057:             List<RectangleF[]> compositions = null;
//000058:             if (paths != null && paths.Count > 0)
//000059:             {
//000060:                 compositions = new List<RectangleF[]>(paths.Count);
//000061:                 using (Matrix m = new Matrix())
//000062:                 {
//000063:                     for(int i=0; i<paths.Count; i++)
//000064:                     {
//000065:                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
//000066:                     }
//000067:                 }
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_00c9:  ldloc.s    CS$4$0001
    IL_00cb:  brtrue.s   IL_008c

//000051:             }
    IL_00cd:  nop
//000052: 
//000053:             // Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000054:             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000055:             // with rectangles which can be hit tested against instead of the paths.  Not quite
//000056:             // as accurate, but much faster.
//000057:             List<RectangleF[]> compositions = null;
    IL_00ce:  ldloc.s    'CS$<>8__locals2'
    IL_00d0:  ldnull
    IL_00d1:  stfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::compositions
//000058:             if (paths != null && paths.Count > 0)
    IL_00d6:  ldloc.s    'CS$<>8__locals2'
    IL_00d8:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_00dd:  brfalse.s  IL_00f3

    IL_00df:  ldloc.s    'CS$<>8__locals2'
    IL_00e1:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_00e6:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_00eb:  ldc.i4.0
    IL_00ec:  cgt
    IL_00ee:  ldc.i4.0
    IL_00ef:  ceq
    IL_00f1:  br.s       IL_00f4

    IL_00f3:  ldc.i4.1
    IL_00f4:  stloc.s    CS$4$0001
//000059:             {
//000060:                 compositions = new List<RectangleF[]>(paths.Count);
//000061:                 using (Matrix m = new Matrix())
//000062:                 {
//000063:                     for(int i=0; i<paths.Count; i++)
//000064:                     {
//000065:                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
//000066:                     }
//000067:                 }
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_00f6:  ldloc.s    CS$4$0001
    IL_00f8:  brtrue     IL_0193

//000059:             {
    IL_00fd:  nop
//000060:                 compositions = new List<RectangleF[]>(paths.Count);
    IL_00fe:  ldloc.s    'CS$<>8__locals2'
    IL_0100:  ldloc.s    'CS$<>8__locals2'
    IL_0102:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
    IL_0107:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_010c:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]>::.ctor(int32)
    IL_0111:  stfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::compositions
//000061:                 using (Matrix m = new Matrix())
    IL_0116:  newobj     instance void [System.Drawing]System.Drawing.Drawing2D.Matrix::.ctor()
    IL_011b:  stloc.3
//000062:                 {
    .try
    {
      IL_011c:  nop
//000063:                     for(int i=0; i<paths.Count; i++)
      IL_011d:  ldc.i4.0
      IL_011e:  stloc.2
//000064:                     {
//000065:                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
//000066:                     }
//000067:                 }
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_011f:  br.s       IL_0167

//000064:                     {
      IL_0121:  nop
//000065:                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
      IL_0122:  ldloc.s    'CS$<>8__locals2'
      IL_0124:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
      IL_0129:  ldloc.2
      IL_012a:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Item(int32)
      IL_012f:  newobj     instance void [System.Drawing]System.Drawing.Region::.ctor(class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath)
      IL_0134:  stloc.s    r
      .try
      {
        IL_0136:  ldloc.s    'CS$<>8__locals2'
        IL_0138:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::compositions
        IL_013d:  ldloc.s    r
        IL_013f:  ldloc.3
        IL_0140:  callvirt   instance valuetype [System.Drawing]System.Drawing.RectangleF[] [System.Drawing]System.Drawing.Region::GetRegionScans(class [System.Drawing]System.Drawing.Drawing2D.Matrix)
        IL_0145:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]>::Add(!0)
        IL_014a:  nop
//000066:                     }
//000067:                 }
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_014b:  leave.s    IL_0161

      }  // end .try
      finally
      {
        IL_014d:  ldloc.s    r
        IL_014f:  ldnull
        IL_0150:  ceq
        IL_0152:  stloc.s    CS$4$0001
        IL_0154:  ldloc.s    CS$4$0001
        IL_0156:  brtrue.s   IL_0160

        IL_0158:  ldloc.s    r
        IL_015a:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_015f:  nop
        IL_0160:  endfinally
      }  // end handler
      IL_0161:  nop
//000066:                     }
      IL_0162:  nop
//000063:                     for(int i=0; i<paths.Count; i++)
      IL_0163:  ldloc.2
      IL_0164:  ldc.i4.1
      IL_0165:  add
      IL_0166:  stloc.2
      IL_0167:  ldloc.2
      IL_0168:  ldloc.s    'CS$<>8__locals2'
      IL_016a:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::paths
      IL_016f:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
      IL_0174:  clt
      IL_0176:  stloc.s    CS$4$0001
//000064:                     {
//000065:                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
//000066:                     }
//000067:                 }
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_0178:  ldloc.s    CS$4$0001
      IL_017a:  brtrue.s   IL_0121

//000067:                 }
      IL_017c:  nop
//000068:             }
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      IL_017d:  leave.s    IL_0191

    }  // end .try
    finally
    {
      IL_017f:  ldloc.3
      IL_0180:  ldnull
      IL_0181:  ceq
      IL_0183:  stloc.s    CS$4$0001
      IL_0185:  ldloc.s    CS$4$0001
      IL_0187:  brtrue.s   IL_0190

      IL_0189:  ldloc.3
      IL_018a:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_018f:  nop
      IL_0190:  endfinally
    }  // end handler
    IL_0191:  nop
//000068:             }
    IL_0192:  nop
//000069: 
//000070:             // Use FastBitmap instances to provide unsafe/faster access to the pixels
//000071:             // in the original and in the new images
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_0193:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3'::.ctor()
    IL_0198:  stloc.s    'CS$<>8__locals4'
//000072:             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
    IL_019a:  ldloc.s    'CS$<>8__locals4'
    IL_019c:  ldloc.1
    IL_019d:  newobj     instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
    IL_01a2:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3'::fastColorizedImage
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    .try
    {
      IL_01a7:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5'::.ctor()
      IL_01ac:  stloc.s    'CS$<>8__locals6'
//000073:             using (FastBitmap fastOriginalImage = new FastBitmap(original))
      IL_01ae:  ldloc.s    'CS$<>8__locals6'
      IL_01b0:  ldarg.1
      IL_01b1:  newobj     instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
      IL_01b6:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5'::fastOriginalImage
//000074:             {
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
//000077:                 foreach (Point p in selectedPixels)
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
      .try
      {
        IL_01bb:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::.ctor()
        IL_01c0:  stloc.s    'CS$<>8__locals8'
        IL_01c2:  ldloc.s    'CS$<>8__locals8'
        IL_01c4:  ldloc.s    'CS$<>8__locals6'
        IL_01c6:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals6'
        IL_01cb:  ldloc.s    'CS$<>8__locals8'
        IL_01cd:  ldloc.s    'CS$<>8__locals4'
        IL_01cf:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals4'
        IL_01d4:  ldloc.s    'CS$<>8__locals8'
        IL_01d6:  ldloc.s    'CS$<>8__locals2'
        IL_01d8:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1' Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'CS$<>8__locals2'
//000074:             {
        IL_01dd:  nop
//000075:                 // Extract the selected hues from the selected pixels
//000076:                 List<float> selectedHues = new List<float>(selectedPixels.Count);
        IL_01de:  ldloc.s    'CS$<>8__locals8'
        IL_01e0:  ldarg.2
        IL_01e1:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
        IL_01e6:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<float32>::.ctor(int32)
        IL_01eb:  stfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::selectedHues
//000077:                 foreach (Point p in selectedPixels)
        IL_01f0:  nop
        IL_01f1:  ldarg.2
        IL_01f2:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::GetEnumerator()
        IL_01f7:  stloc.s    CS$5$0002
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        .try
        {
          IL_01f9:  br.s       IL_0236

//000077:                 foreach (Point p in selectedPixels)
          IL_01fb:  ldloca.s   CS$5$0002
          IL_01fd:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point>::get_Current()
          IL_0202:  stloc.s    p
//000078:                 {
          IL_0204:  nop
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
          IL_0205:  ldloc.s    'CS$<>8__locals8'
          IL_0207:  ldfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::selectedHues
          IL_020c:  ldloc.s    'CS$<>8__locals6'
          IL_020e:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5'::fastOriginalImage
          IL_0213:  ldloca.s   p
          IL_0215:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
          IL_021a:  ldloca.s   p
          IL_021c:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
          IL_0221:  callvirt   instance valuetype [System.Drawing]System.Drawing.Color [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::GetColor(int32,
                                                                                                                                                        int32)
          IL_0226:  stloc.s    CS$0$0003
          IL_0228:  ldloca.s   CS$0$0003
          IL_022a:  call       instance float32 [System.Drawing]System.Drawing.Color::GetHue()
          IL_022f:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<float32>::Add(!0)
          IL_0234:  nop
//000080:                 }
          IL_0235:  nop
//000077:                 foreach (Point p in selectedPixels)
          IL_0236:  ldloca.s   CS$5$0002
          IL_0238:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point>::MoveNext()
          IL_023d:  stloc.s    CS$4$0001
//000078:                 {
//000079:                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
//000080:                 }
//000081: 
//000082:                 // For progress update purposes, figure out how many pixels there
//000083:                 // are in total, and how many constitute 1% so that we can raise
//000084:                 // events after every additional 1% has been completed.
//000085:                 long totalPixels = height * width;
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
          IL_023f:  ldloc.s    CS$4$0001
          IL_0241:  brtrue.s   IL_01fb

          IL_0243:  leave.s    IL_0254

        }  // end .try
        finally
        {
          IL_0245:  ldloca.s   CS$5$0002
          IL_0247:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point>
          IL_024d:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
          IL_0252:  nop
          IL_0253:  endfinally
        }  // end handler
        IL_0254:  nop
//000085:                 long totalPixels = height * width;
        IL_0255:  ldloc.s    'CS$<>8__locals8'
        IL_0257:  ldloc.0
        IL_0258:  ldloc.s    'CS$<>8__locals2'
        IL_025a:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::width
        IL_025f:  mul
        IL_0260:  conv.i8
        IL_0261:  stfld      int64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::totalPixels
//000086:                 long pixelsPerProgressUpdate = totalPixels / 100;
        IL_0266:  ldloc.s    'CS$<>8__locals8'
        IL_0268:  ldfld      int64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::totalPixels
        IL_026d:  ldc.i4.s   100
        IL_026f:  conv.i8
        IL_0270:  div
        IL_0271:  stloc.s    pixelsPerProgressUpdate
//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
        IL_0273:  ldloc.s    pixelsPerProgressUpdate
        IL_0275:  ldc.i4.0
        IL_0276:  conv.i8
        IL_0277:  ceq
        IL_0279:  ldc.i4.0
        IL_027a:  ceq
        IL_027c:  stloc.s    CS$4$0001
//000088:                 long pixelsProcessed = 0;
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_027e:  ldloc.s    CS$4$0001
        IL_0280:  brtrue.s   IL_0286

//000087:                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
        IL_0282:  ldc.i4.1
        IL_0283:  conv.i8
        IL_0284:  stloc.s    pixelsPerProgressUpdate
//000088:                 long pixelsProcessed = 0;
        IL_0286:  ldloc.s    'CS$<>8__locals8'
        IL_0288:  ldc.i4.0
        IL_0289:  conv.i8
        IL_028a:  stfld      int64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::pixelsProcessed
//000089: 
//000090:                 // Pixels close to the selected hue but not close enough may be
//000091:                 // left partially desaturated.  The saturation window determines
//000092:                 // what pixels fall into that range.
//000093:                 const int maxSaturationWindow = 10;
//000094:                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
        IL_028f:  ldloc.s    'CS$<>8__locals8'
        IL_0291:  ldc.i4.s   10
        IL_0293:  ldloc.s    'CS$<>8__locals2'
        IL_0295:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass1'::epsilon
        IL_029a:  call       int32 [mscorlib]System.Math::Min(int32,
                                                              int32)
        IL_029f:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::saturationWindow
//000095: 
//000096:                 // Separated out the body of the loop just to make it easier
//000097:                 // to switch between sequential and parallel for demo purposes
//000098:                 Action<int> processRow = y =>
        IL_02a4:  ldloc.s    'CS$<>8__locals8'
        IL_02a6:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass7'::'<Colorize>b__0'(int32)
        IL_02ac:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                         native int)
        IL_02b1:  stloc.s    processRow
//000099:                 {
//000100:                     for (int x = 0; x < width; x++)
//000101:                     {
//000102:                         // Get the color/hue of th epixel
//000103:                         Color c = fastOriginalImage.GetColor(x, y);
//000104:                         float pixelHue = c.GetHue();
//000105: 
//000106:                         // Use hit-testing to determine if the pixel is in the selected region.
//000107:                         bool pixelInSelectedRegion = false;
//000108: 
//000109:                         // First, if there are no paths, by definition it is in the selected
//000110:                         // region, since the whole image is then selected
//000111:                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
//000112:                         else
//000113:                         {
//000114:                             // For each path, first see if the pixel is within the bounding
//000115:                             // rectangle; if it's not, it's not in the selected region.
//000116:                             Point p = new Point(x, y);
//000117:                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
//000118:                             {
//000119:                                 if (pathsBounds[i].Contains(p))
//000120:                                 {
//000121:                                     // The pixel is within a bounding rectangle, so now
//000122:                                     // see if it's within the composition rectangles
//000123:                                     // approximating the region.
//000124:                                     foreach (RectangleF bound in compositions[i])
//000125:                                     {
//000126:                                         if (bound.Contains(x, y))
//000127:                                         {
//000128:                                             // If it is, it's in the region.
//000129:                                             pixelInSelectedRegion = true;
//000130:                                             break;
//000131:                                         }
//000132:                                     }
//000133:                                 }
//000134:                             }
//000135:                         }
//000136: 
//000137:                         // Now that we know whether a pixel is in the region,
//000138:                         // we can figure out what to do with it.  If the pixel
//000139:                         // is not in the selected region, it needs to be converted
//000140:                         // to grayscale.
//000141:                         bool useGrayscale = true;
//000142:                         if (pixelInSelectedRegion)
//000143:                         {
//000144:                             // If it is in the selected region, get the color hue's distance 
//000145:                             // from each target hue.  If that distance is less than the user-selected
//000146:                             // hue variation limit, leave it in color.  If it's greater than the
//000147:                             // variation limit, but within the saturation window of the limit,
//000148:                             // desaturate it proportionally to the distance from the limit.
//000149:                             foreach (float selectedHue in selectedHues)
//000150:                             {
//000151:                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000152:                                 // will be two distances between them, depending on which way you go around
//000153:                                 // the wheel from one to the other (unless they're exactly opposite from
//000154:                                 // each other on the wheel, the two distances will be different).  We always
//000155:                                 // want to do our work based on the smaller of the two distances (e.g. a hue
//000156:                                 // with the value 359 is very, very close to a hue with the value 1).  So,
//000157:                                 // we take the absolute value of the difference between the two hues.  If that
//000158:                                 // distance is 180 degrees, then both distances are the same, so it doesn't
//000159:                                 // matter which we go with. If that difference is less than 180 degrees, 
//000160:                                 // we know this must be the smaller of the two distances, since the sum of the 
//000161:                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
//000162:                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
//000163:                                 float distance = Math.Abs(pixelHue - selectedHue);
//000164:                                 if (distance > 180) distance = 360 - distance;
//000165: 
//000166:                                 if (distance <= epsilon)
//000167:                                 {
//000168:                                     useGrayscale = false;
//000169:                                     break;
//000170:                                 }
//000171:                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
//000172:                                 {
//000173:                                     useGrayscale = false;
//000174:                                     c = ColorFromHsb(
//000175:                                         pixelHue,
//000176:                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
//000177:                                         c.GetBrightness());
//000178:                                     break;
//000179:                                 }
//000180:                             }
//000181:                         }
//000182: 
//000183:                         // Set the pixel color into the new image
//000184:                         if (useGrayscale) c = ToGrayscale(c);
//000185:                         fastColorizedImage.SetColor(x, y, c);
//000186:                     }
//000187: 
//000188:                     // Notify any listeners of our progress, if enough progress has been made
//000189:                     Interlocked.Add(ref pixelsProcessed, width);
//000190:                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
//000191:                 };
//000192: 
//000193:                 // Copy over every single pixel, and possibly transform it in the process
//000194:                 if (parallel)
        IL_02b3:  ldarg.s    parallel
        IL_02b5:  ldc.i4.0
        IL_02b6:  ceq
        IL_02b8:  stloc.s    CS$4$0001
//000195:                 {
//000196:                     Parallel.For(0, height, processRow);
//000197:                 }
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_02ba:  ldloc.s    CS$4$0001
        IL_02bc:  brtrue.s   IL_02cc

//000195:                 {
        IL_02be:  nop
//000196:                     Parallel.For(0, height, processRow);
        IL_02bf:  ldc.i4.0
        IL_02c0:  ldloc.0
        IL_02c1:  ldloc.s    processRow
        IL_02c3:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                          int32,
                                                                                                                                          class [mscorlib]System.Action`1<int32>)
        IL_02c8:  pop
//000197:                 }
        IL_02c9:  nop
//000198:                 else
//000199:                 {
//000200:                     for (int y = 0; y < height; y++) processRow(y);
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_02ca:  br.s       IL_02ee

//000199:                 {
        IL_02cc:  nop
//000200:                     for (int y = 0; y < height; y++) processRow(y);
        IL_02cd:  ldc.i4.0
        IL_02ce:  stloc.s    y
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_02d0:  br.s       IL_02e2

//000200:                     for (int y = 0; y < height; y++) processRow(y);
        IL_02d2:  ldloc.s    processRow
        IL_02d4:  ldloc.s    y
        IL_02d6:  callvirt   instance void class [mscorlib]System.Action`1<int32>::Invoke(!0)
        IL_02db:  nop
        IL_02dc:  ldloc.s    y
        IL_02de:  ldc.i4.1
        IL_02df:  add
        IL_02e0:  stloc.s    y
        IL_02e2:  ldloc.s    y
        IL_02e4:  ldloc.0
        IL_02e5:  clt
        IL_02e7:  stloc.s    CS$4$0001
//000201:                 }
//000202:             }
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_02e9:  ldloc.s    CS$4$0001
        IL_02eb:  brtrue.s   IL_02d2

//000201:                 }
        IL_02ed:  nop
//000202:             }
        IL_02ee:  nop
//000203: 
//000204:             // We're done creating the image.  Return it.
//000205:             return colorizedImage;
//000206:         }
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
//000212:             if (ProgressChanged != null)
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
        IL_02ef:  leave.s    IL_030f

      }  // end .try
      finally
      {
        IL_02f1:  ldloc.s    'CS$<>8__locals6'
        IL_02f3:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5'::fastOriginalImage
        IL_02f8:  ldnull
        IL_02f9:  ceq
        IL_02fb:  stloc.s    CS$4$0001
        IL_02fd:  ldloc.s    CS$4$0001
        IL_02ff:  brtrue.s   IL_030e

        IL_0301:  ldloc.s    'CS$<>8__locals6'
        IL_0303:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass5'::fastOriginalImage
        IL_0308:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_030d:  nop
        IL_030e:  endfinally
      }  // end handler
      IL_030f:  nop
      IL_0310:  leave.s    IL_0330

    }  // end .try
    finally
    {
      IL_0312:  ldloc.s    'CS$<>8__locals4'
      IL_0314:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3'::fastColorizedImage
      IL_0319:  ldnull
      IL_031a:  ceq
      IL_031c:  stloc.s    CS$4$0001
      IL_031e:  ldloc.s    CS$4$0001
      IL_0320:  brtrue.s   IL_032f

      IL_0322:  ldloc.s    'CS$<>8__locals4'
      IL_0324:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/'<>c__DisplayClass3'::fastColorizedImage
      IL_0329:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_032e:  nop
      IL_032f:  endfinally
    }  // end handler
    IL_0330:  nop
//000205:             return colorizedImage;
    IL_0331:  ldloc.1
    IL_0332:  stloc.s    CS$1$0000
    IL_0334:  br.s       IL_0336

//000206:         }
    IL_0336:  ldloc.s    CS$1$0000
    IL_0338:  ret
  } // end of method ImageManipulation::Colorize

  .method private hidebysig instance void 
          OnProgressChanged(int32 progressPercentage) cil managed
  {
    // Code size       37 (0x25)
    .maxstack  5
    .locals init ([0] bool CS$4$0000)
//000207: 
//000208:         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000209:         /// <param name="progressPercentage">The progress percentage.</param>
//000210:         private void OnProgressChanged(int progressPercentage)
//000211:         {
    IL_0000:  nop
//000212:             if (ProgressChanged != null)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChanged
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  stloc.0
//000213:             {
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
//000215:             }
//000216:         }
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
//000224:             return Color.FromArgb(luminance, luminance, luminance);
//000225:         }
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_000b:  ldloc.0
    IL_000c:  brtrue.s   IL_0024

//000213:             {
    IL_000e:  nop
//000214:                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
    IL_000f:  ldarg.0
    IL_0010:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChanged
    IL_0015:  ldarg.0
    IL_0016:  ldarg.1
    IL_0017:  ldnull
    IL_0018:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventArgs::.ctor(int32,
                                                                                                     object)
    IL_001d:  callvirt   instance void [System]System.ComponentModel.ProgressChangedEventHandler::Invoke(object,
                                                                                                         class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_0022:  nop
//000215:             }
    IL_0023:  nop
//000216:         }
    IL_0024:  ret
  } // end of method ImageManipulation::OnProgressChanged

  .method private hidebysig static valuetype [System.Drawing]System.Drawing.Color 
          ToGrayscale(valuetype [System.Drawing]System.Drawing.Color c) cil managed
  {
    // Code size       72 (0x48)
    .maxstack  3
    .locals init ([0] int32 luminance,
             [1] valuetype [System.Drawing]System.Drawing.Color CS$1$0000)
//000217: 
//000218:         /// <summary>Converts a color to grayscale.</summary>
//000219:         /// <param name="c">The color to convert.</param>
//000220:         /// <returns>The grayscale color.</returns>
//000221:         private static Color ToGrayscale(Color c)
//000222:         {
    IL_0000:  nop
//000223:             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
    IL_0001:  ldc.r8     0.29899999999999999
    IL_000a:  ldarga.s   c
    IL_000c:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_R()
    IL_0011:  conv.r8
    IL_0012:  mul
    IL_0013:  ldc.r8     0.58699999999999997
    IL_001c:  ldarga.s   c
    IL_001e:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_G()
    IL_0023:  conv.r8
    IL_0024:  mul
    IL_0025:  add
    IL_0026:  ldc.r8     0.114
    IL_002f:  ldarga.s   c
    IL_0031:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_B()
    IL_0036:  conv.r8
    IL_0037:  mul
    IL_0038:  add
    IL_0039:  conv.i4
    IL_003a:  stloc.0
//000224:             return Color.FromArgb(luminance, luminance, luminance);
    IL_003b:  ldloc.0
    IL_003c:  ldloc.0
    IL_003d:  ldloc.0
    IL_003e:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_0043:  stloc.1
    IL_0044:  br.s       IL_0046

//000225:         }
    IL_0046:  ldloc.1
    IL_0047:  ret
  } // end of method ImageManipulation::ToGrayscale

  .method private hidebysig static valuetype [System.Drawing]System.Drawing.Color 
          ColorFromHsb(float32 h,
                       float32 s,
                       float32 b) cil managed
  {
    // Code size       501 (0x1f5)
    .maxstack  4
    .locals init ([0] float32 fMax,
             [1] float32 fMid,
             [2] float32 fMin,
             [3] int32 iSextant,
             [4] int32 iMax,
             [5] int32 iMid,
             [6] int32 iMin,
             [7] valuetype [System.Drawing]System.Drawing.Color CS$1$0000,
             [8] bool CS$4$0001,
             [9] int32 CS$4$0002)
//000226: 
//000227:         /// <summary>HSB to RGB color conversion.</summary>
//000228:         /// <param name="h">The color's hue.</param>
//000229:         /// <param name="s">The color's saturation.</param>
//000230:         /// <param name="b">The color's brightness.</param>
//000231:         /// <returns>The RGB color for the supplied HSB values.</returns>
//000232:         /// <remarks>
//000233:         /// Based on Chris Jackson's conversion routine from:
//000234:         /// http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000235:         /// </remarks>
//000236:         private static Color ColorFromHsb(float h, float s, float b)
//000237:         {
    IL_0000:  nop
//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
    IL_0001:  ldc.r4     0.0
    IL_0006:  ldarg.0
    IL_0007:  bgt.s      IL_0016

    IL_0009:  ldc.r4     360.
    IL_000e:  ldarg.0
    IL_000f:  clt
    IL_0011:  ldc.i4.0
    IL_0012:  ceq
    IL_0014:  br.s       IL_0017

    IL_0016:  ldc.i4.0
    IL_0017:  stloc.s    CS$4$0001
//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_0019:  ldloc.s    CS$4$0001
    IL_001b:  brtrue.s   IL_0028

//000238:             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
    IL_001d:  ldstr      "h"
    IL_0022:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_0027:  throw

//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
    IL_0028:  ldc.r4     0.0
    IL_002d:  ldarg.1
    IL_002e:  bgt.s      IL_003d

    IL_0030:  ldc.r4     1.
    IL_0035:  ldarg.1
    IL_0036:  clt
    IL_0038:  ldc.i4.0
    IL_0039:  ceq
    IL_003b:  br.s       IL_003e

    IL_003d:  ldc.i4.0
    IL_003e:  stloc.s    CS$4$0001
//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_0040:  ldloc.s    CS$4$0001
    IL_0042:  brtrue.s   IL_004f

//000239:             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
    IL_0044:  ldstr      "s"
    IL_0049:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_004e:  throw

//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
    IL_004f:  ldc.r4     0.0
    IL_0054:  ldarg.2
    IL_0055:  bgt.s      IL_0064

    IL_0057:  ldc.r4     1.
    IL_005c:  ldarg.2
    IL_005d:  clt
    IL_005f:  ldc.i4.0
    IL_0060:  ceq
    IL_0062:  br.s       IL_0065

    IL_0064:  ldc.i4.0
    IL_0065:  stloc.s    CS$4$0001
//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_0067:  ldloc.s    CS$4$0001
    IL_0069:  brtrue.s   IL_0076

//000240:             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
    IL_006b:  ldstr      "b"
    IL_0070:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_0075:  throw

//000241: 
//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
    IL_0076:  ldc.r4     0.0
    IL_007b:  ldarg.1
    IL_007c:  ceq
    IL_007e:  ldc.i4.0
    IL_007f:  ceq
    IL_0081:  stloc.s    CS$4$0001
//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_0083:  ldloc.s    CS$4$0001
    IL_0085:  brtrue.s   IL_00ab

//000242:             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
    IL_0087:  ldarg.2
    IL_0088:  ldc.r4     255.
    IL_008d:  mul
    IL_008e:  conv.i4
    IL_008f:  ldarg.2
    IL_0090:  ldc.r4     255.
    IL_0095:  mul
    IL_0096:  conv.i4
    IL_0097:  ldarg.2
    IL_0098:  ldc.r4     255.
    IL_009d:  mul
    IL_009e:  conv.i4
    IL_009f:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_00a4:  stloc.s    CS$1$0000
    IL_00a6:  br         IL_01f2

//000243: 
//000244:             float fMax, fMid, fMin;
//000245:             int iSextant, iMax, iMid, iMin;
//000246: 
//000247:             if (0.5 < b)
    IL_00ab:  ldc.r8     0.5
    IL_00b4:  ldarg.2
    IL_00b5:  conv.r8
    IL_00b6:  clt
    IL_00b8:  ldc.i4.0
    IL_00b9:  ceq
    IL_00bb:  stloc.s    CS$4$0001
//000248:             {
//000249:                 fMax = b - (b * s) + s;
//000250:                 fMin = b + (b * s) - s;
//000251:             }
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_00bd:  ldloc.s    CS$4$0001
    IL_00bf:  brtrue.s   IL_00d5

//000248:             {
    IL_00c1:  nop
//000249:                 fMax = b - (b * s) + s;
    IL_00c2:  ldarg.2
    IL_00c3:  ldarg.2
    IL_00c4:  ldarg.1
    IL_00c5:  mul
    IL_00c6:  sub
    IL_00c7:  ldarg.1
    IL_00c8:  add
    IL_00c9:  stloc.0
//000250:                 fMin = b + (b * s) - s;
    IL_00ca:  ldarg.2
    IL_00cb:  ldarg.2
    IL_00cc:  ldarg.1
    IL_00cd:  mul
    IL_00ce:  add
    IL_00cf:  ldarg.1
    IL_00d0:  sub
    IL_00d1:  stloc.2
//000251:             }
    IL_00d2:  nop
//000252:             else
//000253:             {
//000254:                 fMax = b + (b * s);
//000255:                 fMin = b - (b * s);
//000256:             }
//000257: 
//000258:             iSextant = (int)(h / 60f);
//000259:             if (300f <= h)
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_00d3:  br.s       IL_00e3

//000253:             {
    IL_00d5:  nop
//000254:                 fMax = b + (b * s);
    IL_00d6:  ldarg.2
    IL_00d7:  ldarg.2
    IL_00d8:  ldarg.1
    IL_00d9:  mul
    IL_00da:  add
    IL_00db:  stloc.0
//000255:                 fMin = b - (b * s);
    IL_00dc:  ldarg.2
    IL_00dd:  ldarg.2
    IL_00de:  ldarg.1
    IL_00df:  mul
    IL_00e0:  sub
    IL_00e1:  stloc.2
//000256:             }
    IL_00e2:  nop
//000257: 
//000258:             iSextant = (int)(h / 60f);
    IL_00e3:  ldarg.0
    IL_00e4:  ldc.r4     60.
    IL_00e9:  div
    IL_00ea:  conv.i4
    IL_00eb:  stloc.3
//000259:             if (300f <= h)
    IL_00ec:  ldc.r4     300.
    IL_00f1:  ldarg.0
    IL_00f2:  cgt.un
    IL_00f4:  stloc.s    CS$4$0001
//000260:             {
//000261:                 h -= 360f;
//000262:             }
//000263:             h /= 60f;
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
//000265:             if (0 == iSextant % 2)
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_00f6:  ldloc.s    CS$4$0001
    IL_00f8:  brtrue.s   IL_0105

//000260:             {
    IL_00fa:  nop
//000261:                 h -= 360f;
    IL_00fb:  ldarg.0
    IL_00fc:  ldc.r4     360.
    IL_0101:  sub
    IL_0102:  starg.s    h
//000262:             }
    IL_0104:  nop
//000263:             h /= 60f;
    IL_0105:  ldarg.0
    IL_0106:  ldc.r4     60.
    IL_010b:  div
    IL_010c:  starg.s    h
//000264:             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
    IL_010e:  ldarg.0
    IL_010f:  ldc.r4     2.
    IL_0114:  ldloc.3
    IL_0115:  conv.r4
    IL_0116:  ldc.r4     1.
    IL_011b:  add
    IL_011c:  ldc.r4     6.
    IL_0121:  rem
    IL_0122:  ldc.r4     2.
    IL_0127:  div
    IL_0128:  conv.r8
    IL_0129:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_012e:  conv.r4
    IL_012f:  mul
    IL_0130:  sub
    IL_0131:  starg.s    h
//000265:             if (0 == iSextant % 2)
    IL_0133:  ldc.i4.0
    IL_0134:  ldloc.3
    IL_0135:  ldc.i4.2
    IL_0136:  rem
    IL_0137:  ceq
    IL_0139:  ldc.i4.0
    IL_013a:  ceq
    IL_013c:  stloc.s    CS$4$0001
//000266:             {
//000267:                 fMid = h * (fMax - fMin) + fMin;
//000268:             }
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_013e:  ldloc.s    CS$4$0001
    IL_0140:  brtrue.s   IL_014e

//000266:             {
    IL_0142:  nop
//000267:                 fMid = h * (fMax - fMin) + fMin;
    IL_0143:  ldarg.0
    IL_0144:  ldloc.0
    IL_0145:  ldloc.2
    IL_0146:  sub
    IL_0147:  mul
    IL_0148:  ldloc.2
    IL_0149:  add
    IL_014a:  stloc.1
//000268:             }
    IL_014b:  nop
//000269:             else
//000270:             {
//000271:                 fMid = fMin - h * (fMax - fMin);
//000272:             }
//000273: 
//000274:             iMax = (int)(fMax * 255);
//000275:             iMid = (int)(fMid * 255);
//000276:             iMin = (int)(fMin * 255);
//000277: 
//000278:             switch (iSextant)
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_014c:  br.s       IL_0158

//000270:             {
    IL_014e:  nop
//000271:                 fMid = fMin - h * (fMax - fMin);
    IL_014f:  ldloc.2
    IL_0150:  ldarg.0
    IL_0151:  ldloc.0
    IL_0152:  ldloc.2
    IL_0153:  sub
    IL_0154:  mul
    IL_0155:  sub
    IL_0156:  stloc.1
//000272:             }
    IL_0157:  nop
//000273: 
//000274:             iMax = (int)(fMax * 255);
    IL_0158:  ldloc.0
    IL_0159:  ldc.r4     255.
    IL_015e:  mul
    IL_015f:  conv.i4
    IL_0160:  stloc.s    iMax
//000275:             iMid = (int)(fMid * 255);
    IL_0162:  ldloc.1
    IL_0163:  ldc.r4     255.
    IL_0168:  mul
    IL_0169:  conv.i4
    IL_016a:  stloc.s    iMid
//000276:             iMin = (int)(fMin * 255);
    IL_016c:  ldloc.2
    IL_016d:  ldc.r4     255.
    IL_0172:  mul
    IL_0173:  conv.i4
    IL_0174:  stloc.s    iMin
//000277: 
//000278:             switch (iSextant)
    IL_0176:  ldloc.3
    IL_0177:  stloc.s    CS$4$0002
//000279:             {
//000280:                 case 1:
//000281:                     return Color.FromArgb(iMid, iMax, iMin);
//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
//000292:             }
//000293:         }
//000294:     }
//000295: }
    IL_0179:  ldloc.s    CS$4$0002
    IL_017b:  ldc.i4.1
    IL_017c:  sub
    IL_017d:  switch     ( 
                          IL_0198,
                          IL_01a7,
                          IL_01b6,
                          IL_01c5,
                          IL_01d4)
    IL_0196:  br.s       IL_01e3

//000281:                     return Color.FromArgb(iMid, iMax, iMin);
    IL_0198:  ldloc.s    iMid
    IL_019a:  ldloc.s    iMax
    IL_019c:  ldloc.s    iMin
    IL_019e:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01a3:  stloc.s    CS$1$0000
    IL_01a5:  br.s       IL_01f2

//000282:                 case 2:
//000283:                     return Color.FromArgb(iMin, iMax, iMid);
    IL_01a7:  ldloc.s    iMin
    IL_01a9:  ldloc.s    iMax
    IL_01ab:  ldloc.s    iMid
    IL_01ad:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01b2:  stloc.s    CS$1$0000
    IL_01b4:  br.s       IL_01f2

//000284:                 case 3:
//000285:                     return Color.FromArgb(iMin, iMid, iMax);
    IL_01b6:  ldloc.s    iMin
    IL_01b8:  ldloc.s    iMid
    IL_01ba:  ldloc.s    iMax
    IL_01bc:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01c1:  stloc.s    CS$1$0000
    IL_01c3:  br.s       IL_01f2

//000286:                 case 4:
//000287:                     return Color.FromArgb(iMid, iMin, iMax);
    IL_01c5:  ldloc.s    iMid
    IL_01c7:  ldloc.s    iMin
    IL_01c9:  ldloc.s    iMax
    IL_01cb:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01d0:  stloc.s    CS$1$0000
    IL_01d2:  br.s       IL_01f2

//000288:                 case 5:
//000289:                     return Color.FromArgb(iMax, iMin, iMid);
    IL_01d4:  ldloc.s    iMax
    IL_01d6:  ldloc.s    iMin
    IL_01d8:  ldloc.s    iMid
    IL_01da:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01df:  stloc.s    CS$1$0000
    IL_01e1:  br.s       IL_01f2

//000290:                 default:
//000291:                     return Color.FromArgb(iMax, iMid, iMin);
    IL_01e3:  ldloc.s    iMax
    IL_01e5:  ldloc.s    iMid
    IL_01e7:  ldloc.s    iMin
    IL_01e9:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01ee:  stloc.s    CS$1$0000
    IL_01f0:  br.s       IL_01f2

//000292:             }
//000293:         }
    IL_01f2:  ldloc.s    CS$1$0000
    IL_01f4:  ret
  } // end of method ImageManipulation::ColorFromHsb

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method ImageManipulation::.ctor

  .event [System]System.ComponentModel.ProgressChangedEventHandler ProgressChanged
  {
    .addon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    .removeon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::remove_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
  } // end of event ImageManipulation::ProgressChanged
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation

.class private auto ansi '<PrivateImplementationDetails>{2BE498C6-20DC-4C09-97C0-6532881E7B83}'
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field static assembly class [mscorlib]System.Collections.Generic.Dictionary`2<string,int32> '$$method0x6000018-1'
} // end of class '<PrivateImplementationDetails>{2BE498C6-20DC-4C09-97C0-6532881E7B83}'


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
