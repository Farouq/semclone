<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="12" endline="17"><![CDATA[
         Protected Overrides Sub Dispose(ByVal disposing As Boolean)
             If disposing AndAlso (components IsNot Nothing) Then
                 components.Dispose()
             End If
             MyBase.Dispose(disposing)
         End Sub
 
 #Region "Windows Form Designer generated code"
 
         ''' <summary>
         ''' Required method for Designer support - do not modify
         ''' the contents of this method with the code editor.
         ''' </summary>
         Private Sub InitializeComponent()
             Me.components = New System.ComponentModel.Container()
             Me.pbPartitionedImage = New PictureBox()
             Me.btnVisualize = New Button()
             Me.lvPartitioningMethods = New ListView()
             Me.lvWorkloads = New ListView()
             Me.label1 = New Label()
             Me.label2 = New Label()
             Me.lblTime = New Label()
             Me.tbWorkFactor = New TrackBar()
             Me.label3 = New Label()
             Me.rbParallelFor = New RadioButton()
             Me.rbParallelForEach = New RadioButton()
             Me.rbPLINQ = New RadioButton()
             Me.groupBox1 = New GroupBox()
             Me.label4 = New Label()
             Me.tbCores = New TrackBar()
             Me.toolTip1 = New ToolTip(Me.components)
             CType(Me.pbPartitionedImage, System.ComponentModel.ISupportInitialize).BeginInit()
             CType(Me.tbWorkFactor, System.ComponentModel.ISupportInitialize).BeginInit()
             Me.groupBox1.SuspendLayout()
             CType(Me.tbCores, System.ComponentModel.ISupportInitialize).BeginInit()
             Me.SuspendLayout()
             ' 
             ' pbPartitionedImage
             ' 
             Me.pbPartitionedImage.Anchor = (CType((((AnchorStyles.Top Or AnchorStyles.Bottom) Or AnchorStyles.Left) Or AnchorStyles.Right), AnchorStyles))
             Me.pbPartitionedImage.BackColor = Color.Black
             Me.pbPartitionedImage.BorderStyle = BorderStyle.Fixed3D
             Me.pbPartitionedImage.Location = New Point(12, 12)
             Me.pbPartitionedImage.Name = "pbPartitionedImage"
             Me.pbPartitionedImage.Size = New Size(539, 522)
             Me.pbPartitionedImage.SizeMode = PictureBoxSizeMode.StretchImage
             Me.pbPartitionedImage.TabIndex = 0
             Me.pbPartitionedImage.TabStop = False
             ' 
             ' btnVisualize
             ' 
             Me.btnVisualize.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.btnVisualize.Location = New Point(557, 490)
             Me.btnVisualize.Name = "btnVisualize"
             Me.btnVisualize.Size = New Size(75, 23)
             Me.btnVisualize.TabIndex = 1
             Me.btnVisualize.Text = "Visualize"
             Me.btnVisualize.UseVisualStyleBackColor = True
             ' Me.btnVisualize.Click += New System.EventHandler(AddressOf Me.btnVisualize_Click)
             ' 
             ' lvPartitioningMethods
             ' 
             Me.lvPartitioningMethods.Activation = ItemActivation.OneClick
             Me.lvPartitioningMethods.Alignment = ListViewAlignment.Default
             Me.lvPartitioningMethods.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.lvPartitioningMethods.AutoArrange = False
             Me.lvPartitioningMethods.Enabled = False
             Me.lvPartitioningMethods.FullRowSelect = True
             Me.lvPartitioningMethods.GridLines = True
             Me.lvPartitioningMethods.HeaderStyle = ColumnHeaderStyle.None
             Me.lvPartitioningMethods.Location = New Point(559, 127)
             Me.lvPartitioningMethods.MultiSelect = False
             Me.lvPartitioningMethods.Name = "lvPartitioningMethods"
             Me.lvPartitioningMethods.ShowGroups = False
             Me.lvPartitioningMethods.Size = New Size(126, 150)
             Me.lvPartitioningMethods.TabIndex = 2
             Me.lvPartitioningMethods.UseCompatibleStateImageBehavior = False
             Me.lvPartitioningMethods.View = View.List
             ' 
             ' lvWorkloads
             ' 
             Me.lvWorkloads.Activation = ItemActivation.OneClick
             Me.lvWorkloads.Alignment = ListViewAlignment.Default
             Me.lvWorkloads.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.lvWorkloads.AutoArrange = False
             Me.lvWorkloads.FullRowSelect = True
             Me.lvWorkloads.GridLines = True
             Me.lvWorkloads.HeaderStyle = ColumnHeaderStyle.None
             Me.lvWorkloads.HideSelection = False
             Me.lvWorkloads.Location = New Point(559, 296)
             Me.lvWorkloads.MultiSelect = False
             Me.lvWorkloads.Name = "lvWorkloads"
             Me.lvWorkloads.ShowGroups = False
             Me.lvWorkloads.Size = New Size(126, 77)
             Me.lvWorkloads.TabIndex = 3
             Me.lvWorkloads.UseCompatibleStateImageBehavior = False
             Me.lvWorkloads.View = View.List
             ' 
             ' label1
             ' 
             Me.label1.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label1.AutoSize = True
             Me.label1.Location = New Point(556, 280)
             Me.label1.Name = "label1"
             Me.label1.Size = New Size(53, 13)
             Me.label1.TabIndex = 4
             Me.label1.Text = "Workload"
             ' 
             ' label2
             ' 
             Me.label2.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label2.AutoSize = True
             Me.label2.Location = New Point(557, 111)
             Me.label2.Name = "label2"
             Me.label2.Size = New Size(59, 13)
             Me.label2.TabIndex = 5
             Me.label2.Text = "Partitioning"
             ' 
             ' lblTime
             ' 
             Me.lblTime.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.lblTime.AutoSize = True
             Me.lblTime.Location = New Point(556, 516)
             Me.lblTime.Name = "lblTime"
             Me.lblTime.Size = New Size(36, 13)
             Me.lblTime.TabIndex = 6
             Me.lblTime.Text = "Time
             ' 
             ' tbWorkFactor
             ' 
             Me.tbWorkFactor.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.tbWorkFactor.LargeChange = 1
             Me.tbWorkFactor.Location = New Point(558, 408)
             Me.tbWorkFactor.Maximum = 1000
             Me.tbWorkFactor.Minimum = 1
             Me.tbWorkFactor.Name = "tbWorkFactor"
             Me.tbWorkFactor.Size = New Size(123, 45)
             Me.tbWorkFactor.TabIndex = 7
             Me.tbWorkFactor.TickFrequency = 100
             Me.tbWorkFactor.TickStyle = TickStyle.None
             Me.tbWorkFactor.Value = 1
             ' Me.tbWorkFactor.ValueChanged += New System.EventHandler(Me.tbWorkFactor_ValueChanged)
             ' 
             ' label3
             ' 
             Me.label3.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label3.AutoSize = True
             Me.label3.Location = New Point(557, 385)
             Me.label3.Name = "label3"
             Me.label3.Size = New Size(66, 13)
             Me.label3.TabIndex = 8
             Me.label3.Text = "Work Factor"
             ' 
             ' rbParallelFor
             ' 
             Me.rbParallelFor.AutoSize = True
             Me.rbParallelFor.Checked = True
             Me.rbParallelFor.Location = New Point(7, 18)
             Me.rbParallelFor.Name = "rbParallelFor"
             Me.rbParallelFor.Size = New Size(77, 17)
             Me.rbParallelFor.TabIndex = 9
             Me.rbParallelFor.TabStop = True
             Me.rbParallelFor.Text = "Parallel.For"
             Me.rbParallelFor.UseVisualStyleBackColor = True
             ' Me.rbParallelFor.CheckedChanged += New System.EventHandler(Me.rbAPI_CheckedChanged)
             ' 
             ' rbParallelForEach
             ' 
             Me.rbParallelForEach.AutoSize = True
             Me.rbParallelForEach.Location = New Point(6, 41)
             Me.rbParallelForEach.Name = "rbParallelForEach"
             Me.rbParallelForEach.Size = New Size(102, 17)
             Me.rbParallelForEach.TabIndex = 10
             Me.rbParallelForEach.TabStop = True
             Me.rbParallelForEach.Text = "Parallel.ForEach"
             Me.rbParallelForEach.UseVisualStyleBackColor = True
             ' Me.rbParallelForEach.CheckedChanged += New System.EventHandler(Me.rbAPI_CheckedChanged)
             ' 
             ' rbPLINQ
             ' 
             Me.rbPLINQ.AutoSize = True
             Me.rbPLINQ.Location = New Point(6, 64)
             Me.rbPLINQ.Name = "rbPLINQ"
             Me.rbPLINQ.Size = New Size(57, 17)
             Me.rbPLINQ.TabIndex = 11
             Me.rbPLINQ.TabStop = True
             Me.rbPLINQ.Text = "PLINQ"
             Me.rbPLINQ.UseVisualStyleBackColor = True
             ' Me.rbPLINQ.CheckedChanged += New System.EventHandler(Me.rbAPI_CheckedChanged)
             ' 
             ' groupBox1
             ' 
             Me.groupBox1.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.groupBox1.Controls.Add(Me.rbParallelForEach)
             Me.groupBox1.Controls.Add(Me.rbPLINQ)
             Me.groupBox1.Controls.Add(Me.rbParallelFor)
             Me.groupBox1.Location = New Point(557, 12)
             Me.groupBox1.Name = "groupBox1"
             Me.groupBox1.Size = New Size(130, 91)
             Me.groupBox1.TabIndex = 12
             Me.groupBox1.TabStop = False
             Me.groupBox1.Text = "API"
             ' 
             ' label4
             ' 
             Me.label4.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label4.AutoSize = True
             Me.label4.Location = New Point(556, 436)
             Me.label4.Name = "label4"
             Me.label4.Size = New Size(34, 13)
             Me.label4.TabIndex = 14
             Me.label4.Text = "Cores"
             ' 
             ' tbCores
             ' 
             Me.tbCores.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.tbCores.LargeChange = 1
             Me.tbCores.Location = New Point(557, 459)
             Me.tbCores.Maximum = 100
             Me.tbCores.Minimum = 0
             Me.tbCores.Name = "tbCores"
             Me.tbCores.Size = New Size(123, 45)
             Me.tbCores.TabIndex = 13
             Me.tbCores.TickStyle = TickStyle.None
             Me.tbCores.Value = 0
             ' Me.tbCores.ValueChanged += New System.EventHandler(Me.tbCores_ValueChanged)
             ' 
             ' MainForm
             ' 
             Me.AutoScaleDimensions = New SizeF(6.0F, 13.0F)
             Me.AutoScaleMode = AutoScaleMode.Font
             Me.ClientSize = New Size(695, 547)
             Me.Controls.Add(Me.btnVisualize)
             Me.Controls.Add(Me.label4)
             Me.Controls.Add(Me.tbCores)
             Me.Controls.Add(Me.groupBox1)
             Me.Controls.Add(Me.label3)
             Me.Controls.Add(Me.tbWorkFactor)
             Me.Controls.Add(Me.lblTime)
             Me.Controls.Add(Me.label2)
             Me.Controls.Add(Me.label1)
             Me.Controls.Add(Me.lvWorkloads)
             Me.Controls.Add(Me.lvPartitioningMethods)
             Me.Controls.Add(Me.pbPartitionedImage)
             Me.Name = "MainForm"
             Me.Text = "Visualize Partitioning"
             CType(Me.pbPartitionedImage, System.ComponentModel.ISupportInitialize).EndInit()
             CType(Me.tbWorkFactor, System.ComponentModel.ISupportInitialize).EndInit()
             Me.groupBox1.ResumeLayout(False)
             Me.groupBox1.PerformLayout()
             CType(Me.tbCores, System.ComponentModel.ISupportInitialize).EndInit()
             Me.ResumeLayout(False)
             Me.PerformLayout()
 
         End Sub
 
 #End Region
 
         Private pbPartitionedImage As PictureBox
         Private WithEvents btnVisualize As Button
         Private lvPartitioningMethods As ListView
         Private lvWorkloads As ListView
         Private label1 As Label
         Private label2 As Label
         Private lblTime As Label
         Private WithEvents tbWorkFactor As TrackBar
         Private label3 As Label
         Private WithEvents rbParallelFor As RadioButton
         Private WithEvents rbParallelForEach As RadioButton
         Private WithEvents rbPLINQ As RadioButton
         Private groupBox1 As GroupBox
         Private label4 As Label
         Private WithEvents tbCores As TrackBar
         Private toolTip1 As ToolTip
     End Class
 End Namespace
 
                 components.Dispose()
             End If
             MyBase.Dispose(disposing)
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="18" endline="266"><![CDATA[
 
 #Region "Windows Form Designer generated code"
 
         ''' <summary>
         ''' Required method for Designer support - do not modify
         ''' the contents of this method with the code editor.
         ''' </summary>
         Private Sub InitializeComponent()
             Me.components = New System.ComponentModel.Container()
             Me.pbPartitionedImage = New PictureBox()
             Me.btnVisualize = New Button()
             Me.lvPartitioningMethods = New ListView()
             Me.lvWorkloads = New ListView()
             Me.label1 = New Label()
             Me.label2 = New Label()
             Me.lblTime = New Label()
             Me.tbWorkFactor = New TrackBar()
             Me.label3 = New Label()
             Me.rbParallelFor = New RadioButton()
             Me.rbParallelForEach = New RadioButton()
             Me.rbPLINQ = New RadioButton()
             Me.groupBox1 = New GroupBox()
             Me.label4 = New Label()
             Me.tbCores = New TrackBar()
             Me.toolTip1 = New ToolTip(Me.components)
             CType(Me.pbPartitionedImage, System.ComponentModel.ISupportInitialize).BeginInit()
             CType(Me.tbWorkFactor, System.ComponentModel.ISupportInitialize).BeginInit()
             Me.groupBox1.SuspendLayout()
             CType(Me.tbCores, System.ComponentModel.ISupportInitialize).BeginInit()
             Me.SuspendLayout()
             ' 
             ' pbPartitionedImage
             ' 
             Me.pbPartitionedImage.Anchor = (CType((((AnchorStyles.Top Or AnchorStyles.Bottom) Or AnchorStyles.Left) Or AnchorStyles.Right), AnchorStyles))
             Me.pbPartitionedImage.BackColor = Color.Black
             Me.pbPartitionedImage.BorderStyle = BorderStyle.Fixed3D
             Me.pbPartitionedImage.Location = New Point(12, 12)
             Me.pbPartitionedImage.Name = "pbPartitionedImage"
             Me.pbPartitionedImage.Size = New Size(539, 522)
             Me.pbPartitionedImage.SizeMode = PictureBoxSizeMode.StretchImage
             Me.pbPartitionedImage.TabIndex = 0
             Me.pbPartitionedImage.TabStop = False
             ' 
             ' btnVisualize
             ' 
             Me.btnVisualize.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.btnVisualize.Location = New Point(557, 490)
             Me.btnVisualize.Name = "btnVisualize"
             Me.btnVisualize.Size = New Size(75, 23)
             Me.btnVisualize.TabIndex = 1
             Me.btnVisualize.Text = "Visualize"
             Me.btnVisualize.UseVisualStyleBackColor = True
             ' Me.btnVisualize.Click += New System.EventHandler(AddressOf Me.btnVisualize_Click)
             ' 
             ' lvPartitioningMethods
             ' 
             Me.lvPartitioningMethods.Activation = ItemActivation.OneClick
             Me.lvPartitioningMethods.Alignment = ListViewAlignment.Default
             Me.lvPartitioningMethods.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.lvPartitioningMethods.AutoArrange = False
             Me.lvPartitioningMethods.Enabled = False
             Me.lvPartitioningMethods.FullRowSelect = True
             Me.lvPartitioningMethods.GridLines = True
             Me.lvPartitioningMethods.HeaderStyle = ColumnHeaderStyle.None
             Me.lvPartitioningMethods.Location = New Point(559, 127)
             Me.lvPartitioningMethods.MultiSelect = False
             Me.lvPartitioningMethods.Name = "lvPartitioningMethods"
             Me.lvPartitioningMethods.ShowGroups = False
             Me.lvPartitioningMethods.Size = New Size(126, 150)
             Me.lvPartitioningMethods.TabIndex = 2
             Me.lvPartitioningMethods.UseCompatibleStateImageBehavior = False
             Me.lvPartitioningMethods.View = View.List
             ' 
             ' lvWorkloads
             ' 
             Me.lvWorkloads.Activation = ItemActivation.OneClick
             Me.lvWorkloads.Alignment = ListViewAlignment.Default
             Me.lvWorkloads.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.lvWorkloads.AutoArrange = False
             Me.lvWorkloads.FullRowSelect = True
             Me.lvWorkloads.GridLines = True
             Me.lvWorkloads.HeaderStyle = ColumnHeaderStyle.None
             Me.lvWorkloads.HideSelection = False
             Me.lvWorkloads.Location = New Point(559, 296)
             Me.lvWorkloads.MultiSelect = False
             Me.lvWorkloads.Name = "lvWorkloads"
             Me.lvWorkloads.ShowGroups = False
             Me.lvWorkloads.Size = New Size(126, 77)
             Me.lvWorkloads.TabIndex = 3
             Me.lvWorkloads.UseCompatibleStateImageBehavior = False
             Me.lvWorkloads.View = View.List
             ' 
             ' label1
             ' 
             Me.label1.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label1.AutoSize = True
             Me.label1.Location = New Point(556, 280)
             Me.label1.Name = "label1"
             Me.label1.Size = New Size(53, 13)
             Me.label1.TabIndex = 4
             Me.label1.Text = "Workload"
             ' 
             ' label2
             ' 
             Me.label2.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label2.AutoSize = True
             Me.label2.Location = New Point(557, 111)
             Me.label2.Name = "label2"
             Me.label2.Size = New Size(59, 13)
             Me.label2.TabIndex = 5
             Me.label2.Text = "Partitioning"
             ' 
             ' lblTime
             ' 
             Me.lblTime.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.lblTime.AutoSize = True
             Me.lblTime.Location = New Point(556, 516)
             Me.lblTime.Name = "lblTime"
             Me.lblTime.Size = New Size(36, 13)
             Me.lblTime.TabIndex = 6
             Me.lblTime.Text = "Time
             ' 
             ' tbWorkFactor
             ' 
             Me.tbWorkFactor.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.tbWorkFactor.LargeChange = 1
             Me.tbWorkFactor.Location = New Point(558, 408)
             Me.tbWorkFactor.Maximum = 1000
             Me.tbWorkFactor.Minimum = 1
             Me.tbWorkFactor.Name = "tbWorkFactor"
             Me.tbWorkFactor.Size = New Size(123, 45)
             Me.tbWorkFactor.TabIndex = 7
             Me.tbWorkFactor.TickFrequency = 100
             Me.tbWorkFactor.TickStyle = TickStyle.None
             Me.tbWorkFactor.Value = 1
             ' Me.tbWorkFactor.ValueChanged += New System.EventHandler(Me.tbWorkFactor_ValueChanged)
             ' 
             ' label3
             ' 
             Me.label3.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label3.AutoSize = True
             Me.label3.Location = New Point(557, 385)
             Me.label3.Name = "label3"
             Me.label3.Size = New Size(66, 13)
             Me.label3.TabIndex = 8
             Me.label3.Text = "Work Factor"
             ' 
             ' rbParallelFor
             ' 
             Me.rbParallelFor.AutoSize = True
             Me.rbParallelFor.Checked = True
             Me.rbParallelFor.Location = New Point(7, 18)
             Me.rbParallelFor.Name = "rbParallelFor"
             Me.rbParallelFor.Size = New Size(77, 17)
             Me.rbParallelFor.TabIndex = 9
             Me.rbParallelFor.TabStop = True
             Me.rbParallelFor.Text = "Parallel.For"
             Me.rbParallelFor.UseVisualStyleBackColor = True
             ' Me.rbParallelFor.CheckedChanged += New System.EventHandler(Me.rbAPI_CheckedChanged)
             ' 
             ' rbParallelForEach
             ' 
             Me.rbParallelForEach.AutoSize = True
             Me.rbParallelForEach.Location = New Point(6, 41)
             Me.rbParallelForEach.Name = "rbParallelForEach"
             Me.rbParallelForEach.Size = New Size(102, 17)
             Me.rbParallelForEach.TabIndex = 10
             Me.rbParallelForEach.TabStop = True
             Me.rbParallelForEach.Text = "Parallel.ForEach"
             Me.rbParallelForEach.UseVisualStyleBackColor = True
             ' Me.rbParallelForEach.CheckedChanged += New System.EventHandler(Me.rbAPI_CheckedChanged)
             ' 
             ' rbPLINQ
             ' 
             Me.rbPLINQ.AutoSize = True
             Me.rbPLINQ.Location = New Point(6, 64)
             Me.rbPLINQ.Name = "rbPLINQ"
             Me.rbPLINQ.Size = New Size(57, 17)
             Me.rbPLINQ.TabIndex = 11
             Me.rbPLINQ.TabStop = True
             Me.rbPLINQ.Text = "PLINQ"
             Me.rbPLINQ.UseVisualStyleBackColor = True
             ' Me.rbPLINQ.CheckedChanged += New System.EventHandler(Me.rbAPI_CheckedChanged)
             ' 
             ' groupBox1
             ' 
             Me.groupBox1.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.groupBox1.Controls.Add(Me.rbParallelForEach)
             Me.groupBox1.Controls.Add(Me.rbPLINQ)
             Me.groupBox1.Controls.Add(Me.rbParallelFor)
             Me.groupBox1.Location = New Point(557, 12)
             Me.groupBox1.Name = "groupBox1"
             Me.groupBox1.Size = New Size(130, 91)
             Me.groupBox1.TabIndex = 12
             Me.groupBox1.TabStop = False
             Me.groupBox1.Text = "API"
             ' 
             ' label4
             ' 
             Me.label4.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.label4.AutoSize = True
             Me.label4.Location = New Point(556, 436)
             Me.label4.Name = "label4"
             Me.label4.Size = New Size(34, 13)
             Me.label4.TabIndex = 14
             Me.label4.Text = "Cores"
             ' 
             ' tbCores
             ' 
             Me.tbCores.Anchor = (CType((AnchorStyles.Top Or AnchorStyles.Right), AnchorStyles))
             Me.tbCores.LargeChange = 1
             Me.tbCores.Location = New Point(557, 459)
             Me.tbCores.Maximum = 100
             Me.tbCores.Minimum = 0
             Me.tbCores.Name = "tbCores"
             Me.tbCores.Size = New Size(123, 45)
             Me.tbCores.TabIndex = 13
             Me.tbCores.TickStyle = TickStyle.None
             Me.tbCores.Value = 0
             ' Me.tbCores.ValueChanged += New System.EventHandler(Me.tbCores_ValueChanged)
             ' 
             ' MainForm
             ' 
             Me.AutoScaleDimensions = New SizeF(6.0F, 13.0F)
             Me.AutoScaleMode = AutoScaleMode.Font
             Me.ClientSize = New Size(695, 547)
             Me.Controls.Add(Me.btnVisualize)
             Me.Controls.Add(Me.label4)
             Me.Controls.Add(Me.tbCores)
             Me.Controls.Add(Me.groupBox1)
             Me.Controls.Add(Me.label3)
             Me.Controls.Add(Me.tbWorkFactor)
             Me.Controls.Add(Me.lblTime)
             Me.Controls.Add(Me.label2)
             Me.Controls.Add(Me.label1)
             Me.Controls.Add(Me.lvWorkloads)
             Me.Controls.Add(Me.lvPartitioningMethods)
             Me.Controls.Add(Me.pbPartitionedImage)
             Me.Name = "MainForm"
             Me.Text = "Visualize Partitioning"
             CType(Me.pbPartitionedImage, System.ComponentModel.ISupportInitialize).EndInit()
             CType(Me.tbWorkFactor, System.ComponentModel.ISupportInitialize).EndInit()
             Me.groupBox1.ResumeLayout(False)
             Me.groupBox1.PerformLayout()
             CType(Me.tbCores, System.ComponentModel.ISupportInitialize).EndInit()
             Me.ResumeLayout(False)
             Me.PerformLayout()
 
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="267" endline="31"><![CDATA[
 
 #End Region
 
         Private pbPartitionedImage As PictureBox
         Private WithEvents btnVisualize As Button
         Private lvPartitioningMethods As ListView
         Private lvWorkloads As ListView
         Private label1 As Label
         Private label2 As Label
         Private lblTime As Label
         Private WithEvents tbWorkFactor As TrackBar
         Private label3 As Label
         Private WithEvents rbParallelFor As RadioButton
         Private WithEvents rbParallelForEach As RadioButton
         Private WithEvents rbPLINQ As RadioButton
         Private groupBox1 As GroupBox
         Private label4 As Label
         Private WithEvents tbCores As TrackBar
         Private toolTip1 As ToolTip
     End Class
 End Namespace
 
         Private Shared _randomnessSeed As New Random()
         ''' <summary>A thread-safe source of randomness for all threads that need random values.</summary>
         Private Shared _localRandom As New ThreadLocal(Of Random)(Function()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="32" endline="52"><![CDATA[
                                                                       SyncLock _randomnessSeed
                                                                           Return New Random(_randomnessSeed.[Next]())
                                                                       End SyncLock
                                                                   End Function)
 
         Public Sub New()
             InitializeComponent()
 
             ' Configure the workloads and the color palette. The partitioning methods initialization will be done
             ' when the radio button is changed to Parallel.ForEach or PLINQ. The color palette will be
             ' initialized when the cores trackbar changes value.
             InitializeWorkloads()
 
             ' Configure number of cores.
             With tbCores
                 .Minimum = 1
                 .Maximum = Environment.ProcessorCount * 2
                 .Value = Environment.ProcessorCount
             End With
            
         End Sub
 
         ''' <summary>Initializes the color palette to use when rendering threads.</summary>
         Private Sub InitializeColorPalette()
             Dim random As New Random(8)
             ' Change seed value to change the palette used.
             _colors = (From i In Enumerable.Range(0, tbCores.Value)
                 Select Color.FromArgb(random.[Next](128) + 127, random.[Next](128) + 127, random.[Next](128) + 127)).ToArray()
         End Sub
 
         ''' <summary>Initializes the workloads list view.</summary>
         Private Sub InitializeWorkloads()
             lvWorkloads.Items.Clear()
             Dim workloads = New List(Of Tuple(Of String, Func(Of Integer, Integer, Integer)))()
             ' NOTE
             With workloads
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Constant", Function(size, current) 1000 * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Increasing Linear", Function(size, current) 200 * current * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Decreasing Linear", Function(size, current) 200 * (size - current) * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Random", Function(size, current) _localRandom.Value.[Next](100, 10000) * _workFactor))
             End With
 
             For Each workload In workloads
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
         Private components As System.ComponentModel.IContainer = Nothing
             InitializeComponent()
 
             ' Configure the workloads and the color palette. The partitioning methods initialization will be done
             ' when the radio button is changed to Parallel.ForEach or PLINQ. The color palette will be
             ' initialized when the cores trackbar changes value.
             InitializeWorkloads()
 
             ' Configure number of cores.
             With tbCores
                 .Minimum = 1
                 .Maximum = Environment.ProcessorCount * 2
                 .Value = Environment.ProcessorCount
             End With
            
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="53" endline="60"><![CDATA[
 
         ''' <summary>Initializes the color palette to use when rendering threads.</summary>
         Private Sub InitializeColorPalette()
             Dim random As New Random(8)
             ' Change seed value to change the palette used.
             _colors = (From i In Enumerable.Range(0, tbCores.Value)
                 Select Color.FromArgb(random.[Next](128) + 127, random.[Next](128) + 127, random.[Next](128) + 127)).ToArray()
         End Sub
 
         ''' <summary>Initializes the workloads list view.</summary>
         Private Sub InitializeWorkloads()
             lvWorkloads.Items.Clear()
             Dim workloads = New List(Of Tuple(Of String, Func(Of Integer, Integer, Integer)))()
             ' NOTE
             With workloads
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Constant", Function(size, current) 1000 * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Increasing Linear", Function(size, current) 200 * current * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Decreasing Linear", Function(size, current) 200 * (size - current) * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Random", Function(size, current) _localRandom.Value.[Next](100, 10000) * _workFactor))
             End With
 
             For Each workload In workloads
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             Dim random As New Random(8)
             ' Change seed value to change the palette used.
             _colors = (From i In Enumerable.Range(0, tbCores.Value)
                 Select Color.FromArgb(random.[Next](128) + 127, random.[Next](128) + 127, random.[Next](128) + 127)).ToArray()
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="61" endline="78"><![CDATA[
 
         ''' <summary>Initializes the workloads list view.</summary>
         Private Sub InitializeWorkloads()
             lvWorkloads.Items.Clear()
             Dim workloads = New List(Of Tuple(Of String, Func(Of Integer, Integer, Integer)))()
             ' NOTE
             With workloads
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Constant", Function(size, current) 1000 * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Increasing Linear", Function(size, current) 200 * current * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Decreasing Linear", Function(size, current) 200 * (size - current) * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Random", Function(size, current) _localRandom.Value.[Next](100, 10000) * _workFactor))
             End With
 
             For Each workload In workloads
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             For Each workload In workloads
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             lvWorkloads.Items(0).Selected = True
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="79" endline="128"><![CDATA[
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="129" endline="229"><![CDATA[
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="230" endline="244"><![CDATA[
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
             End Try
         End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="245" endline="257"><![CDATA[
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="258" endline="266"><![CDATA[
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="267" endline="270"><![CDATA[
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="31" endline="35"><![CDATA[
         Private Shared _localRandom As New ThreadLocal(Of Random)(Function()
                                                                       SyncLock _randomnessSeed
                                                                           Return New Random(_randomnessSeed.[Next]())
                                                                       End SyncLock
                                                                   End Function)
 
         Public Sub New()
             InitializeComponent()
 
             ' Configure the workloads and the color palette. The partitioning methods initialization will be done
             ' when the radio button is changed to Parallel.ForEach or PLINQ. The color palette will be
             ' initialized when the cores trackbar changes value.
             InitializeWorkloads()
 
             ' Configure number of cores.
             With tbCores
                 .Minimum = 1
                 .Maximum = Environment.ProcessorCount * 2
                 .Value = Environment.ProcessorCount
             End With
            
         End Sub
 
         ''' <summary>Initializes the color palette to use when rendering threads.</summary>
         Private Sub InitializeColorPalette()
             Dim random As New Random(8)
             ' Change seed value to change the palette used.
             _colors = (From i In Enumerable.Range(0, tbCores.Value)
                 Select Color.FromArgb(random.[Next](128) + 127, random.[Next](128) + 127, random.[Next](128) + 127)).ToArray()
         End Sub
 
         ''' <summary>Initializes the workloads list view.</summary>
         Private Sub InitializeWorkloads()
             lvWorkloads.Items.Clear()
             Dim workloads = New List(Of Tuple(Of String, Func(Of Integer, Integer, Integer)))()
             ' NOTE
             With workloads
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Constant", Function(size, current) 1000 * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Increasing Linear", Function(size, current) 200 * current * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Decreasing Linear", Function(size, current) 200 * (size - current) * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Random", Function(size, current) _localRandom.Value.[Next](100, 10000) * _workFactor))
             End With
 
             For Each workload In workloads
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                                                                       End SyncLock
                                                                   End Function)
 
         Public Sub New()
             InitializeComponent()
 
             ' Configure the workloads and the color palette. The partitioning methods initialization will be done
             ' when the radio button is changed to Parallel.ForEach or PLINQ. The color palette will be
             ' initialized when the cores trackbar changes value.
             InitializeWorkloads()
 
             ' Configure number of cores.
             With tbCores
                 .Minimum = 1
                 .Maximum = Environment.ProcessorCount * 2
                 .Value = Environment.ProcessorCount
             End With
            
         End Sub
 
         ''' <summary>Initializes the color palette to use when rendering threads.</summary>
         Private Sub InitializeColorPalette()
             Dim random As New Random(8)
             ' Change seed value to change the palette used.
             _colors = (From i In Enumerable.Range(0, tbCores.Value)
                 Select Color.FromArgb(random.[Next](128) + 127, random.[Next](128) + 127, random.[Next](128) + 127)).ToArray()
         End Sub
 
         ''' <summary>Initializes the workloads list view.</summary>
         Private Sub InitializeWorkloads()
             lvWorkloads.Items.Clear()
             Dim workloads = New List(Of Tuple(Of String, Func(Of Integer, Integer, Integer)))()
             ' NOTE
             With workloads
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Constant", Function(size, current) 1000 * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Increasing Linear", Function(size, current) 200 * current * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Decreasing Linear", Function(size, current) 200 * (size - current) * _workFactor))
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Random", Function(size, current) _localRandom.Value.[Next](100, 10000) * _workFactor))
             End With
 
             For Each workload In workloads
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
                                                   End If
                                                   source.ForAll(Sub(i)
                                                                     Dim id = threadId.Value
                                                                     DoWork(selectedWorkload.Item2(height, i))
                                                                     For j = 0 To width - 1
                                                                         fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                     Next
                                                                 End Sub)
                                               End If
                                           End If
                                           Return sw.Elapsed
                                       End Using
                                   End Function).ContinueWith(Sub(t)
                                                                  ' Dispose of the old image (if there was one) and display the new one.
                                                                  Dim old = pbPartitionedImage.Image
                                                                  pbPartitionedImage.Image = bmp
                                                                  If old IsNot Nothing Then
                                                                      old.Dispose()
                                                                  End If
 
                                                                  ' Re-enable controls on the form and display the elapsed time.
                                                                  btnVisualize.Enabled = True
                                                                  lblTime.Text = "Time
                                                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
         End Sub
 
         ''' <summary>Does an amount of work relative to the amount requested.</summary>
         ''' <param name="workAmount">The amount of work to perform.</param>
         <MethodImpl(MethodImplOptions.NoOptimization Or MethodImplOptions.NoInlining)>
         Private Shared Function DoWork(ByVal workAmount As Integer) As Integer
             Try
                 Dim value = 1
                 For i = 0 To workAmount - 1
                     value = value * workAmount
                 Next i
                 Return value
             Catch
                 Return 0
             End Try
         End Function
 
         ''' <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         ''' <param name="sender">The radio button.</param>
         ''' <param name="e">The event args.</param>
         Private Sub rbAPI_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles rbParallelForEach.CheckedChanged,
             rbPLINQ.CheckedChanged, rbParallelFor.CheckedChanged
             lvPartitioningMethods.Enabled = Not rbParallelFor.Checked
             lvPartitioningMethods.HideSelection = Not lvPartitioningMethods.Enabled
 
             ' Recreate partitioning methods every time a radio button is checked,
             ' as which API is selected determines which partitioning methods are available.
             InitializePartitioningMethods()
         End Sub
 
         Private Sub tbCores_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbCores.ValueChanged
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString())
             InitializeColorPalette()
             Dim worker As Integer
             Dim io As Integer
             ThreadPool.GetMinThreads(worker, io)
             ThreadPool.SetMinThreads(tbCores.Value, io)
         End Sub
 
         Private Sub tbWorkFactor_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbWorkFactor.ValueChanged
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString())
         End Sub
     End Class
 End Namespace
                                                                   End Function)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="36" endline="68"><![CDATA[
 
         Public Sub New()
             InitializeComponent()
 
             ' Configure the workloads and the color palette. The partitioning methods initialization will be done
             ' when the radio button is changed to Parallel.ForEach or PLINQ. The color palette will be
             ' initialized when the cores trackbar changes value.
             InitializeWorkloads()
 
             ' Configure number of cores.
             With tbCores
                 .Minimum = 1
                 .Maximum = Environment.ProcessorCount * 2
                 .Value = Environment.ProcessorCount
             End With
            
         End Sub
 
         ''' <summary>Initializes the color palette to use when rendering threads.</summary>
         Private Sub InitializeColorPalette()
             Dim random As New Random(8)
             ' Change seed value to change the palette used.
             _colors = (From i In Enumerable.Range(0, tbCores.Value)
                 Select Color.FromArgb(random.[Next](128) + 127, random.[Next](128) + 127, random.[Next](128) + 127)).ToArray()
         End Sub
 
         ''' <summary>Initializes the workloads list view.</summary>
         Private Sub InitializeWorkloads()
             lvWorkloads.Items.Clear()
             Dim workloads = New List(Of Tuple(Of String, Func(Of Integer, Integer, Integer)))()
             ' NOTE
             With workloads
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Constant", Function(size, current) 1000 * _workFactor))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="69" endline="69"><![CDATA[
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Increasing Linear", Function(size, current) 200 * current * _workFactor))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="70" endline="70"><![CDATA[
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Decreasing Linear", Function(size, current) 200 * (size - current) * _workFactor))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="71" endline="71"><![CDATA[
                 .Add(Tuple.Create(Of String, Func(Of Integer, Integer, Integer))("Random", Function(size, current) _localRandom.Value.[Next](100, 10000) * _workFactor))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="72" endline="89"><![CDATA[
             End With
 
             For Each workload In workloads
                 lvWorkloads.Items.Add(New ListViewItem(workload.Item1) With {.Tag = workload})
             Next
             lvWorkloads.Items(0).Selected = True
         End Sub
 
         ''' <summary>Initializes the partitioning methods list view.</summary>
         Private Sub InitializePartitioningMethods()
             lvPartitioningMethods.Items.Clear()
             Dim usingPLINQ As Boolean = rbPLINQ.Checked
             Dim partitioningMethods = New List(Of Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))()
 
             ' Static partitioning using the Partitioner.Create overload requires static partitioner support,
             ' which Parallel.ForEach does not provide.
             If usingPLINQ Then
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Static", Function(e) partitioner.Create(e, False)))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="90" endline="94"><![CDATA[
             End If
 
             ' Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach.
             With partitioningMethods
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Load Balance", Function(e) partitioner.Create(e, True)))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="95" endline="95"><![CDATA[
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(1)", Function(e) ChunkPartitioner.Create(e, 1)))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="96" endline="96"><![CDATA[
                 .Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))("Dynamic(16)", Function(e) ChunkPartitioner.Create(e, 16)))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="97" endline="109"><![CDATA[
                 .Add(Tuple.Create(Of String,  _
                 Func(Of Integer(), Partitioner(Of Integer)))("Guided", Function(e) ChunkPartitioner.Create(e, Function(prev)
                                                                                                                   If prev <= 0 Then
                                                                                                                       Return If(e.Length <= 1, 1,
                                                                                                                                 CType(e.Length /
                                                                                                                                     (Environment.ProcessorCount * 3), Integer))
                                                                                                                   End If
                                                                                                                   Dim [next] = CType(prev / 2, Integer)
                                                                                                                   Return If([next] <= 0, prev, [next])
                                                                                                               End Function)))
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(),  _
                                              Partitioner(Of Integer)))("Grow Exponential", Function(e) ChunkPartitioner.Create(e, Function(prev) If(prev <= 0, 1, prev * 2))))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="110" endline="119"><![CDATA[
                 .Add(Tuple.Create(Of String,  _
                                         Func(Of Integer(), Partitioner(Of Integer)))("Random", Function(e) ChunkPartitioner.Create(e, Function(prev) _localRandom.Value.[Next](e.Length))))
 
             End With
 
             ' Special-case some PLINQ-only hashing.
             If usingPLINQ Then
                 ' The actual enabling of these partitioning schemes is done later, as they can't 
                 ' be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningStripe, Function(e) partitioner.Create(e)))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="120" endline="120"><![CDATA[
                 partitioningMethods.Add(Tuple.Create(Of String, Func(Of Integer(), Partitioner(Of Integer)))(PartitioningHash, Function(e) partitioner.Create(e)))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="121" endline="202"><![CDATA[
             End If
 
             ' Dump the partitioners into the list view.
             For Each method In partitioningMethods
                 lvPartitioningMethods.Items.Add(New ListViewItem(method.Item1) With {.Tag = method})
             Next
             lvPartitioningMethods.Items(0).Selected = True
         End Sub
 
         ''' <summary>Visualize the partitioning.</summary>
         Private Sub btnVisualize_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnVisualize.Click
             Dim numProcs = tbCores.Value
             Dim width = pbPartitionedImage.Width
             Dim height = pbPartitionedImage.Height
             Dim useParallelFor = rbParallelFor.Checked
             Dim useParallelForEach = rbParallelForEach.Checked
             _workFactor = tbWorkFactor.Value
 
             ' If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it.
             Dim selectedMethod As Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))) = Nothing
             If Not useParallelFor Then
                 If lvPartitioningMethods.SelectedIndices.Count = 0 Then
                     Exit Sub
                 Else
                     selectedMethod = DirectCast(lvPartitioningMethods.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer(), Partitioner(Of Integer))))
                 End If
             End If
 
             ' Make sure a workload was selected and use it.
             If lvWorkloads.SelectedItems.Count = 0 Then
                 Exit Sub
             End If
 
             Dim selectedWorkload = DirectCast(lvWorkloads.SelectedItems(0).Tag, Tuple(Of String, Func(Of Integer, Integer, Integer)))
 
             ' Create a new Bitmap to store the rendered output
             Dim bmp = New Bitmap(width, height)
 
             ' Disable the start button and kick off the background work.
             btnVisualize.Enabled = False
             ' Assign each thread a unique id.
             ' Get faster access to the Bitmap's contents.
             ' Time the operation.
             ' Create the partitioner to be used.
             ' Run the work with Parallel.ForEach
             ' PLINQ.
             ' Run the work with PLINQ. If a special partitioning method was selected, use relevant query operators
             ' to get PLINQ to use that partitioning approach.
             ' Return the total time from the task
             ' When the work completes, run the following on the UI thread.
 
             Task.Factory.StartNew(Function()
                                       Dim nextId = -1
                                       Dim threadId = New ThreadLocal(Of Integer)(Function() Interlocked.Increment(nextId))
                                       Using fastBmp As New FastBitmap(bmp)
                                           Dim sw = Stopwatch.StartNew()
                                           If useParallelFor Then
                                               If fastBmp Is Nothing Then
                                                   MsgBox("FastBmp Disposed")
                                               End If
                                               Parallel.[For](0, height, New ParallelOptions(), Sub(i)
                                                                                                    Dim id = threadId.Value
                                                                                                    DoWork(selectedWorkload.Item2(height, i))
 
                                                                                                    For j = 0 To width - 1
                                                                                                        fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                    Next
                                                                                                End Sub)
                                           Else
                                               Dim partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray())
                                               If useParallelForEach Then
                                                   Parallel.ForEach(partitioner, New ParallelOptions(), Sub(i)
                                                                                                            Dim id = threadId.Value
                                                                                                            DoWork(selectedWorkload.Item2(height, i))
                                                                                                            For j = 0 To width - 1
                                                                                                                fastBmp.SetColor(j, i, _colors(id Mod _colors.Length))
                                                                                                            Next
                                                                                                        End Sub)
                                               Else
                                                   Dim source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs)
                                                   If selectedMethod.Item1 = PartitioningStripe Then
                                                       source = source.TakeWhile(Function(elem) True)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="203" endline="204"><![CDATA[
                                                   ElseIf selectedMethod.Item1 = PartitioningHash Then
                                                       source = source.Join(Enumerable.Range(0, height).AsParallel(), Function(i) i, Function(i) i, Function(i, ignore) i)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\MainForm.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\Module1.vb" startline="7" endline="11"><![CDATA[
         Sub Main()
             Application.EnableVisualStyles()
             Application.SetCompatibleTextRenderingDefault(False)
             Application.Run(New MainForm())
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\My Project\Resources.Designer.vb" startline="38" endline="44"><![CDATA[
 			Get
 				If (resourceMan Is Nothing) Then
 					Dim temp As New Global.System.Resources.ResourceManager("Resources", GetType(Resources).Assembly)
 					resourceMan = temp
 				End If
 				Return resourceMan
 			End Get
 		End Property
 
 		''' <summary>
 		'''   Overrides the current thread's CurrentUICulture property for all
 		'''   resource lookups using this strongly typed resource class.
 		''' </summary>
 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
 		Friend Property Culture() As Global.System.Globalization.CultureInfo
 			Get
 				Return resourceCulture
 			End Get
 			Set(ByVal value As System.Globalization.CultureInfo)
 				resourceCulture = value
 			End Set
 		End Property
 	End Module
 End Namespace
 					Dim temp As New Global.System.Resources.ResourceManager("Resources", GetType(Resources).Assembly)
 					resourceMan = temp
 				End If
 				Return resourceMan
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\My Project\Resources.Designer.vb" startline="45" endline="55"><![CDATA[
 		End Property
 
 		''' <summary>
 		'''   Overrides the current thread's CurrentUICulture property for all
 		'''   resource lookups using this strongly typed resource class.
 		''' </summary>
 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
 		Friend Property Culture() As Global.System.Globalization.CultureInfo
 			Get
 				Return resourceCulture
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\My Project\Resources.Designer.vb" startline="56" endline="58"><![CDATA[
 			Set(ByVal value As System.Globalization.CultureInfo)
 				resourceCulture = value
 			End Set
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\My Project\Settings.Designer.vb" startline="19" endline="19"><![CDATA[
         Private Shared defaultInstance As Settings = (CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New Settings()), Settings))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_VisualBasic\My Project\Settings.Designer.vb" startline="20" endline="24"><![CDATA[
 
         Public Shared ReadOnly Property [Default]() As Settings
             Get
                 Return defaultInstance
             End Get
]]></source>
</source_elements></project>
